<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Joe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="enjoy life">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe's Blog">
<meta property="og:url" content="http://yuqiao.github.io/page/2/">
<meta property="og:site_name" content="Joe's Blog">
<meta property="og:description" content="enjoy life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe's Blog">
<meta name="twitter:description" content="enjoy life">

  
    <link rel="alternative" href="/atom.xml" title="Joe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Carpe Diem</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yuqiao.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-scala快学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/scala快学/" class="article-date">
  <time datetime="2015-03-07T01:10:50.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/scala快学/">快学scala</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_基础">1 基础</h1>
<h2 id="scala解释器">scala解释器</h2>
<h2 id="声明值和变量">声明值和变量</h2>
<p>变量或函数的类型总是写在变量或函数名称的后面。 使得我们更容易阅读那些负责类型的声明。</p>
<pre><code><span class="keyword">val</span> greeting: String = <span class="keyword">null</span>
<span class="keyword">val</span> greeting: Any = <span class="string">"Hello"</span>
</code></pre><p>可以将多个值或变量放在一起声明:</p>
<pre><code>val xmax, ymax = <span class="number">100</span> <span class="comment">//将xmax和ymax设为100</span>
valgreeting, message: <span class="built_in">String</span> = <span class="literal">null</span>
</code></pre><h2 id="常用类型">常用类型</h2>
<p>7种数值类型： Byte, Char, Short, Int, Long, Float和Double, Boolean</p>
<p>不需要包装类型，基本类型和包装类型自己的转换是scala编译器的工作。</p>
<p>在scala中，我们用方法，而不是强制类型转换， 来做数值类型之间的转换：</p>
<pre><code><span class="number">99.44</span>.toInt <span class="comment">//= 99</span>
<span class="number">99.</span>toChar   <span class="comment">//='c'</span>
</code></pre><h2 id="算术和操作符重载是">算术和操作符重载是</h2>
<p>“a 方法 b”  是 “a.方法(b)” 的简写</p>
<p>scala没有++， — 操作符</p>
<h2 id="apply方法">apply方法</h2>
<p>“hello”(4)是”hello”.apply(4)的缩写。</p>
<p>使用伴生对象的apply方法。</p>
<h2 id="Scaladoc">Scaladoc</h2>
<p>www.scala-lang.org/api<br>或者www.scala-lang.org/downloads#api</p>
<p>类名旁边的O(伴生对象）和C（类）</p>
<p>scala文档小窍门:</p>
<ul>
<li>想使用数值类型， 记得看看RichInt, RichDouble等， 字符串，记得看看StringOps.</li>
<li>数值函数位于scala.math包中。</li>
<li>名称比较奇怪的函数。 如BigInt有个方法unary_-, 就是你定义前置的负操作符-x的方式</li>
<li>标记位implicit的方法对应的是自动（隐式）转换。</li>
<li>方法可以以函数为常数</li>
</ul>
<h1 id="2_控制结构和函数">2 控制结构和函数</h1>
<h2 id="变长参数">变长参数</h2>
<p>使用Int<em>, 若传入的数组后面要加上”:_</em>“转换</p>
<pre><code>def sum(args:<span class="type">Int</span>*) = {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="number">0</span>
  <span class="keyword">for</span>(arg &lt;- args) <span class="literal">result</span> += arg
  <span class="literal">result</span>
}
val s = sum(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>)
val s2 = sum(<span class="number">1</span> to <span class="number">10</span>: _*)
</code></pre><h2 id="懒值">懒值</h2>
<p>但val被声明为lazy时，它的初始化将被推迟，直到我们首次对它取值。</p>
<p>lazy val words = scala.io.Source.fromFile(“/usr/share/dict/words”).mkString</p>
<h2 id="异常">异常</h2>
<p>throws表达式有特殊的类型Nothing.</p>
<h1 id="3_数组相关操作">3 数组相关操作</h1>
<p>要点：</p>
<ul>
<li>长度固定使用Array， 长度可能变化用ArrayBuffer</li>
<li>提供初始值不用使用new</li>
<li>用()来访问元素</li>
<li>用for(elem &lt;- arr)来遍历元素</li>
<li>用for(elem &lt;- arr if …)… yeild .. 来将原数组转型为新数组</li>
<li>scala数组和Java数组可以互操作；用ArrayBuffer, 使用scala.collection.JavaConversions中的转换函数。</li>
</ul>
<h2 id="与java的互操作">与java的互操作</h2>
<p>转成java的List:</p>
<pre><code>import scala.collection.JavaConversions.bufferAsJavaList
val <span class="command"><span class="keyword">command</span> = <span class="title">ArrayBuffer</span>(<span class="string">"ls"</span>, <span class="string">"-la"</span>, <span class="string">"/home/"</span>)</span>
val pb = <span class="built_in">new</span> ProcessBuilder(<span class="command"><span class="keyword">command</span>)</span>
</code></pre><p>将java的List转成BufferArray:</p>
<pre><code>import scala.collection.JavaConversions.asScalaBuffer
<span class="keyword">val</span> cmd:<span class="keyword">mutable</span>.Buffer[String] = pb.command()
</code></pre><h1 id="4_映射和元组">4 映射和元组</h1>
<pre><code>val scores <span class="subst">=</span> <span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
val ms <span class="subst">=</span> scala<span class="built_in">.</span>collection<span class="built_in">.</span>mutable<span class="built_in">.</span><span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
println(scores(<span class="string">"Bob"</span>))
println(scores<span class="built_in">.</span>getOrElse(<span class="string">"yuqiao"</span>, <span class="number">0</span>))
</code></pre><p>与Java的互操作：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap</span>
</code></pre><p>使用zip:</p>
<pre><code>val symbols = Array(<span class="string">"&lt;"</span>, <span class="string">"-"</span>, <span class="string">"&gt;"</span>)
val counts = Array(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)
val <span class="built_in">pairs</span> = symbols.zip(counts)
<span class="keyword">for</span>((k,v)&lt;-<span class="built_in">pairs</span>){
  <span class="built_in">print</span>(k*v)
}
</code></pre><p>使用toMap将对偶集合转换成映射Map.</p>
<h1 id="5_类">5 类</h1>
<p>要点:</p>
<ul>
<li>类中字段自动带有getter和setter方法</li>
<li>可以用定制的getter/setter方法替换掉字段的定义</li>
<li>用@BeanProperty注解来生成JavaBeans的getXXX/setXXX方法</li>
<li>每个类都有一个主要的构造器, 它的参数直接成为类的字段。</li>
<li>辅助构造器是可选的， 叫做this.</li>
</ul>
<p>定义类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>{
    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span>
    <span class="keyword">def</span> increment() { value +=<span class="number">1</span>}
    <span class="keyword">def</span> current() = value
}

<span class="keyword">val</span> myCounter = <span class="keyword">new</span> Counter
myCounter.increment()        <span class="comment">//对改值器使用()</span>
println(myCounter.current)   <span class="comment">//对取值器不使用()</span>
</code></pre><p>在scala中， getter和setter分别是age和age_=</p>
<p>统一访问原则</p>
<p>对象私有字段</p>
<p>Bean属性</p>
<p>主构造器:</p>
<pre><code><span class="keyword">class</span> Person(val name:String, val age: <span class="keyword">Int</span>) {

<span class="keyword">def</span> <span class="keyword">description</span> = name + <span class="string">" is "</span> + age + <span class="string">" years old"</span>
}
</code></pre><p>Martin Odesky建议: 在scala中, 类也接受参数， 就像方法一样。</p>
<p>嵌套类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(val name:String)</span></span>{
        <span class="keyword">val</span> contacts = <span class="keyword">new</span> ArrayBuffer[Member]()
    }

    <span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> ArrayBuffer[Member]()

    <span class="keyword">def</span> join(name:String)={
        <span class="keyword">val</span> m = <span class="keyword">new</span> Member(name)
        members += m
        m
    }
}

<span class="keyword">val</span> chatter = <span class="keyword">new</span> Network
<span class="keyword">val</span> myFace = <span class="keyword">new</span> Network
</code></pre><p>每个实例都有它自己的Member类。chatter.Member和myFace.Member是不同的类。</p>
<p>可以放在Network的伴生对象。</p>
<h1 id="6_对象">6 对象</h1>
<p>scala没有静态方法或静态字段， 可以用object这个语法结构达到同样目的。</p>
<p>枚举通过扩展Enumeration实现：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrafficColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>{
    <span class="keyword">type</span> TrafficColor = Value
    <span class="keyword">val</span> Red, Yellow, Geen = Value
}

<span class="keyword">def</span> doWhat(color: TrafficColor) ={
  <span class="keyword">if</span>(color == Red)  <span class="string">"stop"</span>
  <span class="keyword">else</span> <span class="keyword">if</span>(color==Geen) <span class="string">"go"</span>
  <span class="keyword">else</span> <span class="string">"hurry up"</span>
}

<span class="keyword">def</span> testEnum(): Unit = {
  <span class="keyword">for</span>(c &lt;- TrafficColor.values) println(c.id + <span class="string">":"</span> + c + <span class="string">" "</span> + doWhat(c))
}
</code></pre><h1 id="7_包和引入">7 包和引入</h1>
<p>要点:</p>
<ul>
<li>包也可以像内部类那样嵌套</li>
<li>包路径不是绝对路径</li>
<li>包声明链x.y.z并不自动将中间包x.y变成可见</li>
<li>位于文件顶部不带花括号的包声明在整个文件范围内有效</li>
<li>包对象可以持有函数和变量</li>
<li>引入语句可以引入包，类和对象</li>
<li>引入语句可以出现在任何地方</li>
<li>引入语句可以重命名和隐藏特定成员</li>
<li>java.lang, scala和predef总是被引入</li>
</ul>
<h1 id="8_继承">8 继承</h1>
<p>要点:</p>
<ul>
<li>extends, final关键字和java相同</li>
<li>重写方法必须用override</li>
<li>只有主构造器可以钓鱼超类的主构造器</li>
<li>你可以重写字段</li>
</ul>
<p>类型检查和转换:</p>
<pre><code><span class="keyword">if</span>(p.isInstanceOf[Employee]){
    val s = p.asInstanceOf[Employee]
    <span class="keyword">...</span>
}
</code></pre><p>若想测试p指向的是一个Employee对象但又不是其子类：</p>
<pre><code><span class="keyword">if</span>(p.getClasss == <span class="class"><span class="keyword">class</span><span class="title">Of</span>[<span class="title">Employee</span>])</span>
</code></pre><p>classOf定义在scala.Predef对象中。</p>
<p>模式匹配通常是更好的选择：</p>
<pre><code>p match {
    case s:Employee =&gt; <span class="keyword">...</span> // 将s作为Employee处理
    case _ =&gt; // p 不是Employee
}
</code></pre><p>超类的构造：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(name: String, age: Int, val salary: Double)</span><span class="keyword">extends</span> <span class="title">Person</span><span class="params">(name, age)</span></span>
</code></pre><p>可以用val重写抽象def. 但def只能重写def, var只能重写另一个抽象的var</p>
<p>匿名子类：</p>
<pre><code>val alien = <span class="keyword">new</span> Person(<span class="string">"Fred"</span>) {
    <span class="keyword">def</span> greeting = <span class="string">"Greetings, Earthinling! My name is Fred!"</span>
}

<span class="keyword">def</span> meet(p: Person{<span class="keyword">def</span> greeting: String}){
    <span class="keyword">println</span>(p.name +<span class="string">"says: "</span> + p.greeting)
}
</code></pre><p>抽象类：用abstract标记不能实例化的类。</p>
<p>重写超类的抽象方法， 不需要override.</p>
<p>类可以有抽象字段。</p>
<p>构造顺序和提前定义。 </p>
<p>提前定义， 让你可以在超类的构造器之前初始化子类的val字段：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Ant</span> <span class="keyword">extends</span> </span>{
    <span class="keyword">override</span> <span class="keyword">val</span> range = <span class="number">2</span>
} <span class="keyword">with</span> Creature
</code></pre><h2 id="Scala继承层级">Scala继承层级</h2>
<p>基本类型和Unit， 都扩展自AnyVal<br>类都扩展自AnyRef.</p>
<p>AnyVal和AnyRef的基类是Any。Any是根节点.</p>
<p>Any类定义了isInstanceOf, asInstanceOf方法， 以及用于相等性判断和哈希码的方法<br>AnyRef追加了来着Object类的监视方法wait和notify/notifyAll.</p>
<h2 id="对象相等性">对象相等性</h2>
<pre><code><span class="keyword">final</span> override <span class="keyword">def</span> equals(other: <span class="keyword">Any</span>){
    val that = other.asInstanceOf[Item]
    <span class="keyword">if</span>(that == <span class="keyword">null</span>) <span class="keyword">false</span>
    <span class="keyword">else</span> <span class="keyword">description</span> == that.<span class="keyword">description</span> &amp;&amp; price == that.price
}
</code></pre><p>注意：</p>
<ul>
<li>方法定义为final</li>
<li>equals方法参数类型为Any.</li>
<li>定义equals时，记得同事也定义hashCode, 计算hashCode时，只应使用那些你用来做相等性判断的字段。</li>
</ul>
<p>::</p>
<pre><code>final override def hashCode = 13 <span class="keyword">*</span>description<span class="keyword">*</span>.hashCode +17 <span class="keyword">*</span> price.hashCode
</code></pre><h1 id="9_文件和正则表达式">9 文件和正则表达式</h1>
<p>要点:</p>
<ul>
<li>Source.fromFile(…).getLines.toArray 输出文件的所有行</li>
<li>Source.fromFile(…).mkString 以字符串形式输出文件内容</li>
<li>将字符串转成数字， 可以用toInt或toDouble方法。</li>
<li>使用Java的PrintWriter写入文件</li>
<li>“正则”.r是一个Regex对象。</li>
<li>若你的正则表达式包含反斜杠或者引号的话，用”””…”””</li>
<li>若正则模式包含分组，使用一些预发提取它们的内容： for(regex(变量,…,变量n)&lt;- 字符串）</li>
</ul>
<h2 id="读取">读取</h2>
<p>从文件:</p>
<pre><code><span class="keyword">import</span> scala.io.Source
<span class="keyword">val</span> source = Source.fromFile(<span class="string">"myfile.txt"</span>, <span class="string">"UTF-8"</span>)
<span class="keyword">val</span> lineIterator = source.getLines
<span class="keyword">val</span> tokens = source.mkString.split(<span class="string">"\\S+"</span>)
<span class="keyword">val</span> numbers = <span class="keyword">for</span>( w&lt;- tokens) <span class="keyword">yield</span> w.toDouble
<span class="keyword">val</span> numbers = tokens.map(_.toDouble)
</code></pre><p>从控制台读取:</p>
<pre><code>val age = <span class="built_in">read</span>Int()
</code></pre><p>其它源：</p>
<pre><code>val <span class="built_in">source</span>1 = Source.fromURL(<span class="string">"http://horstamnn.com"</span>, <span class="string">"UTF-8"</span>)
val <span class="built_in">source</span>2 = Source.fromString(<span class="string">"Hello, Wolle"</span>)
val <span class="built_in">source</span>3 = Source.stdin
</code></pre><p>二进制文件:</p>
<pre><code>val <span class="built_in">file</span>  = <span class="built_in">new</span> File(filename)
val <span class="operator">in</span>  = <span class="built_in">new</span> FileInputStream(<span class="built_in">file</span>)
val <span class="keyword">bytes</span> = <span class="built_in">new</span> Array[Byte](<span class="built_in">file</span>.<span class="built_in">length</span>.toInt)
<span class="operator">in</span>.<span class="built_in">read</span>(<span class="keyword">bytes</span>)
<span class="operator">in</span>.<span class="built_in">close</span>()
</code></pre><h2 id="写入">写入</h2>
<pre><code>val <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="string">"numbers.txt"</span>)
<span class="keyword">for</span>(i&lt;-<span class="number">1</span> <span class="keyword">to</span> <span class="number">100</span>)<span class="keyword">out</span>.println(i)
<span class="keyword">out</span>.close()
</code></pre><h2 id="访问目录">访问目录</h2>
<pre><code><span class="keyword">import</span> java.io.File

<span class="function"><span class="keyword">def</span> <span class="title">subdirs</span><span class="params">(dir:File)</span>:</span> Iterator[File] = {
    val children = dir.listFiles.filter(_.isDirectory)
    children.toIterator ++ children.toIterator.flatMap(subdirs _)
}
</code></pre><p>在scala中， 我们通常喜欢用函数对象来制定过着内容。</p>
<pre><code><span class="reserved">import</span> java.nio.file._
implicit def makeFileVistor<span class="function"><span class="params">(f: (Path) =&gt; Unit)</span>= <span class="title">new</span> <span class="title">SimpleFileVisitor</span>[<span class="title">Path</span>] {
    <span class="title">override</span> <span class="title">def</span> <span class="title">visitFile</span><span class="params">(p: Path, attrs: attribute.BasicFileAttributes)</span>= {
        <span class="title">f</span><span class="params">(p)</span>
        <span class="title">FileVisitResult</span>.<span class="title">CONTINUE</span>
    } 
}

<span class="title">Files</span>.<span class="title">walkFileTree</span><span class="params">(dir.toPath, (f:Path) =&gt;println(f))</span></span>
</code></pre><h2 id="序列化">序列化</h2>
<pre><code><span class="annotation">@SerialVersionUID</span>(<span class="number">42</span>L) <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Serilizable</span></span>
</code></pre><h2 id="进程控制">进程控制</h2>
<p>scala.sys.process包提供了与shell程序交互的工具。</p>
<pre><code><span class="keyword">import</span> sys.process._
<span class="string">"ls -al .."</span>!   <span class="comment">//执行结果打印到标准输出</span>
val result = <span class="string">"ls -al .."</span> !! <span class="comment">// !! 返回字符串</span>
<span class="string">"ls -al .."</span> #&gt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>)  <span class="comment">// #&gt; 重定向到文件</span>
<span class="string">"ls -al .."</span> #&gt;&gt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>)  <span class="comment">// #&gt;&gt; 追加到文件末尾</span>
<span class="string">"grep sec"</span> #&lt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>) <span class="comment">// #&lt; 把文件内容作为输入</span>
<span class="string">"grep Scala"</span> #&lt; <span class="keyword">new</span> URL(<span class="string">"http://horstmann.com/index.html"</span>) 
</code></pre><h2 id="正则表达式">正则表达式</h2>
<pre><code><span class="keyword">val</span> numPattern = <span class="string">"[0-9]+"</span>.r 
<span class="keyword">for</span> (matchString &lt;- numPattern.findAllIn(<span class="string">"99 bottles, 98 bottles"</span>) )
    处理matchString  <span class="comment">// 99, 98</span>

<span class="keyword">val</span> m1 = numPattern.findFirstIn(<span class="string">"99 bottles, 98 bottles"</span>) <span class="comment">//Some()</span>
numPattern.findPrefixOf(<span class="string">"99 bottles, 98 bottles"</span>) <span class="comment">// Some(99)</span>
</code></pre><h2 id="正则表达式组">正则表达式组</h2>
<pre><code>val numitemPatten = <span class="string">"([0-9]+) ([a-z]+)"</span>.r
val numitemPatten(<span class="built_in">num</span>, <span class="keyword">item</span>) = <span class="string">"99 bottles"</span><span class="comment"> // num 设置为99 ， item设置为"bottles"</span>

<span class="keyword">for</span> (numitemPatten(<span class="built_in">num</span>, <span class="keyword">item</span>) &lt;- numitemPatten.findAllIn(<span class="string">"99 bottles, 98 bottles"</span>) )
    处理<span class="built_in">num</span>, <span class="keyword">item</span>
</code></pre><h1 id="10_特质">10 特质</h1>
<p>要点：</p>
<ul>
<li>类可以实现任意数量的特质</li>
<li>特质要求实现他们的类具备特定的字段， 方法或超类</li>
<li>和Java接口不同，Scala特质可以提供方法和字段的实现</li>
<li>但你将多个特质叠加在一起时，顺序很重要 — 其方法先被执行的特质排在更后面</li>
</ul>
<h2 id="d当做接口使用的特质">d当做接口使用的特质</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>{
    <span class="keyword">def</span> log(msg: String)
}
</code></pre><p>子类可以给出实现：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">def</span> log(msg: String) { println(msg)}
}
</code></pre><h2 id="带有具体实现的特质">带有具体实现的特质</h2>
<h2 id="带有特质的对象">带有特质的对象</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Logged</span> </span>{
    <span class="keyword">def</span> log(msg: String){}
}
<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">Logged</span> </span>{
    <span class="keyword">def</span> withdraw(amount:Double){
        <span class="keyword">if</span>(amout &gt; balance) log(<span class="string">"INsufficient funds"</span>)
        <span class="keyword">else</span> ...
    }
}
</code></pre><p>可以在构造具体对象时”混入”一个更好的日志记录器的实现：</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String) { println(msg)}
}
<span class="keyword">val</span> acct = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> ConsoleLogger
<span class="keyword">val</span> acct2 = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> FileLogger
</code></pre><h2 id="叠加在一起的特质">叠加在一起的特质</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String){
        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.Date() +<span class="string">" "</span> +msg)
    }
}

<span class="class"><span class="keyword">trait</span> <span class="title">ShorLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String){
        <span class="keyword">super</span>.log(
            <span class="keyword">if</span>(msg.length&lt;=maxLength) msg <span class="keyword">else</span> msg.substring(<span class="number">0</span>, maxLength -<span class="number">3</span>) + <span class="string">"..."</span>)
    }
}

<span class="keyword">val</span> acct1 = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> ConsoleLogger <span class="keyword">with</span> TimestampLogger <span class="keyword">with</span> ShorLogger
acct1.withdraw() <span class="comment">// 打印： Wed Mar 18 07:40:16 CST 2015 Insufficient...</span>
</code></pre><p>特质从最后一个开始处理.</p>
<h2 id="重写抽象方法">重写抽象方法</h2>
<p>需要加上abstract关键字。</p>
<h2 id="特质中的字段">特质中的字段</h2>
<p>具体字段和抽象字段。</p>
<h2 id="特质的构造顺序">特质的构造顺序</h2>
<ul>
<li>首先调用超类的构造器</li>
<li>特质构造器在超类构造器之后，类构造器之前咨询</li>
<li>特质从左到右构造</li>
<li>每个特质当中，父特质先被构造</li>
<li>若多个特质共有一个父特质，那么父特质构造只会被构造一次</li>
<li>特质构造完毕后，子类被构造</li>
</ul>
<h2 id="初始化特质的字段">初始化特质的字段</h2>
<p>trait FileLogger extends Logger {<br>    val filename:String<br>    val out = new PrintStream(filename)<br>    def log(msg: String) { out.println(msg);out.flush() }<br>}</p>
<p>提前定义：</p>
<pre><code><span class="keyword">val</span> acct = <span class="keyword">new</span> {
    <span class="keyword">val</span> filename = <span class="string">"myapp.log"</span>
} <span class="keyword">with</span> SavingsAccount <span class="keyword">with</span> FileLogger

<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> </span>{
    <span class="keyword">val</span> filename = <span class="string">"saving.log"</span>
} <span class="keyword">with</span> Account <span class="keyword">with</span> FileLogger {
    ...
}
</code></pre><h2 id="自身类型">自身类型</h2>
<p>可限定被混入指定类型的子类。</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">LoggedException</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">this</span>:Exception =&gt;
        <span class="keyword">def</span> log() { log(getMessage())}
}

<span class="keyword">val</span> f = <span class="keyword">new</span> JFrame <span class="keyword">with</span> LoggedException <span class="comment">// Error：JFrame不是Exception的子类。</span>

<span class="class"><span class="keyword">trait</span> <span class="title">LoggedException</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">this</span>: { <span class="keyword">def</span> getMessage() :String } =&gt;
    <span class="keyword">def</span> log(){log(getMessage()}
} <span class="comment">// 特质可以混入任何拥有getMessage方法的类</span>
</code></pre><h1 id="11_操作符">11 操作符</h1>
<p>要点：</p>
<ul>
<li>标识符由字母，数字或运算符构成</li>
<li>一元和二元操作符其实是方法调用</li>
<li>操作符优先级取决于第一个字符，而结合性取决于最后一个字符</li>
<li>apply和update方法在对expr(args)表达式求值时被调用。</li>
<li>提取器从输入中提取元组或值的序列</li>
</ul>
<p>前置操作符(+,-,!, ~) 被转换成名为unary_操作符的方法调用。</p>
<pre><code>-a  <span class="comment">// a.unary_- 一样</span>
</code></pre><h2 id="apply和update方法">apply和update方法</h2>
<p>f(arg1, arg2, …) // =&gt; f.apply(arg1, arg2, …)</p>
<p>f(arg1, arg2, …) = value // =&gt; f.update(arg1, arg2, …, value)</p>
<p>被用于数组和映射。</p>
<p>apply进程用于伴生对象中， 用来构造对象而不用显式使用new.</p>
<pre><code>class Fraction(n: Int, d: Int){
    <span class="keyword">...</span>
}

object Fraction {
    def apply(n:Int, d:Int)= new Fraction(n,d)
}
</code></pre><h2 id="提取器">提取器</h2>
<p>如前所示，apply从分子和分母创建一个分数。而unapply方法就是取出分子和分母：</p>
<pre><code><span class="attribute">var Fraction(a,b) </span>=<span class="string"> Fraction(3,4) *Fraction(2,5)</span>
</code></pre><p>或者用于模式匹配：</p>
<pre><code>case Fraction(a,b) =&gt; <span class="keyword">...</span> // a, b 被绑定到分子和分母
</code></pre><p>unapply方法返回的是一个Option, 包含一个元组：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Fraction</span> </span>{
    <span class="keyword">def</span> unapply(input:Fraction) =
        <span class="keyword">if</span>(input.den == <span class="number">0</span>) None <span class="keyword">else</span> Some((input.num, input.den))
}
</code></pre><p>样例类自动具备apply和unapply方法。</p>
<p>带来单个参数：</p>
<pre><code>object Number {
    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span><span class="params">(input: String)</span>:</span> Option[Int] = 
        <span class="keyword">try</span>{
            Some(Integer.parseInt(input.trim)
        }catch{
            case ex: NumberFormatException =&gt;<span class="keyword">None</span>
        }
}

val Number(n) = <span class="string">"1729"</span>
</code></pre><p>提取器只是测试输入：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">IsCompound</span> </span>{
    <span class="keyword">def</span> unapply(input: String)= input.contains(<span class="string">" "</span>)
}
</code></pre><p>给模式增加一个测试:</p>
<pre><code>authon match {
    case Name(first, last @ IsCompound()) =&gt; <span class="keyword">...</span>
    case Name(first, last) =&gt; <span class="keyword">...</span>
}
</code></pre><h2 id="unapplySeq方法">unapplySeq方法</h2>
<p>要提取任意长度的值的序列， 使用unapplySeq:</p>
<pre><code>object Nmae {
    def unapplySeq(input: String): Option[Seq[String]] =
        <span class="keyword">if</span>(input.trim == <span class="string">""</span>) None <span class="keyword">else</span> Some(input.trim.split(<span class="string">"\\s+"</span>))
}

author match {
    case Name(first, last) =&gt; <span class="keyword">...</span>
    case Name(first, middle, last) =&gt; <span class="keyword">...</span>
    case Name(first, <span class="string">"van"</span>, <span class="string">"der"</span>, last) =&gt; <span class="keyword">...</span>
}
</code></pre><h1 id="12_高阶函数">12 高阶函数</h1>
<p>要点：</p>
<ul>
<li>函数是“头等公民”， 跟数字一样</li>
<li>可创建匿名函数， 一般交给其他函数</li>
<li>函数参数可以给出需要稍后执行的行为</li>
<li>许多集合方法都接受函数参数</li>
<li>有很多预发简写</li>
<li>可以参加操作代码块的函数，看上去像内建的控制语句</li>
</ul>
<p>作为值的函数：</p>
<pre><code><span class="keyword">val</span> num = <span class="number">3.14</span>
<span class="keyword">val</span> <span class="keyword">fun</span> = ceil _  <span class="comment">// _ 意味着你确实自动是这个函数。从技术上讲_将ceil方法转成了函数</span>
</code></pre><p>调用：</p>
<pre><code><span class="keyword">fun</span>(num) <span class="comment">// = 4</span>
</code></pre><p>传递:</p>
<pre><code><span class="keyword">Array</span>(<span class="number">3.14</span>, <span class="number">1.42</span>, <span class="number">2.0</span>).<span class="keyword">map</span>(fun) // = <span class="keyword">Array</span>(<span class="number">4.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>)
</code></pre><p>带函数参数的函数：</p>
<pre><code>def valueAtOneQuarter<span class="function"><span class="params">(f: (Double) =&gt; Double)</span> = <span class="title">f</span><span class="params">(<span class="number">0.25</span>)</span>
<span class="title">valueAtOneQuarter</span><span class="params">(ceil _ )</span>// 1.0</span>
</code></pre><p>参数推断：</p>
<pre><code>valueAtOneQuarter(<span class="number">3</span> * _)
<span class="keyword">val</span> <span class="keyword">fun</span> = <span class="number">3</span> *_ <span class="comment">// 错误：无法推断类型</span>
<span class="keyword">val</span> <span class="keyword">fun</span> = <span class="number">3</span> *(_:Double) <span class="comment">//OK</span>
<span class="keyword">val</span> <span class="keyword">fun</span>:(Double)=&gt;Double = <span class="number">3</span> * _ <span class="comment">//OK</span>
</code></pre><p>一些高价函数：</p>
<ul>
<li>map</li>
<li>filter</li>
<li>reduceLeft :   ( 1 to 9 ).reduceLeft(<em> * </em>)</li>
</ul>
<h1 id="13_集合">13 集合</h1>
<p>要点：</p>
<ul>
<li>所有集合都扩展自Iterable特质</li>
<li>三大类：序列，集和映射。</li>
<li>都提供可变和不可变版本</li>
<li>列表要么是空的，要么拥有一头一尾，尾部本身又是一个列表。</li>
<li>集是无先后次序的集合</li>
<li>用LinkedHashSet来保留插入次序，或用SortedSet来安顺序进行迭代</li>
<li><ul>
<li>将元素添加到无先后次序的集合中， +: 和 :+ 向前或向后追加序列。 ++把两集合串联在一起; - 和 — 移除元素。</li>
</ul>
</li>
<li>Iterator和Seq特质有数十个常见操作的方法。</li>
<li>映射、折叠和拉链操作是很有用的技巧。</li>
</ul>
<p>:: 操作符从头到尾创建一个新列表：</p>
<pre><code>9 <span class="comment">:: List(4, 2)</span>
9 <span class="comment">:: 4 :: 2 :: Nil</span>
</code></pre><p>可用迭代器遍历列表:</p>
<pre><code>def sum(<span class="keyword">ls</span><span class="variable">t:</span> List[Int]) = 
    <span class="keyword">if</span>(lst == Nil) <span class="number">0</span> <span class="keyword">else</span> lst.head + sum(lst.tail)
</code></pre><p>或者模式匹配：</p>
<pre><code>def sum(lst: <span class="keyword">List</span>[Int]) =  lst match {
    <span class="keyword">case</span> Nil =&gt;<span class="number">0</span> 
    <span class="keyword">case</span> h :: t =&gt; h +sum(t)
}
</code></pre><p>scala类库已经有了sum方法。</p>
<p>iterator的重要方法：</p>
<ul>
<li>head, last, headOption, lastOption</li>
<li>tail, init</li>
<li>length, isEmpty</li>
<li>map(f), foreach(f), flatMap(f), collect(f)</li>
<li>reduceLeft(op), reduceRight(op), aggregate(init)(op, combineOp)</li>
<li>reduce(op)<br>…    </li>
</ul>
<p>与java集合的互操作：</p>
<pre><code><span class="keyword">import</span> scala<span class="built_in">.</span>collection<span class="built_in">.</span>JavaConversions<span class="built_in">.</span>_ <span class="comment">// import scala.collection.JavaConversions.propertiesAsScalaMap</span>
val props: scala<span class="built_in">.</span>collection<span class="built_in">.</span>mutable<span class="built_in">.</span><span class="built_in">Map</span><span class="preprocessor">[</span><span class="built_in">String</span>,<span class="built_in">String</span><span class="preprocessor">]</span><span class="markup"> = System.getProperties()</span>
</code></pre><p>从Scala集合到java的转换：</p>
<ul>
<li>asJavaCollection</li>
<li>asJavaIterable</li>
<li>asJavaIterator</li>
<li>asJavaEnumeration</li>
<li>…</li>
</ul>
<p>从Java集合到scala的转换:</p>
<ul>
<li>collectionAsScalaIterable</li>
<li>…</li>
</ul>
<p>线程安全的集合, 可混入以下六特质：</p>
<ul>
<li>SynchronizedBuffer</li>
<li>SynchronizedMap</li>
<li>SynchronizedPriorityQueue</li>
<li>SynchronizedQueue</li>
<li>SynchronizedSet</li>
<li>SynchronizedStack</li>
</ul>
<p>并行集合:</p>
<pre><code>coll.par.sum
coll.par.count(<span class="variable">_</span> <span class="comment">% 2 == 0)</span>
<span class="function"><span class="title">for</span><span class="params">(i &lt;- (<span class="number">0</span> until <span class="number">100</span>)</span>.<span class="title">par</span>) <span class="title">print</span><span class="params">(i + <span class="string">" "</span>)</span></span>
</code></pre><h1 id="14_模式匹配和样例类">14 模式匹配和样例类</h1>
<p>要点:</p>
<ul>
<li>match表达式是一个更好的switch</li>
<li>若没有模式匹配， 会抛出MatchError. 可用case _模式来避免。</li>
<li>模式可包含一个随意定义的条件，称为守卫。</li>
<li>可对表达式类型进行匹配； 优先选用模式而不是isInstanceOf/asInstanceOf.</li>
<li>可以匹配数组，元组和样例类的么偶是，然后将匹配到的不同部分绑定到变量。</li>
<li>在for表达式中，不能匹配的情况会被安静地跳过。</li>
<li>样例类是编译器会为之自动产出模式匹配所需要的方法的类。</li>
<li>样例类继承层级中的公共超类是sealed的。</li>
<li>用Option来存放对于可能存在也可能不存在的值- 比null更安全。</li>
</ul>
<p>守卫：</p>
<pre><code>ch match {
    <span class="reserved">case</span> <span class="string">'+'</span><span class="function"> =&gt;</span> sign = <span class="number">1</span>
    <span class="reserved">case</span> <span class="string">'-'</span><span class="function"> =&gt;</span> sign = -<span class="number">1</span>
    <span class="reserved">case</span> _ <span class="keyword">if</span> Character.isDigit<span class="function"><span class="params">(ch)</span> =&gt;</span> digit = Character.digit(ch,<span class="number">10</span>)
    <span class="reserved">case</span> _<span class="function"> =&gt;</span>sign = <span class="number">0</span>
}
</code></pre><p>类型模式：</p>
<pre><code>obj match {
    <span class="keyword">case</span> x: Int =&gt; x
    <span class="keyword">case</span> s: String =&gt; Integer.parseInt(s)
    <span class="keyword">case</span> _: BigInt =&gt;Int.MaxValue
    <span class="keyword">case</span> _ =&gt;<span class="number">0</span>
}
</code></pre><p>匹配数组，列表和元组:</p>
<pre><code>arr match {
    <span class="reserved">case</span> Array<span class="function"><span class="params">(<span class="number">0</span>)</span> =&gt;</span><span class="string">"0"</span>
    <span class="reserved">case</span> Array<span class="function"><span class="params">(x,y)</span> =&gt;</span> x + <span class="string">" "</span>+ y
    <span class="reserved">case</span> Array<span class="function"><span class="params">(<span class="number">0</span>, _*)</span> =&gt;</span> <span class="string">"0 ..."</span>
    <span class="reserved">case</span> _<span class="function"> =&gt;</span> <span class="string">"something else"</span>
}

lst match {
    <span class="reserved">case</span> <span class="number">0</span> ::Nil<span class="function"> =&gt;</span><span class="string">"0"</span>
    <span class="reserved">case</span> x :: y ::Nil<span class="function"> =&gt;</span> x+ <span class="string">" "</span> + y
    <span class="reserved">case</span> _<span class="function"> =&gt;</span> <span class="string">"something else"</span>
}
</code></pre><h3 id="样例类">样例类</h3>
<pre><code><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Dollar</span><span class="params">(value: Double)</span> <span class="keyword">extends</span> <span class="title">Amount</span></span>
<span class="keyword">case</span> calss Currency(value: Doublie, unit: String) <span class="keyword">extends</span> Amount
</code></pre><p>也可以针对单例的样例对象:</p>
<pre><code><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nothing</span> <span class="keyword">extends</span> <span class="title">Amount</span></span>
</code></pre><p>使用模式匹配:</p>
<pre><code>amt match {
    <span class="reserved">case</span> Dollar<span class="function"><span class="params">(v)</span> =&gt;</span>  <span class="string">"$"</span> +v
    <span class="reserved">case</span> Currency(_, u) = &gt; <span class="string">"Oh nose, I got "</span>+ u
    <span class="reserved">case</span> Nothing<span class="function"> =&gt;</span><span class="string">""</span>
}
</code></pre><p>声明样例类，自动发送以下事情：</p>
<ul>
<li>构造器中的每个参数都成为val</li>
<li>在伴生对象中提供apply方法让你不用new关键字就构造出相应对象</li>
<li>提供unapply方法让模式匹配可以工作</li>
<li>将生成toString, equals, hashCode和copy方法— 除非显式给出这些方法的定义</li>
</ul>
<p>copy方法,创建一个域现有对象值相同的新对象。</p>
<h3 id="匹配嵌套结构">匹配嵌套结构</h3>
<h3 id="密封类">密封类</h3>
<pre><code><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>
</code></pre><p>模拟枚举：</p>
<pre><code><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Red</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Yellow</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Green</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>

color <span class="keyword">match</span> {
    <span class="keyword">case</span> Red =&gt; <span class="string">"stop"</span>
    <span class="keyword">case</span> Green =&gt; <span class="string">"go"</span>
    <span class="keyword">case</span> Yellow =&gt; <span class="string">"Hurry up"</span>
}
</code></pre><h3 id="Option_类型">Option 类型</h3>
<p>表示可能存在，也不可能存在。<br>支持泛型。</p>
<pre><code>val aliceScore = scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>)
<span class="keyword">if</span>(aliceScore.isEmpty) <span class="built_in">println</span>(<span class="string">"no score"</span>)
<span class="keyword">else</span> <span class="built_in">println</span>(aliceScore.<span class="keyword">get</span>)

<span class="built_in">println</span>(aliceScore.getOrElse(<span class="string">"no score"</span>))
<span class="built_in">println</span>(scores.getOrElse(<span class="string">"Alice"</span>, <span class="string">"no score"</span>))
</code></pre><p>若想略过None:</p>
<pre><code><span class="keyword">for</span>(score &lt;- scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>)) <span class="built_in">println</span>(score)
scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>).foreach(<span class="built_in">println</span> <span class="number">_</span>)
</code></pre><h2 id="偏函数">偏函数</h2>
<p>被包在花括号内的一组case语句是一个偏函数 —  一个并非对所有输入值都有定义的函数。</p>
<h1 id="15_注解">15 注解</h1>
<ul>
<li>可以为类， 方法，字段， 局部变量，参数，表达式，类型参数以及各种类型添加注解</li>
<li>对于表达式和类型，注解跟在被注解条目之后</li>
<li>注解的形式: @Annotation @Annotation(value) 或 @Annotation(name1=value1,…)</li>
<li>@volatile @transient @strictfp 和@native分别生成等效的java修饰符</li>
<li>@throws来生成与java兼容的throws规格说明</li>
<li>@tailrec注解让你校验某个递归函数使用了尾递归优化</li>
<li>assert函数利用了@eldable注解，你可以移除所有断言</li>
<li>@deprecated注解标记已过时的特性</li>
</ul>
<h1 id="16_XML处理">16 XML处理</h1>
<h1 id="17_类型参数">17 类型参数</h1>
<h1 id="18_高级类型">18 高级类型</h1>
<h1 id="19_解析">19 解析</h1>
<h1 id="20_Actor">20 Actor</h1>
<h1 id="21_隐式转换和隐式参数">21 隐式转换和隐式参数</h1>
<h1 id="22_定界延续">22 定界延续</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/scala快学/" data-id="vbw899bc9g9rfzk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何记笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/04/如何记笔记/" class="article-date">
  <time datetime="2015-03-04T06:30:39.000Z" itemprop="datePublished">3月 4 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/04/如何记笔记/">如何记笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="记笔记的目的">记笔记的目的</h1>
<ul>
<li>加深记忆, 稳定心绪. (看书有时候看不进去，通过记笔记，可以稳定心绪)</li>
<li>系统整理书的知识体系</li>
<li>看笔记就能想起书的内容, 可以完整反应书本内容， 可以扔掉原书</li>
</ul>
<h1 id="方法">方法</h1>
<ol>
<li><p>一本书应该被读两遍，而且只读两遍。</p>
<ul>
<li>第一步正常通读，放松欣赏</li>
<li>第二遍写下读书笔记，可以供以后重温，直接看笔记即可</li>
</ul>
</li>
<li><p>按照原书的章节给读书笔记划分章节，甚至保留各章的标题. 写下每章作者到底想说什么。<br>写出作者的逻辑脉络。</p>
</li>
<li><p>颜色和字体的变化可以起到自动突出重点和分类的作用。</p>
</li>
<li><p>要注意给将来使用搜索引擎留下线索。也就是说要把关键字，人名地名组织名等记好</p>
</li>
<li><p>主动式的阅读。在笔记中写下自己对此书的评论。统一做法是把自己的评论全部放在方括号【】中。</p>
</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li>用强力研读书: <a href="http://www.geekonomics10000.com/376" target="_blank" rel="external">http://www.geekonomics10000.com/376</a></li>
<li>三遍读书法: <a href="http://www.codeceo.com/article/how-i-read-programming-books.html" target="_blank" rel="external">http://www.codeceo.com/article/how-i-read-programming-books.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/04/如何记笔记/" data-id="h0er2ax0f7tpdgt7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/如何记笔记/">如何记笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-p专业主义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/p专业主义/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/p专业主义/">专业主义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>专业,你唯一的生存之道.</p>
<h1 id="前言_预言将自我实现">前言 预言将自我实现</h1>
<p>大前研一强调”希波克拉底誓言”对于企业职业价值的意义.<br>我们并不是因为专业技术成为专家, 而是因为”向上帝发誓, 以此为职业” - 把顾客作为出发点而成为专家.</p>
<p>专家阶层的势力迟早会增强, 并动摇日本的产业界.</p>
<p>在职业化的时代，自由竞争越来越健全，真正拥有实力的人越来越受到推崇。</p>
<p>预言: 人人都能成为专家.</p>
<p>你凭什么胜出？<br>未来能够牵动世界大势的，是个人之间的竞争。<br>能否独霸世界舞台，锻造他人无法超越的核心竞争力。<br>你唯一的依恃，就是专业。</p>
<p>你够专业吗？<br>专业不是职业，职业人士不同于专家。<br>细微的差别，却是成败的关键。</p>
<p>真正的专家具备四种能力:</p>
<ul>
<li>先见能力</li>
<li>构思能力</li>
<li>讨论的能力</li>
<li>适应矛盾的能力</li>
</ul>
<h1 id="1-_你够专业吗?">1. 你够专业吗?</h1>
<p>专家要控制自己的情感, 并靠理性而行动. 他们不仅具备较强的专业知识和技能以及较强的理念,<br>而且无一例外地以顾客为第一位,具有无穷的好奇心和永无止境的进取心,严格遵守纪律.<br>以上条件全部具备的人才, 才能成为专家.</p>
<h2 id="专家的定义">专家的定义</h2>
<p>一种健康的危机感正在蔓延, 大家感到”国家和社会已经靠不住了”, 提升自身价值的现象正在萌芽.</p>
<h2 id="被遗忘的”对顾客的誓言”">被遗忘的”对顾客的誓言”</h2>
<p>专家的词源本身”profess”, 意思是”向上帝发誓,以此为职业”</p>
<p>希波克拉底誓言:</p>
<ol>
<li>请允许我行医,我要终生奉行人道主义.</li>
<li>向恩师表达尊敬和感谢之意.</li>
<li>在行医过程中严守良心和尊严.</li>
<li>以患者的健康与生命放在第一位.</li>
<li>严格为患者保守秘密.</li>
<li>保持医学界的名誉与宝贵的传统.</li>
<li>把同事视为兄弟, 不因患者的人种,宗教国籍和社会地位的不同而区别对待.</li>
<li>从受孕之始,即把人的生命作为至高无上之物来尊重.</li>
<li>无论承受怎样的压力, 在运用自己的知识时也不会违背人道主义.</li>
</ol>
<p>企业通过商品与服务销售誓言,那是百分之百地让你满意,顾客购买的就是这种誓言.</p>
<h2 id="顾客无处不在">顾客无处不在</h2>
<p>官僚就是公仆, 所谓”官僚主义”,应该可以理解为为社会和他人献身,但现在这个词被赋予贬义,真是一种讽刺.</p>
<p>“你的工资是顾客给的”. </p>
<p>通过考虑顾客的顾客,可以把目标领域扩展到其他行业, 这就为重新审视现有的方法提供了契机,并且有可能赢得机会,<br>为直接的客户停供独特的价值.</p>
<p>那些仅仅按照公司的规定采取行动的人,不仅无法称之为专家,而且也不利于公司的发展.因此我们应该铭记,<br>从事任何工作都有首先确定自己的顾客,并发誓为顾客作出贡献.</p>
<h2 id="关于授权的误解">关于授权的误解</h2>
<p>被授予权利,行动获得自由后, 人们容易任意行事.这一现象是由于只强调授权的一面,专业主义这辆车的两个车轮未能同时运转.</p>
<p>有几个问题:</p>
<ul>
<li>权限扩大了, 你能够给顾客提供怎样的价值?</li>
<li>你自身具备使用新权力的能力和技能吗?</li>
<li>能力和技能不足, 无法熟练运用新的权力时,你该怎么办?</li>
</ul>
<p>追求权力容易, 但要保持权利则非常困难.</p>
<p>如果感到自己确实需要权力,并且能够运用手中的权力为顾客服务, 我们就应该去争取权力,而不是等待上司授予自己权力.</p>
<p>授权者应在认清下属的能力和技能并考虑此人今后发展的基础上,确定合适的权限范围;把握下属现有的能力水平与权限所要求的能力水平之间的差距,<br>做好亲自缩短这种差距的准备, 然后再把权力交给下属.当然,切记不要连累顾客.</p>
<p>所谓授权,就是对下属进行投资.</p>
<p>专家能够不断创造事业机会。</p>
<p>对顾客而言, 上司和下属的关系是无所谓的, 专家必须经常考虑顾客的利益.</p>
<h2 id="不断学习,_乐此不彼">不断学习, 乐此不彼</h2>
<p>我们需要这样的专家, 他们从基础知识开始进行系统学习, 亲身实践.对新事物反复消化并不断积累经验;<br>经过持续的训练,他们能够把之间学到的知识提供给别人.</p>
<p>绝不认为自己的本领是绝对的, 而是准备花费一生的时间去磨砺自己,并且乐此不彼.</p>
<p>要想获得成功,先要期盼成功,对自己能够获得成功充满自信.与此同时,如果在自信的背后没有好奇心作为助推器提供动力,<br>是无法达到一流境界的.这一点可以说是区分非凡与平凡的决定性因素.</p>
<h2 id="保有好奇心">保有好奇心</h2>
<p>好奇心不足的人,也就是怠慢自己智慧的人,他们几乎无一例外地属于自我防卫型,对变化采取抵制的态度.</p>
<p>不要怠慢自己的智慧.适可而止的心态不仅对本人,对周围的人也是有害的.</p>
<p>浅尝辄止地完成工作,是无法称为专家.</p>
<h2 id="纪律的力量">纪律的力量</h2>
<p>无论如何完善教育制度,如何增加报酬和改善福利, 也不会产生大批的专家.<br>只有纪律—或者称之为价值观更准确些,才能培养出专家.</p>
<p>对专家而言,是不允许妥协的.所谓”妥协”,指的是只考虑自己的情况, 而无视顾客与商业伙伴的利益,凡事过于乐观.</p>
<p>需要专家在”方向”与”程度”方面给出恰如其分的建议.</p>
<p>在21世纪的经济社会中, 我们要与”看不见的空间”作战.我们需要运作的不再是看得见的人或组织;<br>我们的工作是占领看不见的经济领域,打败其中的人或组织(有时可能是自己公司以外了的人或组织, 有时可能是<br>非特定的多数人或组织).</p>
<p>无论前提条件发生多大的变化,都能够认清深层变化的本质,比别人发挥出更大的能力,这样的人才是专家.</p>
<h1 id="2-_先见能力">2. 先见能力</h1>
<p>今后的时代所需要的先见能力, 是能够看清别人看不到的事物的能力.</p>
<h2 id="看不见的新大陆">看不见的新大陆</h2>
<p>眼睛看不见,手触不到的无形的活动将成为主流.过去辉煌的成功经验不仅不再起作用,甚至会成为发展的瓶颈.</p>
<p>工业化社会的经济是有形的,这种有形的经济虽然没有被废弃, 但已经不再是主流.</p>
<p>在”看不见的新大陆”上开展的生存竞争是毫不留情的. 既没有乞怜于人的时间,也看不到能够接受乞求的人.</p>
<h2 id="战略论的功与过">战略论的功与过</h2>
<p>如今的时代,依靠某些精英学习最新理论,制定战略并严格按照战略进行实践,这种做法已经无法推动企业的发展.</p>
<p>宝丽来失败的根本原因是什么?答案就是固守成功的模式.</p>
<p>战略: 制定规划,使自己的公司与竞争对手之间相对力量关系的变化朝着有利于自己公司高效变化的方向发展.</p>
<p>改变这种力量的三种方法:</p>
<ul>
<li>基于成功的关键因素(KFS)的战略. 可以将资源集中于KFS, 凭借自己公司的股份与收益等优势获胜.</li>
<li>基于相对优势的战略. 着眼于竞争条件的不同,以确保优势. </li>
<li>推动新规划的战略. 积极开拓竞争对手所不涉足的业务,开辟市场.</li>
</ul>
<p>战略论分为两种: </p>
<ul>
<li>定位论</li>
<li>核心竞争力理论</li>
</ul>
<p>这些理论是以稳定发展的工业化社会为背景的: 商品经济无论多么复杂,发展得多么迅速, 我们都能捕捉到商品,竞争和市场的动向,<br>在开发新产品的服务以及开拓新业务时,能够具体把握目标客户与市场.</p>
<p>但20世纪末的十几年间,作为战略论前提的顾客,市场,竞争等因素已不再具有固定的定义.</p>
<p>我们应该铭记一点: 那就是依靠固有的模式与陈旧的知识解释史无前例的现象,这种做法将会给事业的发展带来危害.</p>
<h2 id="在正确的时间做正确的事情">在正确的时间做正确的事情</h2>
<p>如今的时代,改写经济常识的并不一定是实力强大的组织,个人也完全有可能做到.</p>
<p>在新大陆中, 以往的战略论已不再适用, 但还是有不少人获得了成功,这是因为他们充分认清了新大陆的本质.<br>我们只能在新的竞争领域的彼岸遥望他们的生硬, 但沿着他们走过的道路前进则毫无意义.</p>
<p>错过了时机, 便不会成功.更何况在”看不见的新大陆”上, 经济环境的变化与20世纪相比加快了数倍,<br>谨慎被动的对企业与国家而言都将导致致命的损失.</p>
<p>推动未来世界运转的, 是个体之间的竞争, 而不再是国家之间或企业之间的竞争. 优秀的个体之间的竞争<br>转瞬之间便能改变世界.类似1990的托沃兹,具备世界一流才能的人,不知会从何处现身.</p>
<h2 id="先见能力的蜕变">先见能力的蜕变</h2>
<p>今后时代需要的先见能力,是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>纵观事业获得成功的诸多示例,给人留下的印象是这些事业都很富有先见性,并且都按照预言家的预言发展的.<br>在这些事例的背后, 我们自始至终都能看到同样的成功模式:</p>
<ol>
<li>明确定义事业领域(范围).</li>
<li>从分析现状入手预测未来的方向, 可简明扼要地阐明假想的论点, 以分析其因果关系.</li>
<li>在可能有多种选择的情况下, 只精选其中的几种.在推行所选择的方案时,采取强制的方法调配人,<br>财,物等方面资源.</li>
<li>不要迷失假说的基本方向, 不要偏离原则, 除非情况彻底发生变化.</li>
</ol>
<p>当时需要不是天才的灵感, 也不是预言家的素质,而是对一系列的逻辑过程毫不松懈地落实的执行能力:<br>定义事业领域, 从分析现状入手, 预测将来的方向.<br>但今后的时代需要的先见能力, 是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>所以不能简单依靠现有的战略论和过去的成功经验, 重要是把精力集中在不断认识前人未曾涉及的世界,<br>并磨练自觉的资质上.</p>
<h2 id="怀疑一切">怀疑一切</h2>
<p>要想学习没有常识的世界中的新常识, 即21世界的规则, 首先必须有意识地让自己习惯对命苦玉溪的一个个常识提出质疑.</p>
<p>众所周知, 人类的大脑具备这样的功能, 它会把新的信息与”过去的经验或积累的部分知识”相对照, 然后加以调整并接受.<br>如果眼前新的现实与大脑中的存储的固有信息无法协调, 便会在无意识中拒绝新的现实(当做没看见);<br>或者通过子句一知半解的知识任意推测,使自己认识到的情况偏离实际(产生错觉).<br>这是人类的一种本能, 目的在于使自己保持冷静.</p>
<p>20世纪充满常识, 而21世纪是一个无常识可言,而且会突然发生变化的时代.<br>若被旧世界的常识所束缚, 就无法在瞬间抓住并正确理解新世界中的新事实,更不可能预见到新的事业.</p>
<p>人的大脑有一种习性, 那就是”只能看到想看的东西”, 因此我们需要特别注意从成功的体验中得到的知识和理论.<br>有可能并不再适用.</p>
<p>知识来自先驱者们的研究与经验,是在反复试验, 反复失败的摸索中获得的.如果已经得到明确的知识, 则说明这块领域已被<br>无数人造访过,已毫无商机可言.<br>此后的商务专家必须比以前更加怀疑常识,并抛弃现有的知识, 也就是坚决养成”不学习”的习惯.</p>
<p>怀疑常识并不是毫无想法, 而是有意识地假设一个相反的观点, 并不断地反复验证, 把20世纪的学习变成一个破坏i类极具<br>创造性的”不学习”的过程.</p>
<p>只有对”看不见的新大陆”有所预见,才能确保自己不会丢掉工作, 获得丰厚的薪水.抛弃先例,养成怀疑常识的习惯,获得洞悉变化本质的能力—<br>即使说这一切是商务专家的生命线,也绝不过分.</p>
<h2 id="享受变化">享受变化</h2>
<p>只有具备享受变化与失败的素质,或者说是从容镇定的心情,好奇心和气魄, 才能成为”打破规则者”, 才可能带来变化.</p>
<p>在新的经济空间里, 对所从事的事业进行取舍是成败的关键. 这需要人们在自己的头脑中一边想象一边完成,<br>因为我们无法依靠别人创造的模式对事业的成败进行取舍.</p>
<p>我们只有经历无数次的失败,遍体鳞伤, 才能学会在新的竞争领域中较为实用的生存技能.</p>
<p>惧怕风险, 企图逃避风险, 这样做是为了种族延续, 是生物的本能.向未知的领域挑战是先驱者们的任务, 也是企业家的乐趣.<br>新的竞争领域就在眼前, 我毫无惧色,因为我能够经常预感到变化, 心情愉快地以失败为食粮拓展自己的世界,<br>对此我感到非常地自豪.</p>
<p>在任何地方, 被称为名人或高手的人大体上都具备: 慎重和大胆两方面的素质.</p>
<h2 id="不怕失败,执着探索">不怕失败,执着探索</h2>
<p>回避争论, 不习惯争论, 对于具备国际水准的专家而言, 是致命的弱点.</p>
<p>害怕新的竞争领域, 不敢投身其中, 是永远也无法掌握新领域的规则的, 而且也无法继续生存下去.</p>
<p>怠于思考的人是无法否定一切的. 他们惧怕失败, 因此不想承认自己是错误的.坦率地承认自己的错误, 意味着对思考永不厌倦.</p>
<p>在向新的竞争领域迈进时, 应具备以假象为支柱反复试验, 不怕失败的姿态. 换言之, 即使失败,也要勇往直前, 坚信下次一定能成功,<br>这种执着的精神是我们的附身符之一.</p>
<p>要认清变化的本质, 首先对身边的变化逐一反复地向自己提问:为什么会这样, 新在什么地方, 从中会产生什么, 其真正的价值何在.<br>然后从中确定课题, 建立假说, 搜集事实一认清这一假说,并进行分析和验证, 重新构建自己的观点.</p>
<h2 id="偏执狂的危机感">偏执狂的危机感</h2>
<p>一个高水平的偏执狂正因为具备了紧张感, 他的感受力才很强.才能通过其卓越的洞察力施展自己的行动能力.</p>
<p>比尔盖茨说过:”如果今天我的决策失误一次, 这家公司明天就会倒闭.如今我依然有这种危机感.”</p>
<p>格鲁夫:”只有偏执狂才能生存.”. 偏执狂: 对组织,对他人的思想或行动抱有怀疑态度.<br>只有那些总以为自己的经营环境危机四伏并时刻关注各种”坏消息”的企业,才有可能免于灭亡.</p>
<p>成功的背后必定潜藏着危机.</p>
<p>未曾开发的新竞争领域前途莫测. 因为不了解, 我们对任何情况都感到非常紧张,这种紧张感能够唤醒我们的知觉, 提高我们对事物的洞察力.<br>分析问题的速度与应对危机的能力.</p>
<p>如果是享受变化, 执着探索以及不效仿20世纪是在”看不见的新大陆”生存必不可少的条件,那么紧张感, 也就是积极的猜疑心理,<br>便是磨砺先见能力的”强心剂”.在”看不见的新大陆”上, 我们需要这种”强心剂”发挥作用, 否则我们便无法跟上变化的速度.</p>
<h2 id="磨练自觉能力">磨练自觉能力</h2>
<h2 id="对事业倾注全力">对事业倾注全力</h2>
<h2 id="“看不见的新大陆”为何看不见">“看不见的新大陆”为何看不见</h2>
<h1 id="3-_构思能力">3. 构思能力</h1>
<h2 id="仅有先见能力是不够的">仅有先见能力是不够的</h2>
<h2 id="成功的必要条件和充分条件">成功的必要条件和充分条件</h2>
<h2 id="把握变化的速度和规模">把握变化的速度和规模</h2>
<h2 id="电子商务的三个关键点">电子商务的三个关键点</h2>
<h2 id="设定满足8亿人市场的标准">设定满足8亿人市场的标准</h2>
<h2 id="未雨绸缪">未雨绸缪</h2>
<h2 id="“and”还是”or”">“and”还是”or”</h2>
<h2 id="勇于自我否定">勇于自我否定</h2>
<h2 id="视成功为过去时">视成功为过去时</h2>
<h2 id="追求”深度经济”">追求”深度经济”</h2>
<h1 id="4-_讨论的能力">4. 讨论的能力</h1>
<h2 id="避免对企业发展无益的讨论">避免对企业发展无益的讨论</h2>
<h2 id="符合逻辑的思考vs-符合逻辑的讨论">符合逻辑的思考vs.符合逻辑的讨论</h2>
<h2 id="讨论的能力可以后天养成">讨论的能力可以后天养成</h2>
<h2 id="逻辑是全球唯一的通用语">逻辑是全球唯一的通用语</h2>
<h2 id="确保提问符合逻辑">确保提问符合逻辑</h2>
<h2 id="倾听的能力与说服的能力">倾听的能力与说服的能力</h2>
<h2 id="不可掉入诡辩的陷阱">不可掉入诡辩的陷阱</h2>
<h2 id="尽情讨论,直到权威者发话">尽情讨论,直到权威者发话</h2>
<h2 id="符合逻辑的反驳">符合逻辑的反驳</h2>
<h2 id="亚里士多德的逻辑学">亚里士多德的逻辑学</h2>
<h2 id="成功始于坚定的信念">成功始于坚定的信念</h2>
<h1 id="5-_适应矛盾的能力">5. 适应矛盾的能力</h1>
<h2 id="企业经营没有唯一的最佳答案">企业经营没有唯一的最佳答案</h2>
<h2 id="经营中包含的矛盾">经营中包含的矛盾</h2>
<h2 id="解决问题的能力与沟通的能力">解决问题的能力与沟通的能力</h2>
<h2 id="集权与分权">集权与分权</h2>
<h2 id="全球化与本地化">全球化与本地化</h2>
<h2 id="竞争与顾客">竞争与顾客</h2>
<h2 id="自由与统帅">自由与统帅</h2>
<h2 id="左脑与右脑">左脑与右脑</h2>
<h1 id="结语">结语</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/p专业主义/" data-id="zwjtonorw13p8bap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/管理/">管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java核心技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/java核心技术/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/java核心技术/">java核心技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_流与文件">1. 流与文件</h1>
<h2 id="流">流</h2>
<p>输入流</p>
<p>输出流</p>
<p>抽象类：InputStream和OutputStream</p>
<h1 id="2-_XML">2. XML</h1>
<h1 id="3-_网络">3. 网络</h1>
<h1 id="4-_数据库编程">4. 数据库编程</h1>
<h1 id="5-_国际化">5. 国际化</h1>
<h1 id="6-_高级swing">6. 高级swing</h1>
<h1 id="7-_高级AWT">7. 高级AWT</h1>
<h1 id="8-_JavaBean构件">8. JavaBean构件</h1>
<h1 id="9-_安全">9. 安全</h1>
<h1 id="10-_脚本，编译与注解处理">10. 脚本，编译与注解处理</h1>
<h1 id="11-_分布式对象">11. 分布式对象</h1>
<h1 id="12-_本地方法">12. 本地方法</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/java核心技术/" data-id="g4fg92x6t3nqeuwt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript权威指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/18/javascript权威指南/" class="article-date">
  <time datetime="2015-02-17T23:57:09.000Z" itemprop="datePublished">2月 18 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/18/javascript权威指南/">javascript权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Javascript概述">1. Javascript概述</h1>
<p>Javascript是面向Web的编程语言。</p>
<p>前端工程师必须掌握的三大技能: </p>
<ul>
<li>描述网页内容的HTML </li>
<li>描述网页样式的css </li>
<li>描述网页行为的Javascript</li>
</ul>
<p>Firefox的插件Firebug: <a href="http://getfirebug.com/" target="_blank" rel="external">http://getfirebug.com/</a></p>
<p>F12唤醒Firefox操作面板 Ctrl+Shift+J唤醒错误控制台(Error Console).</p>
<h2 id="Javascript语言核心">Javascript语言核心</h2>
<p>变量和赋值：</p>
<pre><code><span class="title">var</span> x;
<span class="title">x</span> = <span class="number">0</span>;

<span class="title">x</span>
x = <span class="number">1</span>;
<span class="title">x</span> = <span class="number">0</span>.<span class="number">01</span>;
<span class="title">x</span> = <span class="string">"hello world"</span>;
<span class="title">x</span> = <span class="string">'hello world'</span>;
<span class="title">x</span> = <span class="built_in">true</span>;
<span class="title">x</span> = null;
<span class="title">x</span> = undefined;
</code></pre><p>复杂类型:</p>
<pre><code><span class="keyword">var</span> book = {
    topic: <span class="string">"Javascript"</span>,
    fat: <span class="keyword">true</span>
};

book.topic
book[<span class="string">'fat'</span>]
book.author = <span class="string">'Flanagan'</span>;
book.content = {};

<span class="keyword">var</span> primes = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];
primes[<span class="number">0</span>]
primes.length
primes[primes.length -<span class="number">1</span> ]
primes[<span class="number">4</span>] = <span class="number">9</span>;  <span class="comment">// 通过赋值添加新元素</span>
primes[<span class="number">4</span>] = <span class="number">11</span>;
<span class="keyword">var</span> <span class="keyword">empty</span> = []
<span class="keyword">empty</span>.length

<span class="keyword">var</span> points = [
    {x:<span class="number">0</span>, y:<span class="number">0</span>},
    {x:<span class="number">1</span>, y:<span class="number">1</span>}
];

<span class="keyword">var</span> data = {
    trial1: [ [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],
    trial2: [ [<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]
}
</code></pre><p>表达式：</p>
<pre><code><span class="number">3</span> + <span class="number">2</span>
<span class="number">3</span> - <span class="number">2</span>
<span class="number">3</span> * <span class="number">2</span>
<span class="number">3</span> / <span class="number">2</span>                           <span class="comment">// =&gt; 1.5</span>
points[<span class="number">1</span>].x - points[<span class="number">0</span>].x  
<span class="string">"3"</span> + <span class="string">"2"</span>                       <span class="comment">// =&gt; "32" </span>

<span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span>;
<span class="built_in">count</span> ++;
<span class="built_in">count</span> --;
<span class="built_in">count</span> += <span class="number">2</span>;
<span class="built_in">count</span> *= <span class="number">3</span>;
<span class="built_in">count</span>

<span class="keyword">var</span> x=<span class="number">2</span>, y=<span class="number">3</span>;
x == y
x != y
x &lt; y
<span class="string">"two"</span> &gt; <span class="string">"three"</span>

(x == <span class="number">2</span>) &amp;&amp; (y==<span class="number">3</span>)
</code></pre><p>函数:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">plus1</span><span class="params">(x)</span></span>{
    reutrn x +<span class="number">1</span>;
}
plus1(y)

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{
    <span class="keyword">return</span> x * x;
};

square(plus1(y))
</code></pre><p>将函数和对象合写在一起， 方法：</p>
<pre><code><span class="keyword">var</span> a = [];
a.push(<span class="number">1</span>, <span class="number">2</span> <span class="number">3</span>);
a.reverse();

<span class="comment">// "this"关键字是对定义方法对象的引用</span>
points.dist = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> p1 = <span class="keyword">this</span>[<span class="number">0</span>];
    <span class="keyword">var</span> p2 = <span class="keyword">this</span>[<span class="number">1</span>];
    <span class="keyword">var</span> a = p2.x - p1.x
    <span class="keyword">var</span> b = p2.y - p2.y;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(a*<span class="number">2</span> + b*b ）
points.dist()
</code></pre><p>控制语句：</p>
<pre><code><span class="keyword">function</span> abs(x) {
    <span class="keyword">if</span>(x &gt;=<span class="number">0</span>){
        <span class="keyword">return</span> x;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> -x;
    }
}

//<span class="keyword">...</span>    
    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i+){
        //<span class="keyword">...</span>
    }
    <span class="keyword">while</span>(true){
        //<span class="keyword">...</span>
    }
</code></pre><p>对象：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
}
<span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);

Point.prototype.r = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(
        <span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y);
    };
p.r();
</code></pre><h1 id="2-_词法结构">2. 词法结构</h1>
<h1 id="3-_类型，值和变量">3. 类型，值和变量</h1>
<h1 id="4-_表达式和运算符">4. 表达式和运算符</h1>
<h1 id="5-_语句">5. 语句</h1>
<h1 id="6-_对象">6. 对象</h1>
<p>对象是一种复合值: 将很多值聚合在一起， 可通过名字访问这些值。</p>
<p>对象可以看做属性的无序集合，每个属性都是一个名/值对。</p>
<p>属性名是字符串，因此我们可以吧对象看成从字符串到值的映射。</p>
<p>对象不仅仅是字符串到值的映射，除了可以保持自有的属性，对象还可以从一个称为原型的对象继承属性。<br>对象的方法通常是继承的属性。</p>
<p>“原型式继承”是Javascript的核心特征。</p>
<h2 id="创建对象">创建对象</h2>
<p>三种方式.</p>
<h3 id="对象直接量">对象直接量</h3>
<pre><code><span class="keyword">var</span> <span class="keyword">empty</span> = {}
<span class="keyword">var</span> point = {x:<span class="number">0</span>, y:<span class="number">0</span>}
<span class="keyword">var</span> book = {
    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,
    <span class="string">"sub-title"</span>:<span class="string">"The Definitive Guide"</span>
}
</code></pre><h3 id="new创建对象">new创建对象</h3>
<pre><code><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个空对象， 和{}一样</span>
<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个空数组, 和[]一样</span>
<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); 
<span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>);
</code></pre><p>除了这些内置构造函数， 也可以自定义构造函数来初始化新对象。</p>
<h3 id="原型">原型</h3>
<pre><code><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create({x:<span class="number">1</span>, y:<span class="number">2</span>}) <span class="comment">// o1 继承了属性x和y</span>
<span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype) <span class="comment">// o3 和 {} 一样</span>
</code></pre><p>可以通过任何原型创建对象:</p>
<p>function inherit(p){<br>    if(p==null) throw TypeError();<br>    if(Object.create) return Object.create(p);<br>    var t= typeof p;<br>    if(t!== “object”&amp;&amp; t!== “function”) throw TypeError();<br>    fucntion f() {} // 定义一个空构造函数<br>    f.prototype = p;<br>    return new f();<br>}</p>
<h2 id="属性的查询和设置">属性的查询和设置</h2>
<p>通过.和[]来获取属性的值。</p>
<p>Javascript对象都是关联数组。</p>
<p>属性访问错误，会抛出一个类型错误异常。</p>
<p>避免错误的方法:</p>
<pre><code><span class="keyword">var</span> <span class="built_in">len</span> = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;
</code></pre><h2 id="删除属性">删除属性</h2>
<p>delete book.author<br>delete book[“main title”]</p>
<h2 id="检测属性">检测属性</h2>
<h2 id="枚举属性">枚举属性</h2>
<p>for/in循环可以在循环体中遍历对象中所有可枚举的属性。<br>对象继承的内置方法是不可枚举的。<br>d但在代码中给对象添加的属性是可枚举的。</p>
<h2 id="属性getter和setter">属性getter和setter</h2>
<h2 id="属性的特征">属性的特征</h2>
<p>除了包含名字和值之外，属性还包含一些标识他们可写，可枚举和可配置的特性。</p>
<h2 id="对象的三个属性">对象的三个属性</h2>
<p>每个对象都有与之相关的原型(prototype), 类(class)和可扩展性().</p>
<h2 id="序列化对象">序列化对象</h2>
<h2 id="对象方法">对象方法</h2>
<h1 id="7-_数组">7. 数组</h1>
<h1 id="8-_函数">8. 函数</h1>
<p>函数即对象。</p>
<h2 id="函数定义">函数定义</h2>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">distance</span><span class="params">(x1, y1, x2, y2)</span></span>{
    <span class="keyword">var</span> dx = x2 - x1;
    <span class="keyword">var</span> dy = y2 - y1;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);
}

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{<span class="keyword">return</span> x*x;}

<span class="comment">// 函数表达式可以包含名称</span>
<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(x)</span> </span>{ <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x * faxt(x-<span class="number">1</span>);};

data.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>{<span class="keyword">return</span> a-b;});
</code></pre><p>嵌套函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span><span class="params">(a,b)</span></span>{
    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(x)</span></span>{<span class="keyword">return</span> x*x;}
    reurn <span class="built_in">Math</span>.sqrt(square(a) +square(b));
}
</code></pre><h2 id="函数调用">函数调用</h2>
<p>有四种方式.</p>
<h3 id="函数调用-1">函数调用</h3>
<h3 id="方法调用">方法调用</h3>
<h1 id="9-_类和模块">9. 类和模块</h1>
<h1 id="10-_正则表达式的模式匹配">10. 正则表达式的模式匹配</h1>
<h1 id="11-_Javascript的子集和扩展">11. Javascript的子集和扩展</h1>
<h1 id="12-_服务端Javascript">12. 服务端Javascript</h1>
<h1 id="13-_Web浏览器中的Javascript">13. Web浏览器中的Javascript</h1>
<h1 id="14-_windows对象">14. windows对象</h1>
<h1 id="15-_脚本化文档">15. 脚本化文档</h1>
<h1 id="16-_脚本化css">16. 脚本化css</h1>
<h1 id="17-_事件处理">17. 事件处理</h1>
<h1 id="18-_脚本化http">18. 脚本化http</h1>
<h1 id="19-_JQuery类库">19. JQuery类库</h1>
<h1 id="20-_客户端存储">20. 客户端存储</h1>
<h1 id="21-_多媒体和图形编程">21. 多媒体和图形编程</h1>
<h1 id="22-_HTML5_API">22. HTML5 API</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/18/javascript权威指南/" data-id="r2tcz3rjcn12u8oj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node即学即用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/17/node即学即用/" class="article-date">
  <time datetime="2015-02-17T14:06:27.000Z" itemprop="datePublished">2月 17 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/17/node即学即用/">node即学即用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言">前言</h1>
<p>本书目标：了解Node平台本身，还能掌握Node为快速高效地构建高扩展性网站和服务提供多个重要模块。</p>
<h1 id="1-_Node-js简介">1. Node.js简介</h1>
<p>Node的特性： </p>
<ul>
<li>对高性能的追求</li>
<li>利用了Javascript的事件驱动(Event-driven)特性。 采用了事件驱动(event loop)架构，让开发高效的服务端程序变得简单和安全。</li>
<li>提供了一系列“非阻塞”函数库来支持事件循环特性：把文件系统和数据库操作封装成事件驱动形式的函数接口</li>
<li>能在服务端运行Javascript.</li>
<li>开发者很容易为其扩展新的库。</li>
</ul>
<h2 id="写代码">写代码</h2>
<h3 id="Node_REPL">Node REPL</h3>
<h3 id="编写首个服务器程序">编写首个服务器程序</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">http</span> = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">http</span>.createServer(<span class="function"><span class="keyword">function</span> (<span class="title">req</span>, <span class="title">res</span>){</span></div><div class="line">    res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>})</div><div class="line">    res.<span class="keyword">end</span>(<span class="string">'Hello, node\n'</span>)</div><div class="line">}).listen(<span class="number">8124</span>, <span class="string">'127.0.0.1'</span>)</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'Server running at http://127.0.0.1:8124'</span>)</div></pre></td></tr></table></figure>

<h2 id="为何选用Node">为何选用Node</h2>
<h3 id="高性能Web服务器">高性能Web服务器</h3>
<h1 id="2-_编写有趣的应用">2. 编写有趣的应用</h1>
<h2 id="创建一个聊天服务器">创建一个聊天服务器</h2>
<p>需要在Node中包含TCP模块，创建一个新的TCP服务器:</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer()

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.write(<span class="string">'Hi!\n'</span>)
    client.write(<span class="string">'Bye!\n'</span>)
    client.end()
})

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>使用telnet连接服务器测试： telnet 127.0.0.1 9000</p>
<p>首先需要手动客户端发送的消息：</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer()

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.write(<span class="string">'Hi!\n'</span>)
    client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        <span class="built_in">console</span>.log(data)
    })
})

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>这里添加了另外一个事件监听器，调用的是client.on().</p>
<p>Javascript无法很好处理二进制数据,所以Node特地增加了一个Buffer库来帮助服务器。</p>
<p>目前他只能和一个客户端通信，我们需要照顾到所有客户端。为此创建一个列表:</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer(),
    clientList = []

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.name = client.remoteAddress + <span class="string">':'</span> + client.remotePort
    client.write(<span class="string">'Hi '</span> + client.name + <span class="string">'!\n'</span>);
    clientList.push(client)
    client.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        broadcast(data, client)
    })
})

<span class="function"><span class="keyword">function</span> <span class="title">broadcast</span><span class="params">(message, client)</span></span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i+=<span class="number">1</span>){
        <span class="keyword">if</span>(client != clientList[i]){
            clientList[i].write(client.name + <span class="string">" says "</span> + message)
        }
    }
}

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>在connection事件监听器上为每个client对象增加name属性。</p>
<p>但这个服务器有个致命缺陷：若一个客户端断开了，服务器会出大问题。<br>对已经关闭的socket进行write操作时，Node程序会抛出异常。</p>
<p>把聊天服务器改造得更加健壮:</p>
<pre><code>chatServer.on(<span class="string">'connection'</span>, function(<span class="keyword">client</span>){
    <span class="keyword">client</span>.name = <span class="keyword">client</span>.remoteAddress + <span class="string">':'</span> + <span class="keyword">client</span>.remotePort
    <span class="keyword">client</span>.write(<span class="string">'Hi '</span> + <span class="keyword">client</span>.name + <span class="string">'!\n'</span>);
    clientList.push(<span class="keyword">client</span>)
    <span class="keyword">client</span>.on(<span class="string">'data'</span>,function(data){
        broadcast(data, <span class="keyword">client</span>)
    })
    <span class="keyword">client</span>.on(<span class="string">'end'</span>,function(){
        clientList.splice(clientList.indexOf(<span class="keyword">client</span>),<span class="number">1</span>)
    })
})
</code></pre><p>一个socket锻炼连接时会触发end事件，表示它要关闭。</p>
<p>可以做得更加保险：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span><span class="params">(message, client)</span></span>{
    <span class="keyword">var</span> cleanup = []
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i+=<span class="number">1</span>){
        <span class="keyword">if</span>(client != clientList[i]){
            <span class="keyword">if</span>(clientList[i].writable){
                clientList[i].write(client.name + <span class="string">" says "</span> + message)
            }<span class="keyword">else</span>{
                cleanup.push(clientList[i])
                clientList[i].destroy()
            }
        }
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;cleanup.length;i+=<span class="number">1</span>){
        clientList.splice(clientList.indexOf(cleanup[i]),<span class="number">1</span>)
    }
}
</code></pre><h2 id="也编写个twitter">也编写个twitter</h2>
<ol>
<li>需要安装express模块，为现有的http服务器添加了更多的扩展，使开发Web应用更加简单： npm install express</li>
</ol>
<p>基本web服务器：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express.createServer()
app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(<span class="string">'Welcome to Node Twitter'</span>)
})

app.listen(<span class="number">8000</span>)
</code></pre><p>添加基础API:</p>
<pre><code><span class="keyword">var</span> express = require(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express.createServer()
app.listen(<span class="number">8000</span>)

<span class="keyword">var</span> tweets = []
app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(<span class="string">'Welcome to Node Twitter'</span>)
})

app.post(<span class="string">'/send'</span>, express.bodyParser(), <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    <span class="keyword">if</span>(req.body &amp;&amp; req.body.tweet){
        tweets.push(req.body.tweet)
        res.send({status:<span class="string">"ok"</span>, message:<span class="string">"Tweet received"</span>})
    }<span class="keyword">else</span>{
        res.send({status:<span class="string">"nok"</span>, message:<span class="string">"no tweet recevied"</span>})
    }
})

app.<span class="keyword">get</span>(<span class="string">'/tweets'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(tweets)
})
</code></pre><h1 id="3-_编写健壮的Node程序">3. 编写健壮的Node程序</h1>
<h1 id="4-_核心API">4. 核心API</h1>
<h1 id="5-_工具类API">5. 工具类API</h1>
<h1 id="6-_数据访问">6. 数据访问</h1>
<h1 id="7-_重要的外部模块">7. 重要的外部模块</h1>
<h1 id="8-_扩展Node">8. 扩展Node</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/17/node即学即用/" data-id="xudy9fv1k37sr358" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hbase实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/08/hbase实战/" class="article-date">
  <time datetime="2015-02-08T12:59:57.000Z" itemprop="datePublished">2月 8 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/08/hbase实战/">hbase实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>源码: <a href="https://github.com/HBaseinaction" target="_blank" rel="external">https://github.com/HBaseinaction</a></p>
<h1 id="1-_HBase介绍">1. HBase介绍</h1>
<p>HBase是一种数据库。一种稀疏的，分布式的，持久化的，多维有序映射，基于行键(rowkey), 列键(column key)和时间戳(timestamp)建立索引。</p>
<p>HBase邮件列表：<a href="http://HBase.apache.org/mail-lists.html" target="_blank" rel="external">http://HBase.apache.org/mail-lists.html</a><br>JIRA网站： <a href="http://issues.apache.org/jira/browse/HBASE" target="_blank" rel="external">http://issues.apache.org/jira/browse/HBASE</a></p>
<h2 id="Hbase使用场景和成功案例">Hbase使用场景和成功案例</h2>
<h3 id="典型的互联网搜索问题">典型的互联网搜索问题</h3>
<h3 id="抓取增量数据">抓取增量数据</h3>
<ul>
<li>抓取监控指标：OpenTSDB</li>
<li>抓取用户交互数据: Facebook和StumbleUpon</li>
<li>遥测技术: Mozilla和Trend Micro</li>
<li>广告效果和点击流</li>
</ul>
<h3 id="内容服务">内容服务</h3>
<p>Twitter帖子, Facebook帖子，Instagram帖子和微博。</p>
<ul>
<li>Url短链接: StumbleUpon</li>
<li>用户模型服务: Runa用户模型服务</li>
</ul>
<h3 id="信息交换">信息交换</h3>
<p>Facebook的短信系统。 用户读写的所有短信都存在HBase列。 </p>
<p>Facebook短信系统要求: 高的写吞吐量，计数器吞吐量，自动分库</p>
<p>参考： </p>
<ul>
<li><a href="https://www.facebook.com/note.php?note_id=454991608919" target="_blank" rel="external">https://www.facebook.com/note.php?note_id=454991608919</a></li>
<li>“Hadoop goes realtime at Facebook” <a href="http://borthakur.com/ftp/RealtimeHadoopSigmod2011.pdf" target="_blank" rel="external">http://borthakur.com/ftp/RealtimeHadoopSigmod2011.pdf</a></li>
</ul>
<h2 id="你好HBase">你好HBase</h2>
<p>Hbase搭建在Apache Hadoop和Apache ZooKeeper上面，用java编写的。 可运行在3种模式：单机， 伪分布式和全分布式。</p>
<h3 id="快速安装">快速安装</h3>
<ol>
<li>下载。 <a href="http://hbase.apache.org/" target="_blank" rel="external">http://hbase.apache.org/</a></li>
<li>export HBASE_HOME=</li>
<li>$HBASE_HOME/bin/start-hbase.sh </li>
<li>默认写数据在/tmp下. 可写配置/etc/hbase/conf/hbase-site.xml</li>
<li>后台简易页面。  <a href="http://localhost:60010" target="_blank" rel="external">http://localhost:60010</a></li>
</ol>
<h3 id="命令行交互">命令行交互</h3>
<pre><code><span class="variable">$ </span>hbase shell                                                                                                                             <span class="number">13</span><span class="symbol">:</span><span class="number">24</span><span class="symbol">:</span><span class="number">45</span>
<span class="constant">HBase</span> <span class="constant">Shell</span>; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.
<span class="constant">Type</span> <span class="string">"exit&lt;RETURN&gt;"</span> to leave the <span class="constant">HBase</span> <span class="constant">Shell</span>
<span class="input"><span class="prompt">Version 0.98.10-hadoop2, rb18bc4b06f3eb90f592c906e78fb6461548ae627, Sun Feb  1 05:48:33 UTC 2015

hbase(main):001:0&gt;</span> list</span>
<span class="constant">TABLE</span>
<span class="number">2015</span>-<span class="number">02</span>-09 <span class="number">13</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">04</span>,<span class="number">209</span> <span class="constant">WARN</span>  [main] util.<span class="constant">NativeCodeLoader</span><span class="symbol">:</span> <span class="constant">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">5500</span> seconds
<span class="output"><span class="status">
=&gt;</span> []</span>
<span class="input"><span class="prompt">hbase(main):002:0&gt;</span> create <span class="string">'mytable'</span>, <span class="string">'cf'</span></span>
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">2180</span> seconds
<span class="output"><span class="status">
=&gt;</span> <span class="constant">Hbase::Table</span> - mytable</span>
<span class="input"><span class="prompt">hbase(main):003:0&gt;</span> list</span>
<span class="constant">TABLE</span>
mytable
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">00</span>8<span class="number">0</span> seconds
<span class="output"><span class="status">
=&gt;</span> [<span class="string">"mytable"</span>]</span>
<span class="input"><span class="prompt">hbase(main):004:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'first'</span>, <span class="string">'cf:message'</span>, <span class="string">'hello HBase'</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0770 seconds

hbase(main):005:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'second'</span>, <span class="string">'cf:foo'</span>, <span class="number">0x0</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0120 seconds

hbase(main):006:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'third'</span>, <span class="string">'cf:bar'</span>, <span class="number">3.14159</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0090 seconds

hbase(main):007:0&gt;</span> get <span class="string">'mytable'</span>, <span class="string">'first'</span></span>
<span class="constant">COLUMN</span>                                        <span class="constant">CELL</span>
<span class="symbol">cf:</span>message                                   timestamp=<span class="number">1423459575172</span>, value=hello <span class="constant">HBase</span>
<span class="input"><span class="prompt">1 row(s) in 0.0180 seconds

hbase(main):008:0&gt;</span> scan <span class="string">'mytable'</span></span>
<span class="constant">ROW</span>                                           <span class="constant">COLUMN</span>+<span class="constant">CELL</span>
first                                        column=<span class="symbol">cf:</span>message, timestamp=<span class="number">1423459575172</span>, value=hello <span class="constant">HBase</span>
second                                       column=<span class="symbol">cf:</span>foo, timestamp=<span class="number">1423459599179</span>, value=<span class="number">0</span>
third                                        column=<span class="symbol">cf:</span>bar, timestamp=<span class="number">1423459615603</span>, value=<span class="number">3.14159</span>
<span class="input"><span class="prompt">3 row(s) in 0.0160 seconds

hbase(main):009:0&gt;</span> quit    </span>
</code></pre><h1 id="2-_入门">2. 入门</h1>
<p>本章目标:</p>
<ul>
<li>学习HBase的逻辑数据模型(logical data model)</li>
<li>如何进行HBase模式(Schema)设计</li>
</ul>
<p>代码参考:  <a href="https://github.com/hbaseinaction/twitbase" target="_blank" rel="external">https://github.com/hbaseinaction/twitbase</a></p>
<h2 id="从头开始">从头开始</h2>
<p>TwitBase存储3种简单的核心数据元素: 用户(user), 推贴(twit)和关系(relationship).</p>
<h3 id="创建表">创建表</h3>
<pre><code><span class="input"><span class="prompt">hbase(main):002:0&gt;</span> create <span class="string">'users'</span>, <span class="string">'info'</span></span>
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">10.2700</span> seconds
<span class="output"><span class="status">
=&gt;</span> <span class="constant">Hbase::Table</span> - users</span>
<span class="input"><span class="prompt">hbase(main):003:0&gt;</span> list</span>
<span class="constant">TABLE</span>
mytable
users
<span class="number">2</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">0040</span> seconds
<span class="output"><span class="status">
=&gt;</span> [<span class="string">"mytable"</span>, <span class="string">"users"</span>]</span>
<span class="input"><span class="prompt">hbase(main):004:0&gt;</span> describe <span class="string">'users'</span></span>
<span class="constant">Table</span> users is <span class="constant">ENABLED</span>
users
<span class="constant">COLUMN</span> <span class="constant">FAMILIES</span> <span class="constant">DESCRIPTION</span>
{<span class="constant">NAME</span> =&gt; <span class="string">'info'</span>, <span class="constant">BLOOMFILTER</span> =&gt; <span class="string">'ROW'</span>, <span class="constant">VERSIONS</span> =&gt; <span class="string">'1'</span>, <span class="constant">IN_MEMORY</span> =&gt; <span class="string">'false'</span>, <span class="constant">KEEP_DELETED_CELLS</span> =&gt; <span class="string">'FALSE'</span>, <span class="constant">DATA_BLOCK_ENCODING</span> =&gt; <span class="string">'NONE'</span>, <span class="constant">TTL</span> =&gt; <span class="string">'FOREVER'</span>, <span class="constant">COMPRESSION</span> =&gt; <span class="string">'NONE
'</span>, <span class="constant">MIN_VERSIONS</span> =&gt; <span class="string">'0'</span>, <span class="constant">BLOCKCACHE</span> =&gt; <span class="string">'true'</span>, <span class="constant">BLOCKSIZE</span> =&gt; <span class="string">'65536'</span>, <span class="constant">REPLICATION_SCOPE</span> =&gt; <span class="string">'0'</span>}
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">0350</span> seconds
</code></pre><h3 id="建立连接">建立连接</h3>
<pre><code>Configuration myConf = HBaseConfiguration.create();
myConf.<span class="keyword">set</span>(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"serverip"</span>);
HTableInterface usersTable = <span class="keyword">new</span> HTable(myConf, <span class="string">"users"</span>);
</code></pre><h3 id="连接管理">连接管理</h3>
<p>创建一个表实例是个开销很大的操作， 需要占用一些网络资源。使用连接池更好一些，使用HTablePool比直接使用HTable更常见：</p>
<pre><code>HTablePool pool = new HTablePool();
HTableInterface usersTabel = pool.getTable(<span class="string">"users"</span>);
<span class="keyword">...</span> //work withe the table
usersTable.close();
</code></pre><p>当你完成工作表时，连接资源会返回到连接池里。</p>
<h2 id="数据操作">数据操作</h2>
<p>行键(rowkey): Hbase的行唯一标识符。<br>HBase Api有5个基本命令: Get, Put, Delete, Scan和Increment.</p>
<h3 id="Hbase写路径">Hbase写路径</h3>
<p>在Hbase中，无论是增加新行还是修改已有行，内部流程都是相同的。 Hbase接到命令后存入变化信息，或者写入失败抛出异常。</p>
<p>默认，执行写入时写到两个地方: 预写式日志（write-ahead log, WAL) 和MemStore. 以保证数据持久化。两个地方信息都写入并确认后，才认为写动作完成。</p>
<p>MemStore是内存里的写入缓冲区，HBase中数据在永久写入之前都在这里累积。当MemStore填满后，其中的数据会刷写到硬盘，生成一个HFile.</p>
<p>HFile是Hbase使用的底层存储格式。Hfile对应列族，一个列族可以有多个HFile，但一个HFile不能存多个列族的数据。<br>在集群的每个节点上， 每个列族有一个MemStore.</p>
<p>大型分布式系统中硬件故障很常见，HBase也不例外。若MemStore还没有刷写，服务器就崩溃了， 内存没有写入硬盘的数据就会丢失。<br>使用WAL恢复。</p>
<p>// 待补</p>
<h3 id="Hbase读路径">Hbase读路径</h3>
<p>想快速访问数据，通用的原则是数据保持有序并尽可能保存在内存里。</p>
<p>Hbase实现了这两个目标， 大多情况下读操作可以做到毫秒级。</p>
<p>BlockCache是优化HBase性能的一个重要部分。</p>
<p>首先检查MemStore, 然后检查BlockCache, 最后访问硬盘上的HFile.</p>
<h3 id="合并:_HBase的后台工作">合并: HBase的后台工作</h3>
<p>Delete命令并不立即删除内容，只是打上删除的标记。因为HFile是不能改变的，直到执行一次大合并(major compaction), 这时被删除记录占用的空间才会释放。</p>
<p>合并分为两种：大合并()和小合并().</p>
<p>小合并把多个小HFile合并生成一个大HFile. 因为读出一个完整的行可能引用很多文件，限制HFile的数量对于读性能很重要。</p>
<p>大合并将处理给定region的一个列族的所有HFile.</p>
<p>参考: “Visualizing HBase Flushes and Compactions” Bruno Dumon.</p>
<h3 id="有时间版本的数据">有时间版本的数据</h3>
<p>HBase默认只存储3个版本，可以基于列族设置。</p>
<h3 id="数据模型概括">数据模型概括</h3>
<p>逻辑实体如下：</p>
<ul>
<li>表</li>
<li>行</li>
<li>列族</li>
<li>列限定符</li>
<li>单元</li>
<li>时间版本</li>
</ul>
<h2 id="数据坐标">数据坐标</h2>
<p>HBase使用的坐标依次是: 行键，列族，列限定符，时间版本。 4个坐标</p>
<h2 id="数据模型">数据模型</h2>
<p>半结构化数据。</p>
<p>HBase的半结构化逻辑模型里数据构成是松耦合的，这一点有利于物理分散存储。<br>当然也导致HBase不能实施关系约束(constraint)并不支持多行事务(multirow transaction).</p>
<h1 id="3-_分布式的HBase,HDFS和MapReduce">3. 分布式的HBase,HDFS和MapReduce</h1>
<p>HBase在两方面依赖Hadoop.</p>
<ol>
<li>Hadoop MapReduce提供了分布式计算框架，支持高吞吐量数据访问。</li>
<li>HDFS作为HBase的存储层，支持可用性(availability)和可靠性(reliability).</li>
</ol>
<h2 id="一个MapReduce的例子">一个MapReduce的例子</h2>
<h2 id="MapReduce概览">MapReduce概览</h2>
<ul>
<li>拆解。 hadoop只能以行为单位拆解</li>
<li>map阶段处理</li>
<li>洗牌阶段(shuffle step)</li>
<li>排序阶段(sort step)</li>
<li>聚合工作·</li>
</ul>
<h3 id="MapReduce内部处理">MapReduce内部处理</h3>
<ul>
<li>JobTracker进程扮演着应用监管的角色，负责管理集群上运行的MapReduce应用。作业提交给JobTracker来执行，管理分配工作负载。</li>
<li>Map阶段和Reduce阶段定义的工作由另一个TaskTracker的进程来执行</li>
</ul>
<h2 id="分布式模式的HBase">分布式模式的HBase</h2>
<p>Hbse中的表由行和列组成的。</p>
<p>表会切分小一点儿的数据单位(Region), 然后分配到多台服务器上。</p>
<p>托管region的服务器叫做RegionServer.</p>
<p>RegionServer和HDFS DataNode典型情况下并列配置在同一物理硬件上。<br>RegionServer本质上是HDFS客户端，在上面存储和访问数据。 主(master)进程分配region给RegionServer.<br>每个RegionServer一般托管多个region.</p>
<h3 id="如何找到Region">如何找到Region</h3>
<p>HBase有两个特殊的表：-Root-和.META.</p>
<p>当客户端要访问某行时，先找到-ROOT-表，查找上面地方可以找到负责某行的region. </p>
<h2 id="HBase和MapReduce">HBase和MapReduce</h2>
<h2 id="信息汇总">信息汇总</h2>
<h2 id="大规模条件下的可用性和可靠性">大规模条件下的可用性和可靠性</h2>
<h1 id="4-_HBase表设计">4. HBase表设计</h1>
<h2 id="如何开始模式(schema)设计">如何开始模式(schema)设计</h2>
<p>考虑以下问题:</p>
<ul>
<li>表应该有多少个列族</li>
<li>列族使用什么数据</li>
<li>每个列族应该有多少列</li>
<li>列名是什么？</li>
<li>单元存放什么数据</li>
<li>每个单元存储多少个时间版本</li>
<li>行键的结构是什么？应该包含什么信息</li>
</ul>
<h3 id="问题建模">问题建模</h3>
<p>一个列族的所有列在硬盘上存放在一起，使用这种特性把不同访问模式的列放在不同列族中，以便隔离他们。</p>
<p>提前多做准备工作总是有好处的</p>
<h1 id="5-_使用协处理器扩展HBase">5. 使用协处理器扩展HBase</h1>
<h1 id="6-_其他HBase客户端选择">6. 其他HBase客户端选择</h1>
<h1 id="7-_通过实例学习HBase:_OpenTSDB">7. 通过实例学习HBase: OpenTSDB</h1>
<h1 id="8-_在HBase上查询地理信息系统">8. 在HBase上查询地理信息系统</h1>
<h1 id="9-_部署HBase">9. 部署HBase</h1>
<h1 id="10-_运维">10. 运维</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/08/hbase实战/" data-id="6x2xv8qg5o07bomx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hbase/">hbase</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hadoop权威指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/07/hadoop权威指南/" class="article-date">
  <time datetime="2015-02-07T12:20:54.000Z" itemprop="datePublished">2月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/07/hadoop权威指南/">hadoop权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_初始Hadoop">1. 初始Hadoop</h1>
<p>已经有了大量的数据， 问题是如何存储和分析这些数据。</p>
<h2 id="数据存储和分析">数据存储和分析</h2>
<p>容量快速增长的同时，磁盘的访问速度却未能与时俱进。</p>
<p>多个磁盘数据的并行读写， 需要解决以下问题：</p>
<ul>
<li>硬盘故障。 使用备份（例如RAID冗余磁盘阵列），另外Hadoop文件系统（HDFS).</li>
<li>大多数分析任务需要以某种方式结合大部分数据共同完成分析任务。 MapReduce提出了一个编程模型。</li>
</ul>
<p>Hadoop提供了一个可靠的共享存储和分析系统。</p>
<h2 id="与其它系统的比较">与其它系统的比较</h2>
<h3 id="关系数据库">关系数据库</h3>
<p>为何不使用数据库对大量磁盘上的大规模数据进行批量计算呢？为何需要MapReduce?</p>
<p>答案来自于磁盘的另一个趋势: 寻址时间的提高远远慢于传输速率的提高。</p>
<ul>
<li>如果数据的访问模式包含大量的磁盘寻址，那么读取大量数据集所花的时间势必会更长。（与流式读取比较， 流式读取主要取决于传输速率）</li>
<li>若数据库只更新一小部分记录（B树), 效率比MapReduce效率低得多，因为需要使用”排序/合并”来重建数据库。</li>
</ul>
<p>MapReduce比较适合以批处理的方式处理需要分析整个数据集的问题。而RDBMS适用于“点查询”和更新，数据集被索引后，数据库系统能够提供较低延迟的数据检索和快速的少量数据库更新。<br>另一个区别：它们操作的数据集的结构化程度。</p>
<h3 id="网格计算">网格计算</h3>
<h2 id="Hadoop发展简史">Hadoop发展简史</h2>
<p>Hadoop是Apache Lucence创始人Doug Cutting创建的， Lucence是一个广泛使用的文本搜索系统库。<br>Hadoop起源于Apache Nutch, 一个开源的网络搜索引擎，本身也是Lucence项目的一部分。</p>
<ul>
<li>Nutch始于2002年, 一个可以运行的网页爬取工具和搜索引擎很快“浮出水面”, 但这一架构可扩展度不够， 不能解决数十亿网页的搜索问题. </li>
<li>2003年发表的一篇论文提供了帮助， 文中描述了谷歌产品架构（谷歌分布式文件系统, GFS), 可以解决他们在网页爬取和索引过程中产生的超大文件的存储需求。<br>特别关键的是, GFS能够节省系统管理（如管理存储节点）所花的大量时间。</li>
<li>2004年，他们开始着手实现Nutch的分布式文件系统（NDFS).</li>
<li>2004年，谷歌发布论文介绍MapReduce系统</li>
<li>2005年初， Nutch开发人员在Nutch上实现了一个MapReduce系统</li>
<li>2006年2月，Nutch开发人员将NDFS和MapReduce从Nutch移出形成Lucence的一个子项目，称为Hadoop. 大约同时Doug Cutting加入雅虎。</li>
<li>2008年2月，Yahoo!宣布其搜索引擎使用的索引在一个拥有1万个内核的Hadoop集群上构建的。</li>
<li>2008年4月，Hadoop打破世界纪录，</li>
</ul>
<h2 id="Apache_Hadoop和Hadoop生态圈">Apache Hadoop和Hadoop生态圈</h2>
<p>Hadoop项目：</p>
<ul>
<li>Common: 一组分布式文件系统和通用I/O的组件和接口（序列化，Java RPC和持久化数据结构）</li>
<li>Avro: 一种支持高效，跨语言的RPC以及永久存储数据结构的序列化系统。</li>
<li>MapReduce: 分布式数据模型和执行环境，运行于大型商用机集群。</li>
<li>HDFS: 分布式文件系统</li>
<li>Pig: 一种数据流语言和运行环境，用于检索非常大的数据集，Pig运行在MapReduce和HDFS的集群上</li>
<li>Hive: 一种分布式，按列存储的数据仓库。 Hive管理HDFS中存储的数据，并提供基于SQL的查询语言用以查询数据。</li>
<li>HBase: 一种分布式，按列存储的数据库。使用HDFS作为底层存储，同事支持MapReduce的批量式计算和点查询。</li>
<li>Zookeeper: 一个分布式，高可用的协调服务。</li>
<li>Sqoop: 在数据库和HDFS之间高效传输数据的工具.</li>
</ul>
<h1 id="2-_关于MapReduce">2. 关于MapReduce</h1>
<p>MapReduce是一个可用于数据处理的编程模型。</p>
<h2 id="一个气象数据集">一个气象数据集</h2>
<h2 id="使用Unix工具进行数据分析">使用Unix工具进行数据分析</h2>
<h2 id="使用Hadoop分析数据">使用Hadoop分析数据</h2>
<h3 id="map阶段和reduce阶段">map阶段和reduce阶段</h3>
<h3 id="Java_MapReduce">Java MapReduce</h3>
<p>需要三样东西:</p>
<ul>
<li>map函数</li>
<li>reduce函数</li>
<li>用了运行作业的代码</li>
</ul>
<p>Mapper:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTemperatureMapper</span> <span class="keyword">extends</span> <span class="title">MapReduceBase</span> 
    <span class="keyword">implements</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> inst MISSING = <span class="number">9999</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output,
        Reporter reporter) <span class="keyword">throws</span> IOException {

        String line = value.toString();
        String year = line.substring(<span class="number">15</span>,<span class="number">19</span>);
        <span class="keyword">int</span> airTemperature;

        <span class="keyword">if</span>(line.charAt(<span class="number">87</span>) == <span class="string">'+'</span>){
            airTemperature = Integer.parseInt(line.substring(<span class="number">88</span>,<span class="number">92</span>);
        }<span class="keyword">else</span>{
            airTemperature = Integer.parseInt(line.substring(<span class="number">87</span>,<span class="number">92</span>);
        }
        String quality = liine.substring(<span class="number">92</span>,<span class="number">93</span>);
        <span class="keyword">if</span>(airTemperature != MISSING &amp;&amp; quality.matches(<span class="string">"[01459]"</span>)){
            output.collect(<span class="keyword">new</span> Text(year), <span class="keyword">new</span> IntWritable(airTemperature));
        }
    }
}
</code></pre><p>Reducer:</p>
<p>public class MaxTemperatureReducer extends MapReduceBase<br>    implements Reducer<text, intwritable=""> output, Reporter reporter)</text,></p>
<h2 id="横向扩展">横向扩展</h2>
<h2 id="Hadoop的Steaming">Hadoop的Steaming</h2>
<h2 id="Hadoop的Pipes">Hadoop的Pipes</h2>
<h1 id="3-_Hadoop分布式文件系统">3. Hadoop分布式文件系统</h1>
<h1 id="4-_Hadoop_I/O">4. Hadoop I/O</h1>
<h1 id="5-_MapReduce应用开发">5. MapReduce应用开发</h1>
<h1 id="6-_MapReduce的工作机制">6. MapReduce的工作机制</h1>
<h1 id="7-_MapReduce的类型与格式">7. MapReduce的类型与格式</h1>
<h1 id="8-_MapReduce的特性">8. MapReduce的特性</h1>
<h1 id="9-_构建Hadoop集群">9. 构建Hadoop集群</h1>
<h1 id="10-_管理Hadoop">10. 管理Hadoop</h1>
<h1 id="11-_Pig简介">11. Pig简介</h1>
<h1 id="12-_Hive简介">12. Hive简介</h1>
<h1 id="13-_HBase">13. HBase</h1>
<h1 id="14-_Zookeeper">14. Zookeeper</h1>
<h1 id="15-_开源Sqoop">15. 开源Sqoop</h1>
<h1 id="16-_实例分析">16. 实例分析</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/07/hadoop权威指南/" data-id="1b7yam8klxq1x4yi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ice协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/19/Ice协议/" class="article-date">
  <time datetime="2015-01-19T00:32:01.000Z" itemprop="datePublished">1月 19 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/Ice协议/">Ice协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据编码（Data_Encoding)">数据编码（Data Encoding)</h1>
<h1 id="协议消息（Protocol_Messages)">协议消息（Protocol Messages)</h1>
<h1 id="协议压缩（Protocol_Compressing)">协议压缩（Protocol Compressing)</h1>
<h1 id="协议和编码版本">协议和编码版本</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/01/19/Ice协议/" data-id="yawn65lgew7cjccf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ice/">Ice</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring3-0就这么简单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/02/Spring3-0就这么简单/" class="article-date">
  <time datetime="2014-12-02T03:08:56.000Z" itemprop="datePublished">12月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/02/Spring3-0就这么简单/">Spring3.0就这么简单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_快速入门">1. 快速入门</h1>
<p>spring是分层的Java SE/EE应用一站式的轻量级开源框架，以<strong> 反转控制(IOC) </strong>和 <strong> 面向切片(AOP) </strong> 为内核,<br>提供了展现层Spring MVC, 持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</p>
<p>好的设计优于具体实现，代码应易于测试。</p>
<p>Spring好处：</p>
<ul>
<li>方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀的框架</li>
<li>降低Java EE API的使用难度。</li>
<li>java源码是经典的学习范例。</li>
</ul>
<h3 id="Spring体系结构">Spring体系结构</h3>
<p>5个主要模块:</p>
<ol>
<li>IOC</li>
<li>AOP</li>
<li>数据访问和集成</li>
<li>web及远程操作</li>
<li>web及远程访问(Spring MVC)</li>
</ol>
<h1 id="2-_Spring_IoC容器">2. Spring IoC容器</h1>
<p>Ioc: 通过容器来控制业务对象之间的依赖关系，而非传统实现中， 由代码直接操控。</p>
<p>控制反转：控制权由应用代码中转到了外部容器。</p>
<p>优点：降低了业务对象之间的依赖程度。</p>
<p>BeanFactory是Spring框架最核心的接口，提供了高级Ioc的配置机制。<br>ApplicationContext建立在BeanFactory基础之上， 提供了更多面向应用的功能。(应用上下文）</p>
<h3 id="BeanFactory">BeanFactory</h3>
<p>spring 配置文件:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"UTF-8"</span> ?&gt;</div><div class="line">&lt;beans <span class="variable">xmlns=</span><span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    xmlns:<span class="variable">xsi=</span><span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    xmlns:<span class="variable">p=</span><span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    xsi:<span class="variable">schemaLocation=</span><span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"car"</span> <span class="variable">class=</span><span class="string">"com.smart.Car"</span></div><div class="line">         p:<span class="variable">brand=</span><span class="string">"红旗CA72"</span></div><div class="line">         p:<span class="variable">maxSpeed=</span><span class="string">"200"</span>/&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"myBeanPostProcessor"</span> <span class="variable">class=</span><span class="string">"com.smart.context.MyBeanPostProcessor"</span>/&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"myBeanFactoryPostProcessor"</span> <span class="variable">class=</span><span class="string">"com.smart.context.MyBeanFactoryPostProcessor"</span>/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>

<p>使用BeanFactory:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> BeanFactoryTest {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) throws Throwable{</div><div class="line">       ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">       Resource res = resolver.getResource(<span class="string">"classpath:com/smart/beanfactory/beans.xml"</span>);</div><div class="line">       System.<span class="keyword">out</span>.println(res.getURL());</div><div class="line">       BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(res);</div><div class="line">       System.<span class="keyword">out</span>.println(<span class="string">"init BeanFactory."</span>);</div><div class="line"></div><div class="line">       Car car = bf.getBean(<span class="string">"car"</span>,Car.class);</div><div class="line">       System.<span class="keyword">out</span>.println(<span class="string">"car bean is ready for use!"</span>);</div><div class="line">       car.introduce();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="ApplicationContext">ApplicationContext</h3>
<p>相对BeanFactory, ApplicationContext初始化比较简单:</p>
<pre><code>ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/context/beans.xml"</span>);
</code></pre><p>还可以指定一组配置文件:</p>
<pre><code>ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"conf/beans1.xml"</span>,<span class="string">"conf/beans2.xml"</span>});
</code></pre><p>BeanFactory在初始化容器时，并未初始化Bean, 直到第一次访问某个Bean才实例化Bean.<br>而ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean.</p>
<h3 id="WebApplicationContext">WebApplicationContext</h3>
<p>WebApplicationContext是专门为Web应用准备的，允许从Web根目录的路径中装载配置文件，完成初始化工作。</p>
<p>它需要ServletContext实例。 在web.xml中配置自启动的Servlet或Web容器监听器(ServletContextListener), 借助它们任何一个<br>完成Spring WEb应用上下文的工作。</p>
<p>配置监听器引导：</p>
<pre><code><span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:spring-config.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>
        org.springframework.web.context.ContextLoaderListener
    <span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
</code></pre><p>配置自启动的Servlet引导：</p>
<h3 id="集合类型属性">集合类型属性</h3>
<pre><code><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"boss1"</span> <span class="attribute">class</span>=<span class="value">"com.smart.attr.Boss"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"car"</span> <span class="attribute">ref</span>=<span class="value">"car"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"favorites"</span>&gt;</span>
        <span class="comment">&lt;!-- list&gt;
            &lt;value&gt;看报&lt;/value&gt;
            &lt;value&gt;赛车&lt;/value&gt;
            &lt;value&gt;高尔夫&lt;/value&gt;
            &lt;/list --&gt;</span>
        <span class="tag">&lt;<span class="title">set</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobs"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">map</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span> &gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>AM<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>会见客户<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span>&gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>PM<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>公司内部会议<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">map</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mails"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">props</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"jobMail"</span>&gt;</span>john-office@baobaotao.com<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"lifeMail"</span>&gt;</span>john-life@baobaotao.com<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobTime"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">map</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span>&gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>会见客户<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>124<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">map</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</code></pre><p>对应Boss类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Boss {
    <span class="keyword">private</span> String name ;
    <span class="keyword">private</span> <span class="keyword">int</span> age;
    <span class="keyword">private</span> Car car = <span class="keyword">new</span> Car();
    <span class="keyword">private</span> Map jobs = <span class="keyword">new</span> HashMap();
    <span class="keyword">private</span> Properties mails = <span class="keyword">new</span> Properties();
    <span class="keyword">private</span> Map&lt;String,Integer&gt; jobTime = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>() {
        <span class="keyword">return</span> age;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
    }
    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getJobTime</span>() {
        <span class="keyword">return</span> jobTime;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobTime</span>(Map&lt;String, Integer&gt; jobTime) {
        <span class="keyword">this</span>.jobTime = jobTime;
    }
    <span class="keyword">public</span> Properties <span class="title">getMails</span>() {
        <span class="keyword">return</span> mails;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMails</span>(Properties mails) {
        <span class="keyword">this</span>.mails = mails;
    }
    <span class="keyword">public</span> Map <span class="title">getJobs</span>() {
        <span class="keyword">return</span> jobs;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobs</span>(Map jobs) {
        <span class="keyword">this</span>.jobs = jobs;
    }
<span class="comment">//  private List favorites = new ArrayList();</span>
<span class="comment">//</span>
<span class="comment">//  public List getFavorites() {</span>
<span class="comment">//      return favorites;</span>
<span class="comment">//  }</span>
<span class="comment">//  public void setFavorites(List favorites) {</span>
<span class="comment">//      this.favorites = favorites;</span>
<span class="comment">//  }</span>
    <span class="keyword">private</span> Set favorites = <span class="keyword">new</span> HashSet();
    <span class="keyword">public</span> Car <span class="title">getCar</span>() {
        <span class="keyword">return</span> car;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span>(Car car) {
        <span class="keyword">this</span>.car = car;
    }
    <span class="keyword">public</span> String <span class="title">toString</span>(){
        String temp =<span class="string">"car:"</span>+car+<span class="string">"\n"</span>;
        temp += <span class="string">"favorites.size:"</span>+favorites.size()+<span class="string">"\n"</span>;
        temp += <span class="string">"jobs.size:"</span>+jobs.size();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">public</span> Set <span class="title">getFavorites</span>() {
        <span class="keyword">return</span> favorites;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFavorites</span>(Set favorites) {
        <span class="keyword">this</span>.favorites = favorites;
    }
}
</code></pre><h3 id="配置集合类型的Bean">配置集合类型的Bean</h3>
<pre><code><span class="tag">&lt;<span class="title">util:list</span> <span class="attribute">id</span>=<span class="value">"favoriteList1"</span> <span class="attribute">list-class</span>=<span class="value">"java.util.LinkedList"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">util:list</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:set</span> <span class="attribute">id</span>=<span class="value">"favoriteSet1"</span>  &gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">util:set</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:map</span> <span class="attribute">id</span>=<span class="value">"emails1"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"AM"</span> <span class="attribute">value</span>=<span class="value">"会见客户"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"PM"</span> <span class="attribute">value</span>=<span class="value">"公司内部会议"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">util:map</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:properties</span> <span class="attribute">id</span>=<span class="value">"emailProps1"</span>
<span class="attribute">location</span>=<span class="value">"classpath:com/smart/fb/mails.properties"</span> /&gt;</span>
</code></pre><h3 id="自动装配">自动装配</h3>
<p><bean>元素提供自动装配的属性：autowire=”&lt;自动装配类型&gt;”</bean></p>
<p>4种自动装配类型：</p>
<ul>
<li>byName</li>
<li>byType</li>
<li>constructor</li>
<li>autodetect</li>
</ul>
<p><beans>元素标签中的default-autowire属性可以配置全局自动装配。</beans></p>
<h3 id="Bean作用域">Bean作用域</h3>
<ol>
<li>singleton</li>
<li>prototype</li>
<li>request</li>
<li>session</li>
<li>globalSession</li>
</ol>
<h3 id="基于注解的配置">基于注解的配置</h3>
<ul>
<li>@Component</li>
<li>@Repository: 用于对DAO实现类进行标注</li>
<li>@Service: 用于对Service实现类进行标注</li>
<li>@Controller: 用于对Controller实现类进行标注</li>
</ul>
<p>使用注解配置信息启动Spring容器：</p>
<pre><code>&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.yuqiao.hellomvc.dao"</span>/&gt;
&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.yuqiao.hellomvc.dao"</span> resorce-pattern=<span class="string">"anno/*.class"</span>/&gt;
</code></pre><p>默认情况下, resorce-pattern=”<em>*/</em>.class”</p>
<p>Spring通过@Autowired注解实现Bean的依赖注入。<br>若容器没有一个和标注变量类型匹配的Bean， Spring容器启动时讲抛出NoSuchBeanDefinitionException异常，<br>若希望不抛出该异常，那么就可以使用@Autowired(require=false)进行标注。</p>
<p>使用@Qualifier指定注入Bean名称。</p>
<h1 id="3-_Spring_AOP">3. Spring AOP</h1>
<h2 id="aop_概述">aop 概述</h2>
<p>aop应用场景受限, 一般只适用于那些具有横切逻辑的应用场景：性能监测，访问控制， 事务管理及日志记录。</p>
<h3 id="aop术语">aop术语</h3>
<ul>
<li>连接点(JoinPoint)</li>
<li>切点(PointCut)</li>
<li>增强(Advice)</li>
<li>目标对象(Target)</li>
<li>引介(introduce)</li>
<li>织入(Weaving)</li>
<li>代理(Proxy)</li>
<li>切面(Aspect) </li>
</ul>
<h2 id="创建增强类">创建增强类</h2>
<p>Spring支持5种类型的增强:</p>
<ul>
<li>前置增强(org.springframework.aop.BeforeAdvice)</li>
<li>后置增强(org.springframework.aop.AfterReturningAdvice)</li>
<li>环绕增强(org.springframework.intercept.MethodInterceptor)</li>
<li>异常抛出增强(org.springframework.aop.ThrowsAdvice)</li>
<li>引介增强(org.springframework.aop.INtroductionInterceptor)</li>
</ul>
<h2 id="创建切面">创建切面</h2>
<p>支持两种方法配置器:</p>
<ul>
<li>静态方法配置器</li>
<li>动态方法配置器</li>
</ul>
<h3 id="切点类型">切点类型</h3>
<ul>
<li>静态方法切点</li>
<li>动态方法切点</li>
<li>注解切点</li>
<li>表达式切点</li>
<li>流程切点</li>
<li>复合切点</li>
</ul>
<h3 id="切面类型">切面类型</h3>
<ul>
<li>Advisor(一般切面)</li>
<li>PointcutAdvisor(切点切面)</li>
<li>IntroductionAdvisor(引介切面)</li>
</ul>
<h3 id="静态普通方法名匹配切面">静态普通方法名匹配切面</h3>
<p>在Waiter#greetTo()织入增强，切面类实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Method method, Class&lt;?&gt; targetClass) {</div><div class="line">        <span class="keyword">return</span> <span class="string">"greetTo"</span>.equals(method.getName());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFilter() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Class&lt;?&gt; clazz) {</div><div class="line">                <span class="keyword">return</span> Waiter.class.isAssignableFrom(clazz);</div><div class="line">            }</div><div class="line">        };</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>配置切面:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"greetingAdvisor"</span> class=<span class="string">"com.yuqiao.advice.GreetingAdvisor"</span></div><div class="line">        p:advice-<span class="keyword">ref</span>=<span class="string">"greetingBeforeAdvice"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"parent"</span> abstract=<span class="string">"true"</span></div><div class="line">        class=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span></div><div class="line">        p:interceptorNames=<span class="string">"greetingAdvisor"</span></div><div class="line">        p:proxyTargetClass=<span class="string">"true"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"waiter2"</span> parent=<span class="string">"parent"</span> p:target-<span class="keyword">ref</span>=<span class="string">"nativeWaiter"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"seller1"</span> parent=<span class="string">"parent"</span> p:target-<span class="keyword">ref</span>=<span class="string">"seller"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="静态正则表达式方法匹配切面">静态正则表达式方法匹配切面</h3>
<p>为seller定义切面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"regexAdvisor"</span> class=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span></div><div class="line">        p:advice-<span class="keyword">ref</span>=<span class="string">"greetingBeforeAdvice"</span>&gt;</div><div class="line">    &lt;property name=<span class="string">"patterns"</span>&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;value&gt;.*greet.*&lt;/value&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=<span class="string">"seller2"</span> class=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span></div><div class="line">        p:interceptorNames=<span class="string">"regexAdvisor"</span></div><div class="line">        p:target-<span class="keyword">ref</span>=<span class="string">"seller"</span></div><div class="line">        p:proxyTargetClass=<span class="string">"true"</span>/&gt;&lt;ap</div></pre></td></tr></table></figure>

<h2 id="自动创建代理">自动创建代理</h2>
<p>前面都是使用ProxyFactoryBean创建织入切面的代理， 每个bean都需要该配置， 比较麻烦。</p>
<p>spring提供了自动代理机制。 使用BeanPostProcessor， 根据一定规则自动在容器实例化Bean时为匹配的Bean生成代理实例. 分类：</p>
<ul>
<li>基于Bean配置名规则的自动代理创建器。实现类为BeanNameAutoProxyCreator.</li>
<li>基于Advisor陪陪机制。DefaultAdvisorAutoProxyCreator.</li>
<li>基于Bean中AspectJ注解标签的自动代理创建器。</li>
</ul>
<h3 id="BeanNameAutoProxyCreator">BeanNameAutoProxyCreator</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="variable">class=</span><span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span></div><div class="line">        p:<span class="variable">beanNames=</span><span class="string">"*er"</span></div><div class="line">        p:<span class="variable">interceptorNames=</span><span class="string">"greetingBeforeAdvice"</span></div><div class="line">        p:<span class="variable">optimize=</span><span class="string">"true"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="DefaultAdvisorAutoProxyCreator">DefaultAdvisorAutoProxyCreator</h3>
<pre><code>&lt;bean <span class="keyword">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>/&gt;
</code></pre><h2 id="基于@AspectJ配置切面">基于@AspectJ配置切面</h2>
<h3 id="@AspectJ语法基础">@AspectJ语法基础</h3>
<p>Spring支持9个@AspectJ切点表达函数</p>
<ul>
<li>execution()</li>
<li>@annotation()</li>
<li>args()</li>
<li>@args()</li>
<li>within()</li>
<li>target()</li>
<li>@within()</li>
</ul>
<h1 id="4-_使用Spring_JDBC访问数据库">4. 使用Spring JDBC访问数据库</h1>
<p>由于JDBC api过于底层，开发者不但要编写数据操作代码，还需要编写JDBC连接，处理异常，释放资源等的代码。</p>
<p>Spring JDBC通过模板和回调机制大大降低了JDBC的复杂度。</p>
<p>创建一张表:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DriverManagerDataSource <span class="keyword">ds</span> = <span class="keyword">new</span> DriverManagerDataSource();</div><div class="line"><span class="keyword">ds</span>.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line"><span class="keyword">ds</span>.setUrl(<span class="string">"jdbc:mysql://localhost:3306/sampledb"</span>);</div><div class="line"><span class="keyword">ds</span>.setUsername(<span class="string">"root"</span>);</div><div class="line"></div><div class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</div><div class="line">jdbcTemplate.setDataSource(<span class="keyword">ds</span>);</div><div class="line"></div><div class="line">String sql = <span class="string">"create table t_user(user_id int primary key, user_name varchar(60))"</span>;</div><div class="line">jdbcTemplate.<span class="keyword">execute</span>(sql);</div></pre></td></tr></table></figure>

<p>一般情况下，在DAO类中使用JdbcTemplate, 在XML配置文件中配置好JdbcTemplate,然后直接在DAO中注入即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.yuqiao.hellomvc.dao;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="annotation">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginLogDao</span> </span>{</div><div class="line">    <span class="annotation">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertLoginLog</span>(LoginLog loginLog) {</div><div class="line">        String sqlStr = <span class="string">"INSERT INTO t_login_log(user_id,ip,login_datetime) "</span></div><div class="line">                + <span class="string">"VALUES(?,?,?)"</span>;</div><div class="line">        Object[] args = {loginLog.getUserId(), loginLog.getIp(),</div><div class="line">                loginLog.getLoginDate()};</div><div class="line">        jdbcTemplate.update(sqlStr, args);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Spring配置文件定义jdbcTemplate:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></div><div class="line">      destroy-<span class="keyword">method</span>=<span class="string">"close"</span></div><div class="line">      p:driverClassName=<span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">      p:url=<span class="string">"jdbc:mysql://localhost:3306/sampledb31"</span></div><div class="line">      p:username=<span class="string">"root"</span></div><div class="line">      p:password=<span class="string">""</span>/&gt;</div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"jdbcTemplate"</span> class=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span></div><div class="line">      p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div></pre></td></tr></table></figure>

<p>配置一般分为4个步骤:</p>
<ol>
<li><p>定义DataSource.</p>
</li>
<li><p>定义JdbcTemplate. 可以控制JDBC api的属性.</p>
<ul>
<li>queryTimeout. 查询数据的最大超时时间。</li>
<li>fetchSize. ResultSet每次返回的行数.</li>
<li>maxRows:</li>
<li>ignoreWarnings:</li>
</ul>
</li>
<li><p>声明一个抽象的<bean>，以便所有DAO复用配置。</bean></p>
</li>
<li><p>配置具体的DAO.</p>
</li>
</ol>
<h2 id="基本的数据操作">基本的数据操作</h2>
<h3 id="返回数据库的表自增主键值">返回数据库的表自增主键值</h3>
<p>KeyHolder是一个回调接口，Spring用他保存新增记录对应的主键。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpace</span>(<span class="keyword">final</span> ViewSpace viewSpace){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"INSERT INTO t_view_space (space_name, description, address, user_id) VALUES(?,?,?,?)"</span>;</div><div class="line">    KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</div><div class="line">    jdbcTemplate.update(<span class="keyword">new</span> PreparedStatementCreator() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span>(Connection connection) <span class="keyword">throws</span> SQLException {</div><div class="line">            PreparedStatement ps = connection.prepareStatement(sql);</div><div class="line">            ps.setString(<span class="number">1</span>, viewSpace.getSpaceName());</div><div class="line">            ps.setString(<span class="number">2</span>, viewSpace.getDescription());</div><div class="line">            ps.setString(<span class="number">3</span>, viewSpace.getAddress());</div><div class="line">            ps.setInt(<span class="number">4</span>, viewSpace.getUser());</div><div class="line">            <span class="keyword">return</span> ps;</div><div class="line">        }</div><div class="line">    },keyHolder);</div><div class="line">    viewSpace.setSpaceId(keyHolder.getKey().intValue());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在jdbc3.0之前， PreparedStatement不能绑定主键。用户必须在插入数据库后马上执行另一条获取新增主键的查询语句。<br>mysql: SELECT LAST_INSERT_ID();</p>
<h3 id="批量更改数据">批量更改数据</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpaces</span>(<span class="keyword">final</span> List&lt;ViewSpace&gt; viewSpaceList){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"INSERT INTO t_view_space (space_name, description, address, user_id) VALUES(?,?,?,?)"</span>;</div><div class="line">    jdbcTemplate.batchUpdate(sql, <span class="keyword">new</span> BatchPreparedStatementSetter() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span>(PreparedStatement ps, <span class="keyword">int</span> i) <span class="keyword">throws</span> SQLException {</div><div class="line">            ViewSpace viewSpace = viewSpaceList.get(i);</div><div class="line">            ps.setString(<span class="number">1</span>, viewSpace.getSpaceName());</div><div class="line">            ps.setString(<span class="number">2</span>, viewSpace.getDescription());</div><div class="line">            ps.setString(<span class="number">3</span>, viewSpace.getAddress());</div><div class="line">            ps.setInt(<span class="number">4</span>, viewSpace.getUser());</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span>() {</div><div class="line">            <span class="keyword">return</span> viewSpaceList.size();</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="查询数据">查询数据</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ViewSpace <span class="title">getViewSpace</span>(<span class="keyword">final</span> <span class="keyword">int</span> id){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"SELECT space_name, description, address, user_id from t_view_space where space_id=?"</span>;</div><div class="line">    <span class="keyword">final</span> ViewSpace vs = <span class="keyword">new</span> ViewSpace();</div><div class="line">    jdbcTemplate.query(sql, <span class="keyword">new</span> Object[]{id}, <span class="keyword">new</span> RowCallbackHandler() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span>(ResultSet resultSet) <span class="keyword">throws</span> SQLException {</div><div class="line">            vs.setSpaceId(id);</div><div class="line">            vs.setSpaceName(resultSet.getString(<span class="string">"space_name"</span>));</div><div class="line">            vs.setDescription(resultSet.getString(<span class="string">"description"</span>));</div><div class="line">            vs.setAddress(resultSet.getString(<span class="string">"address"</span>));</div><div class="line">            vs.setUser(resultSet.getInt(<span class="string">"user_id"</span>));</div><div class="line">        }</div><div class="line">    });</div><div class="line">    <span class="keyword">return</span> vs;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>RowCallbackHandler 和RowMapper<t>比较。</t></p>
<p>单值查询接口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewSpaceNum</span>(){</div><div class="line">    String sql = <span class="string">"select COUNT(*) FROM  t_view_space"</span>;</div><div class="line">    <span class="keyword">return</span> jdbcTemplate.queryForInt(sql);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编写sql语句时，用大写方式编写SQL的关键字和函数， 用小写的形式编写表名，字段名等非语义的元素。</p>
<p>调用存储过程： execute</p>
<h2 id="BLOB/CLOB类型数据的操作">BLOB/CLOB类型数据的操作</h2>
<h1 id="5-_集成Hibernate">5. 集成Hibernate</h1>
<h1 id="6-_Spring的事务管理">6. Spring的事务管理</h1>
<h2 id="数据库事务基础知识">数据库事务基础知识</h2>
<p>一荣俱荣，一损俱损。体现事务的思想，很多复杂的事务要分步进行，但他们组成一个整体，要么整体生效，要么整体失效。</p>
<p>数据库事务需要满足4个特性（ACID):原子性(Atomic), 一致性(Consistency), 隔离性(Isolation)和持久性(Durability).</p>
<p>一致性是目标，其它都是达到这个目标的措施或者手段。</p>
<p>数据库系统一般采用重执行日志保证原子性，一致性和持久性。重执行日志记录了数据库变化的每一个动作，数据库在一个事务中执行一部分操作后发生错误退出，数据库即可根据重执行日志车险已经执行的操作。<br>数据库管理系统采用数据库锁机制保证事务的隔离性。</p>
<p>Connection#getMetaData()获取DatbaMataData对象，该对象的supportsTransactions(), supportsTransactionIsolationLevel(int level)查看底层数据库的事务支持情况。</p>
<h3 id="Jdbc对事务的处理">Jdbc对事务的处理</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="type">Connection</span> conn;</div><div class="line"><span class="keyword">try</span>{</div><div class="line">    conn = <span class="type">DriverManager</span>.getConnection();</div><div class="line">    conn.setAutoCommit(<span class="literal">false</span>);</div><div class="line">    conn.setTransactionIsolation(<span class="type">Connection</span>.<span class="type">TRANSACTION_SERIALIZABLE</span>);</div><div class="line">    <span class="type">Statement</span> <span class="type">stmt</span> = conn.createStatement();</div><div class="line">    <span class="type">int</span> rows = <span class="type">stmt</span>.executeUpdate(<span class="string">"INSERT INTO t_viewspace VALUES(1,'XXXX')"</span>);</div><div class="line">    rows = <span class="type">stmt</span>.executeUpdate(<span class="string">"UPDATE t_viewpoint set ticket = ticket +10"</span>);</div><div class="line">    conn.commit();</div><div class="line">}catch (<span class="type">Exception</span> e){</div><div class="line">    conn.rollback();</div><div class="line">}<span class="keyword">finally</span> {</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Spring对事务管理的处理">Spring对事务管理的处理</h2>
<p>Spring为事务管理提供了一致的编程模板, 在高层次建立了同意的事务抽象。提供了TransactionTemplate。</p>
<p>Spring事务管理的亮点在于声明式事务管理。</p>
<h3 id="事务管理关键抽象">事务管理关键抽象</h3>
<p>Spring事务管理SPI(Service Provider Interface)的抽象层主要包括三个接口：</p>
<ul>
<li><p>PlatformTransactionManager: 根据TransactionDefinition提供的事务属性配置信息，创建事务，并用TransationStatus描述这个激活事务的状态。定义了3方法:</p>
<ul>
<li>getTransaction(definition)</li>
<li>commit(stutus)</li>
<li>rollback(status)</li>
</ul>
</li>
<li><p>TransactionDefinition: 描述事务的隔离级别，超时时间，是否为只读事务和事务传播规则等控制事务具体行为的事务属性。</p>
</li>
<li>TransactionStatus: 代表一个事务的具体运行状态。</li>
</ul>
<h3 id="事务管理实现类">事务管理实现类</h3>
<p>Spring将事务管理委托给底层具体的持久化实现框架完成。</p>
<p>Spring JDBC和iBatis都是基于数据源的Connection访问数据库，所以可以使用DataSourceTransactionManager.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"dataSource"</span></div><div class="line">        class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></div><div class="line">        destroy-<span class="keyword">method</span>=<span class="string">"close"</span></div><div class="line">        p:driverClassName=<span class="string">"${jdbc.driverClassName}"</span></div><div class="line">        p:url=<span class="string">"${jdbc.url}"</span></div><div class="line">        p:username=<span class="string">"${jdbc.username}"</span></div><div class="line">        p:password=<span class="string">"${jdbc.password}"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"txManager"</span></div><div class="line">        class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></div><div class="line">        p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="事务同步管理器">事务同步管理器</h3>
<p>Spring将JDBC的Connection,Hibernate的Session等访问数据库的连接或会话对象统称为资源。资源在同一时刻是不能多线程共享的。<br>为了让Dao,Service类可能做到singleton，Spring的事务同步管理类TransactionSynchronizationManager使用ThreadLocal管理为不同事务线程提供了<br>独立的资源副本。</p>
<p>Spring框架为不同的持久化技术提供了一套从TransactionSynchronizationManager中获取对应线程绑定资源的工具类。<br>DataSourceUtils.getConnection可以从指定的数据源中获取和当前线程绑定的Connection.</p>
<h3 id="事务传播行为">事务传播行为</h3>
<h2 id="编程式的事务管理">编程式的事务管理</h2>
<p>很少用。 Spring提供了TransactionTemplate.</p>
<h2 id="使用xml配置声明式事务">使用xml配置声明式事务</h2>
<p>Spring的声明式事务管理是通过Spring AOP实现的，通过事务的声明性信息，Spring负责将事务管理增强逻辑动态织入业务方法相应连接点中。<br>这些逻辑包括获取线程绑定资源，开始事务，提交/回滚事务，进行异常转换和处理工作。</p>
<h3 id="一个被实施事务增强的服务接口">一个被实施事务增强的服务接口</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IViewSpace {</div><div class="line">    <span class="keyword">void</span> addViewSpace(ViewSpace space);</div><div class="line">    <span class="keyword">void</span> updateViewSpace(ViewSpace space);</div><div class="line">    ViewSpace getViewSpace(<span class="keyword">int</span> spaceId);</div><div class="line">    <span class="keyword">int</span> getViewSpaceNum();</div><div class="line">    <span class="keyword">void</span> deleteViewSpace(<span class="keyword">int</span> spaceId);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们希望对addViewSpace和updateViewSpace拥有写事务的能力， 而另外两个拥有读事务的能力。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Transactional</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewSpaceImpl</span> <span class="keyword">implements</span> <span class="title">IViewSpace</span> </span>{</div><div class="line">    <span class="keyword">private</span> ViewSpaceDao viewSpaceDao;</div><div class="line">    <span class="keyword">private</span> ViewPointDao viewPointDao;</div><div class="line"></div><div class="line">    <span class="annotation">@Transactional</span>(readOnly=<span class="keyword">true</span>)</div><div class="line">    <span class="keyword">public</span> ViewSpace <span class="title">getViewSpace</span>(<span class="keyword">int</span> spaceId) {</div><div class="line">        <span class="keyword">return</span> viewSpaceDao.getViewSpace( spaceId);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewSpace</span>(ViewSpace viewSpace) {</div><div class="line">        viewSpaceDao.updateViewSpace(viewSpace);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewSpaceNum</span>() {</div><div class="line">        <span class="keyword">return</span> viewSpaceDao.getViewSpaceNum();</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewSpaceDao</span>(ViewSpaceDao viewSpaceDao) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao = viewSpaceDao;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPointDao</span>(ViewPointDao viewPointDao) {</div><div class="line">        <span class="keyword">this</span>.viewPointDao = viewPointDao;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpace</span>(ViewSpace space) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao.addViewSpace(space);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteViewSpace</span>(<span class="keyword">int</span> spaceId) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao.deleteViewSpace(spaceId);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>ViewSpaceImpl是一个POJO, 只是简单使用持久层的多个DAO类。</p>
<h3 id="使用原始的TransactionProxyFactoryBean">使用原始的TransactionProxyFactoryBean</h3>
<p>了解TransactionProxyFactoryBean有助于跟直观</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--1. 引入dao和DataSource的配置文件--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"classpath:applicationContext-dao.xml"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--2. 声明事务管理器--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"txManager"</span></span></div><div class="line">    <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--3. 需要实施事务增强的目标业务bean--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"viewSpaceTarget"</span></span></div><div class="line">        <span class="attribute">class</span>=<span class="value">"com.smart.service.impl.ViewSpaceImpl"</span></div><div class="line">        <span class="attribute">p:viewSpaceDao-ref</span>=<span class="value">"viewSpaceDao"</span></div><div class="line">        <span class="attribute">p:viewPointDao-ref</span>=<span class="value">"viewPointDao"</span>/&gt;</div><div class="line"><span class="comment">&lt;!--4. 使用事务代理工程类为目标业务Bean提供事务增强--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"viewSpaceService"</span></span></div><div class="line">    <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span></div><div class="line">    <span class="attribute">p:transactionManager-ref</span>=<span class="value">"txManager"</span></div><div class="line">    <span class="attribute">p:target-ref</span>=<span class="value">"viewSpaceTarget"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"get*"</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>异常回滚/提交规则</p>
<p><prop>内的值为事务属性配置信息， 格式如下：</prop></p>
<pre><code>PROPAGATION_REQUIRED, ISOLATION, readOnly, -<span class="keyword">Exception</span>, +<span class="keyword">Exception</span>
</code></pre><h3 id="基于tx/aop命名空间的配置">基于tx/aop命名空间的配置</h3>
<p>Spring基于Schema的配置中,添加了一个tx命名空间， 在配置文件中医明确结构化的方式定义事务属性，<br>大大提高配置事务属性的便利性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">import</span> resource=<span class="string">"classpath:applicationContext-dao.xml"</span> /&gt;</div><div class="line">&lt;!--①不再需要为了事务<span class="type">AOP</span>增强的实施而改名换姓--&gt;</div><div class="line">&lt;bean id=<span class="string">"viewSpaceService"</span></div><div class="line">    class=<span class="string">"com.smart.service.impl.ViewSpaceImpl"</span></div><div class="line">    p:viewSpaceDao-<span class="keyword">ref</span>=<span class="string">"viewSpaceDao"</span></div><div class="line">    p:viewPointDao-<span class="keyword">ref</span>=<span class="string">"viewPointDao"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--<span class="number">2</span>. 事务管理器--&gt;</div><div class="line">&lt;bean id=<span class="string">"txManager"</span></div><div class="line">    class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></div><div class="line">    p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div><div class="line"></div><div class="line">&lt;aop:config&gt;</div><div class="line">    &lt;!--③-<span class="number">1</span>通过aop定义事务增强切面--&gt;</div><div class="line">    &lt;aop:pointcut id=<span class="string">"serviceMethod"</span></div><div class="line">                    expression=<span class="string">"execution(* com.smart.service.*Service.*(..))"</span> /&gt;</div><div class="line">    &lt;!--③-<span class="number">2</span>引用事务增强--&gt;</div><div class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>=<span class="string">"serviceMethod"</span> advice-<span class="keyword">ref</span>=<span class="string">"txAdvice"</span> /&gt;</div><div class="line">&lt;/aop:config&gt;</div><div class="line"></div><div class="line">&lt;!--④事务增强--&gt;</div><div class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"txManager"</span>&gt;</div><div class="line">    &lt;!--④-<span class="number">1</span>事务属性定义--&gt;</div><div class="line">    &lt;tx:attributes&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"get*"</span> read-only=<span class="string">"false"</span>/&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"add*"</span> rollback-<span class="keyword">for</span>=<span class="string">"Exception"</span> /&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"update*"</span>/&gt;</div><div class="line">    &lt;/tx:attributes&gt;</div><div class="line">&lt;/tx:advice&gt;</div></pre></td></tr></table></figure>

<p><tx:method> 元素：</tx:method></p>
<ul>
<li>name</li>
<li>progagation</li>
<li>isolation</li>
<li>timeout</li>
<li>read-only</li>
<li>rollback-for</li>
<li>no-rollback-for</li>
</ul>
<h2 id="使用注解配置声明式事务">使用注解配置声明式事务</h2>
<h1 id="7-_Spring_MVC">7. Spring MVC</h1>
<h2 id="概述">概述</h2>
<p>围绕DispatcherServlet核心展开，DispatcherServlet是Spring MVC的总导演，总策划，它负责截获请求并将其分派给相应的处理器处理。</p>
<p>Spring MVC 包括:</p>
<ul>
<li>注解控制器</li>
<li>请求及响应的相信处理</li>
<li>视图解析</li>
<li>本地化解析</li>
<li>删除文件解析</li>
<li>异常处理</li>
<li>表单标签绑定</li>
</ul>
<h3 id="体系结构">体系结构</h3>
<ol>
<li>client发起一个HTTP请求, 若匹配到DispatcherServlet的请求映射路径(web.xml中指定). web容器将该请求转交给DispatcherServlet处理。</li>
<li>DispatcherServlet收到该请求后，将根据请求的信息(Url, http方法, 请求报文头, 请求参数, Cookie等)及HandlerMapping的配置找到处理请求的处理器（Handler).</li>
<li>通过HandlerAdapter对Handler进行封装， 再以统一的适配器接口调用Handler.</li>
<li>Handler完成业务逻辑的处理后将返回一个ModelAndView给DispatcherServlet, ModelAndView包括了视图逻辑名和模型数据信息.</li>
<li>ModelAndView中包含的“逻辑视图名”而非真正的视图对象, DispatcherServlet借由ViewResolver完成逻辑视图到真实视图对象的解析工作。</li>
<li>当得到真实的视图对象view后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。</li>
<li>最终client获取得到的响应消息可能是一个普通的html页面， 也可能是一个xml或json串，甚至是一张图片或一个pdf文档等不同的媒体形式。</li>
</ol>
<h3 id="配置DispatcherServlet">配置DispatcherServlet</h3>
<ol>
<li>如何截获特定的http请求，交由spring MVC框架处理？</li>
</ol>
<p>配置DispatcherServlet,截获特定的URL请求</p>
<p>在web.xml配置一个Servlet, 并通过<servlet-mapping>指定器处理的url.</servlet-mapping></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--1. 业务层和持久层的配置文件，被父Spring容器使用--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:/conf/applicationContext.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--2. 声明DispatcherServlet. 默认自动加载/WEB-INF/viewspace-servlet.xml--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>viewspace<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--3. 为Dispatcher匹配的URL模式. 指定DispatcherServlet处理所有URL以.html为后缀的HTTP请求--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>viewspace<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>

<p>DispatcherServlet遵循“契约优于配置”的原则，在大多数情况下， 无须精心额外的配置。</p>
<p><servlet>的<init-param>参数:</init-param></servlet></p>
<ul>
<li>namespace</li>
<li>contextConfigLocation</li>
<li>publishContent</li>
<li>publishEvents</li>
</ul>
<h2 id="注解驱动的控制器">注解驱动的控制器</h2>
<h1 id="8-_单元测试">8. 单元测试</h1>
<h2 id="概述-1">概述</h2>
<h3 id="基本概念">基本概念</h3>
<p>被测系统(System Under Test):</p>
<p>测试替身(Test Double): 使用测试替身，也可称为Mock, 减少被测对象的依赖。</p>
<p>测试夹具(Test Fixture): 在测试方法之前自动进行初始化，和资源回收的工作。 @BeforeMethod, @AfterMethod, @Test, @BeforeClass, @AfterClass</p>
<p>测试用例(Test Case)</p>
<p>测试套件(TEst Suite)</p>
<h2 id="TestNG快速进阶">TestNG快速进阶</h2>
<h3 id="异常测试">异常测试</h3>
<p>使用expetedExceptions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> AutoNameAdviceTest {</div><div class="line">    <span class="keyword">private</span> User user;</div><div class="line">    @Test(enabled = <span class="keyword">true</span>, expectedExceptions = NullPointerException.class)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUser</span>(){</div><div class="line">        user= <span class="keyword">new</span> User();</div><div class="line">        assertNotNull(user.getLastIp());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="超时测试">超时测试</h3>
<p>若在指定时间完成， 就通过测试.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Test</span>(timeOut = <span class="number">10</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeout</span>(){</div><div class="line">    user= <span class="keyword">new</span> User();</div><div class="line">    assertNotNull(user);</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        Thread.sleep(<span class="number">11</span>);</div><div class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">        e.printStackTrace();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="参数化测试">参数化测试</h3>
<h1 id="9-_敏捷开发技术">9. 敏捷开发技术</h1>
<h1 id="10-_自己动手打造服务平台框架">10. 自己动手打造服务平台框架</h1>
<h1 id="11-_实战案例开发">11. 实战案例开发</h1>
<pre><code>      p:<span class="variable">proxyTargetClass=</span><span class="string">"true"</span>/&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2014/12/02/Spring3-0就这么简单/" data-id="vnksoj35p9u4whw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Erlang/" style="font-size: 12.50px;">Erlang</a><a href="/tags/Ice/" style="font-size: 12.50px;">Ice</a><a href="/tags/Vim/" style="font-size: 12.50px;">Vim</a><a href="/tags/golang/" style="font-size: 12.50px;">golang</a><a href="/tags/hadoop/" style="font-size: 15.00px;">hadoop</a><a href="/tags/hbase/" style="font-size: 12.50px;">hbase</a><a href="/tags/java/" style="font-size: 17.50px;">java</a><a href="/tags/javascript/" style="font-size: 15.00px;">javascript</a><a href="/tags/node/" style="font-size: 12.50px;">node</a><a href="/tags/program/" style="font-size: 15.00px;">program</a><a href="/tags/scala/" style="font-size: 17.50px;">scala</a><a href="/tags/scalao/" style="font-size: 10.00px;">scalao</a><a href="/tags/think/" style="font-size: 12.50px;">think</a><a href="/tags/tool/" style="font-size: 15.00px;">tool</a><a href="/tags/分布式系统/" style="font-size: 12.50px;">分布式系统</a><a href="/tags/如何记笔记/" style="font-size: 12.50px;">如何记笔记</a><a href="/tags/笔记/" style="font-size: 20.00px;">笔记</a><a href="/tags/管理/" style="font-size: 12.50px;">管理</a><a href="/tags/读书笔记/" style="font-size: 12.50px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/27/ProgrammingScala/">ProgrammingScala</a>
          </li>
        
          <li>
            <a href="/2015/03/22/sbt学习/">sbt学习</a>
          </li>
        
          <li>
            <a href="/2015/03/22/ScalaInDepth/">ScalaInDepth</a>
          </li>
        
          <li>
            <a href="/2015/03/19/代码的未来/">代码的未来</a>
          </li>
        
          <li>
            <a href="/2015/03/17/深入理解JVM虚拟机/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Peter Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>
