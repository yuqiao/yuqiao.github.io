<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Joe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="enjoy life">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe's Blog">
<meta property="og:url" content="http://yuqiao.github.io/page/2/">
<meta property="og:site_name" content="Joe's Blog">
<meta property="og:description" content="enjoy life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe's Blog">
<meta name="twitter:description" content="enjoy life">

  
    <link rel="alternative" href="/atom.xml" title="Joe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Carpe Diem</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yuqiao.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-p专业主义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/p专业主义/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/p专业主义/">专业主义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>专业,你唯一的生存之道.</p>
<h1 id="前言_预言将自我实现">前言 预言将自我实现</h1>
<p>大前研一强调”希波克拉底誓言”对于企业职业价值的意义.<br>我们并不是因为专业技术成为专家, 而是因为”向上帝发誓, 以此为职业” - 把顾客作为出发点而成为专家.</p>
<p>专家阶层的势力迟早会增强, 并动摇日本的产业界.</p>
<p>在职业化的时代，自由竞争越来越健全，真正拥有实力的人越来越受到推崇。</p>
<p>预言: 人人都能成为专家.</p>
<p>你凭什么胜出？<br>未来能够牵动世界大势的，是个人之间的竞争。<br>能否独霸世界舞台，锻造他人无法超越的核心竞争力。<br>你唯一的依恃，就是专业。</p>
<p>你够专业吗？<br>专业不是职业，职业人士不同于专家。<br>细微的差别，却是成败的关键。</p>
<p>真正的专家具备四种能力:</p>
<ul>
<li>先见能力</li>
<li>构思能力</li>
<li>讨论的能力</li>
<li>适应矛盾的能力</li>
</ul>
<h1 id="1-_你够专业吗?">1. 你够专业吗?</h1>
<p>专家要控制自己的情感, 并靠理性而行动. 他们不仅具备较强的专业知识和技能以及较强的理念,<br>而且无一例外地以顾客为第一位,具有无穷的好奇心和永无止境的进取心,严格遵守纪律.<br>以上条件全部具备的人才, 才能成为专家.</p>
<h2 id="专家的定义">专家的定义</h2>
<p>一种健康的危机感正在蔓延, 大家感到”国家和社会已经靠不住了”, 提升自身价值的现象正在萌芽.</p>
<h2 id="被遗忘的”对顾客的誓言”">被遗忘的”对顾客的誓言”</h2>
<p>专家的词源本身”profess”, 意思是”向上帝发誓,以此为职业”</p>
<p>希波克拉底誓言:</p>
<ol>
<li>请允许我行医,我要终生奉行人道主义.</li>
<li>向恩师表达尊敬和感谢之意.</li>
<li>在行医过程中严守良心和尊严.</li>
<li>以患者的健康与生命放在第一位.</li>
<li>严格为患者保守秘密.</li>
<li>保持医学界的名誉与宝贵的传统.</li>
<li>把同事视为兄弟, 不因患者的人种,宗教国籍和社会地位的不同而区别对待.</li>
<li>从受孕之始,即把人的生命作为至高无上之物来尊重.</li>
<li>无论承受怎样的压力, 在运用自己的知识时也不会违背人道主义.</li>
</ol>
<p>企业通过商品与服务销售誓言,那是百分之百地让你满意,顾客购买的就是这种誓言.</p>
<h2 id="顾客无处不在">顾客无处不在</h2>
<p>官僚就是公仆, 所谓”官僚主义”,应该可以理解为为社会和他人献身,但现在这个词被赋予贬义,真是一种讽刺.</p>
<p>“你的工资是顾客给的”. </p>
<p>通过考虑顾客的顾客,可以把目标领域扩展到其他行业, 这就为重新审视现有的方法提供了契机,并且有可能赢得机会,<br>为直接的客户停供独特的价值.</p>
<p>那些仅仅按照公司的规定采取行动的人,不仅无法称之为专家,而且也不利于公司的发展.因此我们应该铭记,<br>从事任何工作都有首先确定自己的顾客,并发誓为顾客作出贡献.</p>
<h2 id="关于授权的误解">关于授权的误解</h2>
<p>被授予权利,行动获得自由后, 人们容易任意行事.这一现象是由于只强调授权的一面,专业主义这辆车的两个车轮未能同时运转.</p>
<p>有几个问题:</p>
<ul>
<li>权限扩大了, 你能够给顾客提供怎样的价值?</li>
<li>你自身具备使用新权力的能力和技能吗?</li>
<li>能力和技能不足, 无法熟练运用新的权力时,你该怎么办?</li>
</ul>
<p>追求权力容易, 但要保持权利则非常困难.</p>
<p>如果感到自己确实需要权力,并且能够运用手中的权力为顾客服务, 我们就应该去争取权力,而不是等待上司授予自己权力.</p>
<p>授权者应在认清下属的能力和技能并考虑此人今后发展的基础上,确定合适的权限范围;把握下属现有的能力水平与权限所要求的能力水平之间的差距,<br>做好亲自缩短这种差距的准备, 然后再把权力交给下属.当然,切记不要连累顾客.</p>
<p>所谓授权,就是对下属进行投资.</p>
<p>专家能够不断创造事业机会。</p>
<p>对顾客而言, 上司和下属的关系是无所谓的, 专家必须经常考虑顾客的利益.</p>
<h2 id="不断学习,_乐此不彼">不断学习, 乐此不彼</h2>
<p>我们需要这样的专家, 他们从基础知识开始进行系统学习, 亲身实践.对新事物反复消化并不断积累经验;<br>经过持续的训练,他们能够把之间学到的知识提供给别人.</p>
<p>绝不认为自己的本领是绝对的, 而是准备花费一生的时间去磨砺自己,并且乐此不彼.</p>
<p>要想获得成功,先要期盼成功,对自己能够获得成功充满自信.与此同时,如果在自信的背后没有好奇心作为助推器提供动力,<br>是无法达到一流境界的.这一点可以说是区分非凡与平凡的决定性因素.</p>
<h2 id="保有好奇心">保有好奇心</h2>
<p>好奇心不足的人,也就是怠慢自己智慧的人,他们几乎无一例外地属于自我防卫型,对变化采取抵制的态度.</p>
<p>不要怠慢自己的智慧.适可而止的心态不仅对本人,对周围的人也是有害的.</p>
<p>浅尝辄止地完成工作,是无法称为专家.</p>
<h2 id="纪律的力量">纪律的力量</h2>
<p>无论如何完善教育制度,如何增加报酬和改善福利, 也不会产生大批的专家.<br>只有纪律—或者称之为价值观更准确些,才能培养出专家.</p>
<p>对专家而言,是不允许妥协的.所谓”妥协”,指的是只考虑自己的情况, 而无视顾客与商业伙伴的利益,凡事过于乐观.</p>
<p>需要专家在”方向”与”程度”方面给出恰如其分的建议.</p>
<p>在21世纪的经济社会中, 我们要与”看不见的空间”作战.我们需要运作的不再是看得见的人或组织;<br>我们的工作是占领看不见的经济领域,打败其中的人或组织(有时可能是自己公司以外了的人或组织, 有时可能是<br>非特定的多数人或组织).</p>
<p>无论前提条件发生多大的变化,都能够认清深层变化的本质,比别人发挥出更大的能力,这样的人才是专家.</p>
<h1 id="2-_先见能力">2. 先见能力</h1>
<p>今后的时代所需要的先见能力, 是能够看清别人看不到的事物的能力.</p>
<h2 id="看不见的新大陆">看不见的新大陆</h2>
<p>眼睛看不见,手触不到的无形的活动将成为主流.过去辉煌的成功经验不仅不再起作用,甚至会成为发展的瓶颈.</p>
<p>工业化社会的经济是有形的,这种有形的经济虽然没有被废弃, 但已经不再是主流.</p>
<p>在”看不见的新大陆”上开展的生存竞争是毫不留情的. 既没有乞怜于人的时间,也看不到能够接受乞求的人.</p>
<h2 id="战略论的功与过">战略论的功与过</h2>
<p>如今的时代,依靠某些精英学习最新理论,制定战略并严格按照战略进行实践,这种做法已经无法推动企业的发展.</p>
<p>宝丽来失败的根本原因是什么?答案就是固守成功的模式.</p>
<p>战略: 制定规划,使自己的公司与竞争对手之间相对力量关系的变化朝着有利于自己公司高效变化的方向发展.</p>
<p>改变这种力量的三种方法:</p>
<ul>
<li>基于成功的关键因素(KFS)的战略. 可以将资源集中于KFS, 凭借自己公司的股份与收益等优势获胜.</li>
<li>基于相对优势的战略. 着眼于竞争条件的不同,以确保优势. </li>
<li>推动新规划的战略. 积极开拓竞争对手所不涉足的业务,开辟市场.</li>
</ul>
<p>战略论分为两种: </p>
<ul>
<li>定位论</li>
<li>核心竞争力理论</li>
</ul>
<p>这些理论是以稳定发展的工业化社会为背景的: 商品经济无论多么复杂,发展得多么迅速, 我们都能捕捉到商品,竞争和市场的动向,<br>在开发新产品的服务以及开拓新业务时,能够具体把握目标客户与市场.</p>
<p>但20世纪末的十几年间,作为战略论前提的顾客,市场,竞争等因素已不再具有固定的定义.</p>
<p>我们应该铭记一点: 那就是依靠固有的模式与陈旧的知识解释史无前例的现象,这种做法将会给事业的发展带来危害.</p>
<h2 id="在正确的时间做正确的事情">在正确的时间做正确的事情</h2>
<p>如今的时代,改写经济常识的并不一定是实力强大的组织,个人也完全有可能做到.</p>
<p>在新大陆中, 以往的战略论已不再适用, 但还是有不少人获得了成功,这是因为他们充分认清了新大陆的本质.<br>我们只能在新的竞争领域的彼岸遥望他们的生硬, 但沿着他们走过的道路前进则毫无意义.</p>
<p>错过了时机, 便不会成功.更何况在”看不见的新大陆”上, 经济环境的变化与20世纪相比加快了数倍,<br>谨慎被动的对企业与国家而言都将导致致命的损失.</p>
<p>推动未来世界运转的, 是个体之间的竞争, 而不再是国家之间或企业之间的竞争. 优秀的个体之间的竞争<br>转瞬之间便能改变世界.类似1990的托沃兹,具备世界一流才能的人,不知会从何处现身.</p>
<h2 id="先见能力的蜕变">先见能力的蜕变</h2>
<p>今后时代需要的先见能力,是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>纵观事业获得成功的诸多示例,给人留下的印象是这些事业都很富有先见性,并且都按照预言家的预言发展的.<br>在这些事例的背后, 我们自始至终都能看到同样的成功模式:</p>
<ol>
<li>明确定义事业领域(范围).</li>
<li>从分析现状入手预测未来的方向, 可简明扼要地阐明假想的论点, 以分析其因果关系.</li>
<li>在可能有多种选择的情况下, 只精选其中的几种.在推行所选择的方案时,采取强制的方法调配人,<br>财,物等方面资源.</li>
<li>不要迷失假说的基本方向, 不要偏离原则, 除非情况彻底发生变化.</li>
</ol>
<p>当时需要不是天才的灵感, 也不是预言家的素质,而是对一系列的逻辑过程毫不松懈地落实的执行能力:<br>定义事业领域, 从分析现状入手, 预测将来的方向.<br>但今后的时代需要的先见能力, 是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>所以不能简单依靠现有的战略论和过去的成功经验, 重要是把精力集中在不断认识前人未曾涉及的世界,<br>并磨练自觉的资质上.</p>
<h2 id="怀疑一切">怀疑一切</h2>
<p>要想学习没有常识的世界中的新常识, 即21世界的规则, 首先必须有意识地让自己习惯对命苦玉溪的一个个常识提出质疑.</p>
<p>众所周知, 人类的大脑具备这样的功能, 它会把新的信息与”过去的经验或积累的部分知识”相对照, 然后加以调整并接受.<br>如果眼前新的现实与大脑中的存储的固有信息无法协调, 便会在无意识中拒绝新的现实(当做没看见);<br>或者通过子句一知半解的知识任意推测,使自己认识到的情况偏离实际(产生错觉).<br>这是人类的一种本能, 目的在于使自己保持冷静.</p>
<p>20世纪充满常识, 而21世纪是一个无常识可言,而且会突然发生变化的时代.<br>若被旧世界的常识所束缚, 就无法在瞬间抓住并正确理解新世界中的新事实,更不可能预见到新的事业.</p>
<p>人的大脑有一种习性, 那就是”只能看到想看的东西”, 因此我们需要特别注意从成功的体验中得到的知识和理论.<br>有可能并不再适用.</p>
<p>知识来自先驱者们的研究与经验,是在反复试验, 反复失败的摸索中获得的.如果已经得到明确的知识, 则说明这块领域已被<br>无数人造访过,已毫无商机可言.<br>此后的商务专家必须比以前更加怀疑常识,并抛弃现有的知识, 也就是坚决养成”不学习”的习惯.</p>
<p>怀疑常识并不是毫无想法, 而是有意识地假设一个相反的观点, 并不断地反复验证, 把20世纪的学习变成一个破坏i类极具<br>创造性的”不学习”的过程.</p>
<p>只有对”看不见的新大陆”有所预见,才能确保自己不会丢掉工作, 获得丰厚的薪水.抛弃先例,养成怀疑常识的习惯,获得洞悉变化本质的能力—<br>即使说这一切是商务专家的生命线,也绝不过分.</p>
<h2 id="享受变化">享受变化</h2>
<p>只有具备享受变化与失败的素质,或者说是从容镇定的心情,好奇心和气魄, 才能成为”打破规则者”, 才可能带来变化.</p>
<p>在新的经济空间里, 对所从事的事业进行取舍是成败的关键. 这需要人们在自己的头脑中一边想象一边完成,<br>因为我们无法依靠别人创造的模式对事业的成败进行取舍.</p>
<p>我们只有经历无数次的失败,遍体鳞伤, 才能学会在新的竞争领域中较为实用的生存技能.</p>
<p>惧怕风险, 企图逃避风险, 这样做是为了种族延续, 是生物的本能.向未知的领域挑战是先驱者们的任务, 也是企业家的乐趣.<br>新的竞争领域就在眼前, 我毫无惧色,因为我能够经常预感到变化, 心情愉快地以失败为食粮拓展自己的世界,<br>对此我感到非常地自豪.</p>
<p>在任何地方, 被称为名人或高手的人大体上都具备: 慎重和大胆两方面的素质.</p>
<h2 id="不怕失败,执着探索">不怕失败,执着探索</h2>
<p>回避争论, 不习惯争论, 对于具备国际水准的专家而言, 是致命的弱点.</p>
<p>害怕新的竞争领域, 不敢投身其中, 是永远也无法掌握新领域的规则的, 而且也无法继续生存下去.</p>
<p>怠于思考的人是无法否定一切的. 他们惧怕失败, 因此不想承认自己是错误的.坦率地承认自己的错误, 意味着对思考永不厌倦.</p>
<p>在向新的竞争领域迈进时, 应具备以假象为支柱反复试验, 不怕失败的姿态. 换言之, 即使失败,也要勇往直前, 坚信下次一定能成功,<br>这种执着的精神是我们的附身符之一.</p>
<p>要认清变化的本质, 首先对身边的变化逐一反复地向自己提问:为什么会这样, 新在什么地方, 从中会产生什么, 其真正的价值何在.<br>然后从中确定课题, 建立假说, 搜集事实一认清这一假说,并进行分析和验证, 重新构建自己的观点.</p>
<h2 id="偏执狂的危机感">偏执狂的危机感</h2>
<p>一个高水平的偏执狂正因为具备了紧张感, 他的感受力才很强.才能通过其卓越的洞察力施展自己的行动能力.</p>
<p>比尔盖茨说过:”如果今天我的决策失误一次, 这家公司明天就会倒闭.如今我依然有这种危机感.”</p>
<p>格鲁夫:”只有偏执狂才能生存.”. 偏执狂: 对组织,对他人的思想或行动抱有怀疑态度.<br>只有那些总以为自己的经营环境危机四伏并时刻关注各种”坏消息”的企业,才有可能免于灭亡.</p>
<p>成功的背后必定潜藏着危机.</p>
<p>未曾开发的新竞争领域前途莫测. 因为不了解, 我们对任何情况都感到非常紧张,这种紧张感能够唤醒我们的知觉, 提高我们对事物的洞察力.<br>分析问题的速度与应对危机的能力.</p>
<p>如果是享受变化, 执着探索以及不效仿20世纪是在”看不见的新大陆”生存必不可少的条件,那么紧张感, 也就是积极的猜疑心理,<br>便是磨砺先见能力的”强心剂”.在”看不见的新大陆”上, 我们需要这种”强心剂”发挥作用, 否则我们便无法跟上变化的速度.</p>
<h2 id="磨练自觉能力">磨练自觉能力</h2>
<h2 id="对事业倾注全力">对事业倾注全力</h2>
<h2 id="“看不见的新大陆”为何看不见">“看不见的新大陆”为何看不见</h2>
<h1 id="3-_构思能力">3. 构思能力</h1>
<h2 id="仅有先见能力是不够的">仅有先见能力是不够的</h2>
<h2 id="成功的必要条件和充分条件">成功的必要条件和充分条件</h2>
<h2 id="把握变化的速度和规模">把握变化的速度和规模</h2>
<h2 id="电子商务的三个关键点">电子商务的三个关键点</h2>
<h2 id="设定满足8亿人市场的标准">设定满足8亿人市场的标准</h2>
<h2 id="未雨绸缪">未雨绸缪</h2>
<h2 id="“and”还是”or”">“and”还是”or”</h2>
<h2 id="勇于自我否定">勇于自我否定</h2>
<h2 id="视成功为过去时">视成功为过去时</h2>
<h2 id="追求”深度经济”">追求”深度经济”</h2>
<h1 id="4-_讨论的能力">4. 讨论的能力</h1>
<h2 id="避免对企业发展无益的讨论">避免对企业发展无益的讨论</h2>
<h2 id="符合逻辑的思考vs-符合逻辑的讨论">符合逻辑的思考vs.符合逻辑的讨论</h2>
<h2 id="讨论的能力可以后天养成">讨论的能力可以后天养成</h2>
<h2 id="逻辑是全球唯一的通用语">逻辑是全球唯一的通用语</h2>
<h2 id="确保提问符合逻辑">确保提问符合逻辑</h2>
<h2 id="倾听的能力与说服的能力">倾听的能力与说服的能力</h2>
<h2 id="不可掉入诡辩的陷阱">不可掉入诡辩的陷阱</h2>
<h2 id="尽情讨论,直到权威者发话">尽情讨论,直到权威者发话</h2>
<h2 id="符合逻辑的反驳">符合逻辑的反驳</h2>
<h2 id="亚里士多德的逻辑学">亚里士多德的逻辑学</h2>
<h2 id="成功始于坚定的信念">成功始于坚定的信念</h2>
<h1 id="5-_适应矛盾的能力">5. 适应矛盾的能力</h1>
<h2 id="企业经营没有唯一的最佳答案">企业经营没有唯一的最佳答案</h2>
<h2 id="经营中包含的矛盾">经营中包含的矛盾</h2>
<h2 id="解决问题的能力与沟通的能力">解决问题的能力与沟通的能力</h2>
<h2 id="集权与分权">集权与分权</h2>
<h2 id="全球化与本地化">全球化与本地化</h2>
<h2 id="竞争与顾客">竞争与顾客</h2>
<h2 id="自由与统帅">自由与统帅</h2>
<h2 id="左脑与右脑">左脑与右脑</h2>
<h1 id="结语">结语</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/p专业主义/" data-id="zwjtonorw13p8bap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/管理/">管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript权威指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/18/javascript权威指南/" class="article-date">
  <time datetime="2015-02-17T23:57:09.000Z" itemprop="datePublished">2月 18 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/18/javascript权威指南/">javascript权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Javascript概述">1. Javascript概述</h1>
<p>Javascript是面向Web的编程语言。</p>
<p>前端工程师必须掌握的三大技能: </p>
<ul>
<li>描述网页内容的HTML </li>
<li>描述网页样式的css </li>
<li>描述网页行为的Javascript</li>
</ul>
<p>Firefox的插件Firebug: <a href="http://getfirebug.com/" target="_blank" rel="external">http://getfirebug.com/</a></p>
<p>F12唤醒Firefox操作面板 Ctrl+Shift+J唤醒错误控制台(Error Console).</p>
<h2 id="Javascript语言核心">Javascript语言核心</h2>
<p>变量和赋值：</p>
<pre><code><span class="title">var</span> x;
<span class="title">x</span> = <span class="number">0</span>;

<span class="title">x</span>
x = <span class="number">1</span>;
<span class="title">x</span> = <span class="number">0</span>.<span class="number">01</span>;
<span class="title">x</span> = <span class="string">"hello world"</span>;
<span class="title">x</span> = <span class="string">'hello world'</span>;
<span class="title">x</span> = <span class="built_in">true</span>;
<span class="title">x</span> = null;
<span class="title">x</span> = undefined;
</code></pre><p>复杂类型:</p>
<pre><code><span class="keyword">var</span> book = {
    topic: <span class="string">"Javascript"</span>,
    fat: <span class="keyword">true</span>
};

book.topic
book[<span class="string">'fat'</span>]
book.author = <span class="string">'Flanagan'</span>;
book.content = {};

<span class="keyword">var</span> primes = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];
primes[<span class="number">0</span>]
primes.length
primes[primes.length -<span class="number">1</span> ]
primes[<span class="number">4</span>] = <span class="number">9</span>;  <span class="comment">// 通过赋值添加新元素</span>
primes[<span class="number">4</span>] = <span class="number">11</span>;
<span class="keyword">var</span> <span class="keyword">empty</span> = []
<span class="keyword">empty</span>.length

<span class="keyword">var</span> points = [
    {x:<span class="number">0</span>, y:<span class="number">0</span>},
    {x:<span class="number">1</span>, y:<span class="number">1</span>}
];

<span class="keyword">var</span> data = {
    trial1: [ [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],
    trial2: [ [<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]
}
</code></pre><p>表达式：</p>
<pre><code><span class="number">3</span> + <span class="number">2</span>
<span class="number">3</span> - <span class="number">2</span>
<span class="number">3</span> * <span class="number">2</span>
<span class="number">3</span> / <span class="number">2</span>                           <span class="comment">// =&gt; 1.5</span>
points[<span class="number">1</span>].x - points[<span class="number">0</span>].x  
<span class="string">"3"</span> + <span class="string">"2"</span>                       <span class="comment">// =&gt; "32" </span>

<span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span>;
<span class="built_in">count</span> ++;
<span class="built_in">count</span> --;
<span class="built_in">count</span> += <span class="number">2</span>;
<span class="built_in">count</span> *= <span class="number">3</span>;
<span class="built_in">count</span>

<span class="keyword">var</span> x=<span class="number">2</span>, y=<span class="number">3</span>;
x == y
x != y
x &lt; y
<span class="string">"two"</span> &gt; <span class="string">"three"</span>

(x == <span class="number">2</span>) &amp;&amp; (y==<span class="number">3</span>)
</code></pre><p>函数:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">plus1</span><span class="params">(x)</span></span>{
    reutrn x +<span class="number">1</span>;
}
plus1(y)

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{
    <span class="keyword">return</span> x * x;
};

square(plus1(y))
</code></pre><p>将函数和对象合写在一起， 方法：</p>
<pre><code><span class="keyword">var</span> a = [];
a.push(<span class="number">1</span>, <span class="number">2</span> <span class="number">3</span>);
a.reverse();

<span class="comment">// "this"关键字是对定义方法对象的引用</span>
points.dist = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> p1 = <span class="keyword">this</span>[<span class="number">0</span>];
    <span class="keyword">var</span> p2 = <span class="keyword">this</span>[<span class="number">1</span>];
    <span class="keyword">var</span> a = p2.x - p1.x
    <span class="keyword">var</span> b = p2.y - p2.y;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(a*<span class="number">2</span> + b*b ）
points.dist()
</code></pre><p>控制语句：</p>
<pre><code><span class="keyword">function</span> abs(x) {
    <span class="keyword">if</span>(x &gt;=<span class="number">0</span>){
        <span class="keyword">return</span> x;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> -x;
    }
}

//<span class="keyword">...</span>    
    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i+){
        //<span class="keyword">...</span>
    }
    <span class="keyword">while</span>(true){
        //<span class="keyword">...</span>
    }
</code></pre><p>对象：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
}
<span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);

Point.prototype.r = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(
        <span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y);
    };
p.r();
</code></pre><h1 id="2-_词法结构">2. 词法结构</h1>
<h1 id="3-_类型，值和变量">3. 类型，值和变量</h1>
<h1 id="4-_表达式和运算符">4. 表达式和运算符</h1>
<h1 id="5-_语句">5. 语句</h1>
<h1 id="6-_对象">6. 对象</h1>
<p>对象是一种复合值: 将很多值聚合在一起， 可通过名字访问这些值。</p>
<p>对象可以看做属性的无序集合，每个属性都是一个名/值对。</p>
<p>属性名是字符串，因此我们可以吧对象看成从字符串到值的映射。</p>
<p>对象不仅仅是字符串到值的映射，除了可以保持自有的属性，对象还可以从一个称为原型的对象继承属性。<br>对象的方法通常是继承的属性。</p>
<p>“原型式继承”是Javascript的核心特征。</p>
<h2 id="创建对象">创建对象</h2>
<p>三种方式.</p>
<h3 id="对象直接量">对象直接量</h3>
<pre><code><span class="keyword">var</span> <span class="keyword">empty</span> = {}
<span class="keyword">var</span> point = {x:<span class="number">0</span>, y:<span class="number">0</span>}
<span class="keyword">var</span> book = {
    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,
    <span class="string">"sub-title"</span>:<span class="string">"The Definitive Guide"</span>
}
</code></pre><h3 id="new创建对象">new创建对象</h3>
<pre><code><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个空对象， 和{}一样</span>
<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个空数组, 和[]一样</span>
<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); 
<span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>);
</code></pre><p>除了这些内置构造函数， 也可以自定义构造函数来初始化新对象。</p>
<h3 id="原型">原型</h3>
<pre><code><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create({x:<span class="number">1</span>, y:<span class="number">2</span>}) <span class="comment">// o1 继承了属性x和y</span>
<span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype) <span class="comment">// o3 和 {} 一样</span>
</code></pre><p>可以通过任何原型创建对象:</p>
<p>function inherit(p){<br>    if(p==null) throw TypeError();<br>    if(Object.create) return Object.create(p);<br>    var t= typeof p;<br>    if(t!== “object”&amp;&amp; t!== “function”) throw TypeError();<br>    fucntion f() {} // 定义一个空构造函数<br>    f.prototype = p;<br>    return new f();<br>}</p>
<h2 id="属性的查询和设置">属性的查询和设置</h2>
<p>通过.和[]来获取属性的值。</p>
<p>Javascript对象都是关联数组。</p>
<p>属性访问错误，会抛出一个类型错误异常。</p>
<p>避免错误的方法:</p>
<pre><code><span class="keyword">var</span> <span class="built_in">len</span> = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;
</code></pre><h2 id="删除属性">删除属性</h2>
<p>delete book.author<br>delete book[“main title”]</p>
<h2 id="检测属性">检测属性</h2>
<h2 id="枚举属性">枚举属性</h2>
<p>for/in循环可以在循环体中遍历对象中所有可枚举的属性。<br>对象继承的内置方法是不可枚举的。<br>d但在代码中给对象添加的属性是可枚举的。</p>
<h2 id="属性getter和setter">属性getter和setter</h2>
<h2 id="属性的特征">属性的特征</h2>
<p>除了包含名字和值之外，属性还包含一些标识他们可写，可枚举和可配置的特性。</p>
<h2 id="对象的三个属性">对象的三个属性</h2>
<p>每个对象都有与之相关的原型(prototype), 类(class)和可扩展性().</p>
<h2 id="序列化对象">序列化对象</h2>
<h2 id="对象方法">对象方法</h2>
<h1 id="7-_数组">7. 数组</h1>
<h1 id="8-_函数">8. 函数</h1>
<p>函数即对象。</p>
<h2 id="函数定义">函数定义</h2>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">distance</span><span class="params">(x1, y1, x2, y2)</span></span>{
    <span class="keyword">var</span> dx = x2 - x1;
    <span class="keyword">var</span> dy = y2 - y1;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);
}

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{<span class="keyword">return</span> x*x;}

<span class="comment">// 函数表达式可以包含名称</span>
<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(x)</span> </span>{ <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x * faxt(x-<span class="number">1</span>);};

data.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>{<span class="keyword">return</span> a-b;});
</code></pre><p>嵌套函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span><span class="params">(a,b)</span></span>{
    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(x)</span></span>{<span class="keyword">return</span> x*x;}
    reurn <span class="built_in">Math</span>.sqrt(square(a) +square(b));
}
</code></pre><h2 id="函数调用">函数调用</h2>
<p>有四种方式.</p>
<h3 id="函数调用-1">函数调用</h3>
<h3 id="方法调用">方法调用</h3>
<h1 id="9-_类和模块">9. 类和模块</h1>
<h1 id="10-_正则表达式的模式匹配">10. 正则表达式的模式匹配</h1>
<h1 id="11-_Javascript的子集和扩展">11. Javascript的子集和扩展</h1>
<h1 id="12-_服务端Javascript">12. 服务端Javascript</h1>
<h1 id="13-_Web浏览器中的Javascript">13. Web浏览器中的Javascript</h1>
<h1 id="14-_windows对象">14. windows对象</h1>
<h1 id="15-_脚本化文档">15. 脚本化文档</h1>
<h1 id="16-_脚本化css">16. 脚本化css</h1>
<h1 id="17-_事件处理">17. 事件处理</h1>
<h1 id="18-_脚本化http">18. 脚本化http</h1>
<h1 id="19-_JQuery类库">19. JQuery类库</h1>
<h1 id="20-_客户端存储">20. 客户端存储</h1>
<h1 id="21-_多媒体和图形编程">21. 多媒体和图形编程</h1>
<h1 id="22-_HTML5_API">22. HTML5 API</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/18/javascript权威指南/" data-id="r2tcz3rjcn12u8oj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node即学即用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/17/node即学即用/" class="article-date">
  <time datetime="2015-02-17T14:06:27.000Z" itemprop="datePublished">2月 17 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/17/node即学即用/">node即学即用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言">前言</h1>
<p>本书目标：了解Node平台本身，还能掌握Node为快速高效地构建高扩展性网站和服务提供多个重要模块。</p>
<h1 id="1-_Node-js简介">1. Node.js简介</h1>
<p>Node的特性： </p>
<ul>
<li>对高性能的追求</li>
<li>利用了Javascript的事件驱动(Event-driven)特性。 采用了事件驱动(event loop)架构，让开发高效的服务端程序变得简单和安全。</li>
<li>提供了一系列“非阻塞”函数库来支持事件循环特性：把文件系统和数据库操作封装成事件驱动形式的函数接口</li>
<li>能在服务端运行Javascript.</li>
<li>开发者很容易为其扩展新的库。</li>
</ul>
<h2 id="写代码">写代码</h2>
<h3 id="Node_REPL">Node REPL</h3>
<h3 id="编写首个服务器程序">编写首个服务器程序</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">http</span> = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">http</span>.createServer(<span class="function"><span class="keyword">function</span> (<span class="title">req</span>, <span class="title">res</span>){</span></div><div class="line">    res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>})</div><div class="line">    res.<span class="keyword">end</span>(<span class="string">'Hello, node\n'</span>)</div><div class="line">}).listen(<span class="number">8124</span>, <span class="string">'127.0.0.1'</span>)</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'Server running at http://127.0.0.1:8124'</span>)</div></pre></td></tr></table></figure>

<h2 id="为何选用Node">为何选用Node</h2>
<h3 id="高性能Web服务器">高性能Web服务器</h3>
<h1 id="2-_编写有趣的应用">2. 编写有趣的应用</h1>
<h2 id="创建一个聊天服务器">创建一个聊天服务器</h2>
<p>需要在Node中包含TCP模块，创建一个新的TCP服务器:</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer()

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.write(<span class="string">'Hi!\n'</span>)
    client.write(<span class="string">'Bye!\n'</span>)
    client.end()
})

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>使用telnet连接服务器测试： telnet 127.0.0.1 9000</p>
<p>首先需要手动客户端发送的消息：</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer()

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.write(<span class="string">'Hi!\n'</span>)
    client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        <span class="built_in">console</span>.log(data)
    })
})

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>这里添加了另外一个事件监听器，调用的是client.on().</p>
<p>Javascript无法很好处理二进制数据,所以Node特地增加了一个Buffer库来帮助服务器。</p>
<p>目前他只能和一个客户端通信，我们需要照顾到所有客户端。为此创建一个列表:</p>
<pre><code><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)

<span class="keyword">var</span> chatServer = net.createServer(),
    clientList = []

chatServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(client)</span> </span>{
    client.name = client.remoteAddress + <span class="string">':'</span> + client.remotePort
    client.write(<span class="string">'Hi '</span> + client.name + <span class="string">'!\n'</span>);
    clientList.push(client)
    client.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        broadcast(data, client)
    })
})

<span class="function"><span class="keyword">function</span> <span class="title">broadcast</span><span class="params">(message, client)</span></span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i+=<span class="number">1</span>){
        <span class="keyword">if</span>(client != clientList[i]){
            clientList[i].write(client.name + <span class="string">" says "</span> + message)
        }
    }
}

chatServer.listen(<span class="number">9000</span>)
</code></pre><p>在connection事件监听器上为每个client对象增加name属性。</p>
<p>但这个服务器有个致命缺陷：若一个客户端断开了，服务器会出大问题。<br>对已经关闭的socket进行write操作时，Node程序会抛出异常。</p>
<p>把聊天服务器改造得更加健壮:</p>
<pre><code>chatServer.on(<span class="string">'connection'</span>, function(<span class="keyword">client</span>){
    <span class="keyword">client</span>.name = <span class="keyword">client</span>.remoteAddress + <span class="string">':'</span> + <span class="keyword">client</span>.remotePort
    <span class="keyword">client</span>.write(<span class="string">'Hi '</span> + <span class="keyword">client</span>.name + <span class="string">'!\n'</span>);
    clientList.push(<span class="keyword">client</span>)
    <span class="keyword">client</span>.on(<span class="string">'data'</span>,function(data){
        broadcast(data, <span class="keyword">client</span>)
    })
    <span class="keyword">client</span>.on(<span class="string">'end'</span>,function(){
        clientList.splice(clientList.indexOf(<span class="keyword">client</span>),<span class="number">1</span>)
    })
})
</code></pre><p>一个socket锻炼连接时会触发end事件，表示它要关闭。</p>
<p>可以做得更加保险：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span><span class="params">(message, client)</span></span>{
    <span class="keyword">var</span> cleanup = []
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i+=<span class="number">1</span>){
        <span class="keyword">if</span>(client != clientList[i]){
            <span class="keyword">if</span>(clientList[i].writable){
                clientList[i].write(client.name + <span class="string">" says "</span> + message)
            }<span class="keyword">else</span>{
                cleanup.push(clientList[i])
                clientList[i].destroy()
            }
        }
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;cleanup.length;i+=<span class="number">1</span>){
        clientList.splice(clientList.indexOf(cleanup[i]),<span class="number">1</span>)
    }
}
</code></pre><h2 id="也编写个twitter">也编写个twitter</h2>
<ol>
<li>需要安装express模块，为现有的http服务器添加了更多的扩展，使开发Web应用更加简单： npm install express</li>
</ol>
<p>基本web服务器：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express.createServer()
app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(<span class="string">'Welcome to Node Twitter'</span>)
})

app.listen(<span class="number">8000</span>)
</code></pre><p>添加基础API:</p>
<pre><code><span class="keyword">var</span> express = require(<span class="string">'express'</span>)
<span class="keyword">var</span> app = express.createServer()
app.listen(<span class="number">8000</span>)

<span class="keyword">var</span> tweets = []
app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(<span class="string">'Welcome to Node Twitter'</span>)
})

app.post(<span class="string">'/send'</span>, express.bodyParser(), <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    <span class="keyword">if</span>(req.body &amp;&amp; req.body.tweet){
        tweets.push(req.body.tweet)
        res.send({status:<span class="string">"ok"</span>, message:<span class="string">"Tweet received"</span>})
    }<span class="keyword">else</span>{
        res.send({status:<span class="string">"nok"</span>, message:<span class="string">"no tweet recevied"</span>})
    }
})

app.<span class="keyword">get</span>(<span class="string">'/tweets'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{
    res.send(tweets)
})
</code></pre><h1 id="3-_编写健壮的Node程序">3. 编写健壮的Node程序</h1>
<h1 id="4-_核心API">4. 核心API</h1>
<h1 id="5-_工具类API">5. 工具类API</h1>
<h1 id="6-_数据访问">6. 数据访问</h1>
<h1 id="7-_重要的外部模块">7. 重要的外部模块</h1>
<h1 id="8-_扩展Node">8. 扩展Node</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/17/node即学即用/" data-id="xudy9fv1k37sr358" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hbase实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/08/hbase实战/" class="article-date">
  <time datetime="2015-02-08T12:59:57.000Z" itemprop="datePublished">2月 8 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/08/hbase实战/">hbase实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>源码: <a href="https://github.com/HBaseinaction" target="_blank" rel="external">https://github.com/HBaseinaction</a></p>
<h1 id="1-_HBase介绍">1. HBase介绍</h1>
<p>HBase是一种数据库。一种稀疏的，分布式的，持久化的，多维有序映射，基于行键(rowkey), 列键(column key)和时间戳(timestamp)建立索引。</p>
<p>HBase邮件列表：<a href="http://HBase.apache.org/mail-lists.html" target="_blank" rel="external">http://HBase.apache.org/mail-lists.html</a><br>JIRA网站： <a href="http://issues.apache.org/jira/browse/HBASE" target="_blank" rel="external">http://issues.apache.org/jira/browse/HBASE</a></p>
<h2 id="Hbase使用场景和成功案例">Hbase使用场景和成功案例</h2>
<h3 id="典型的互联网搜索问题">典型的互联网搜索问题</h3>
<h3 id="抓取增量数据">抓取增量数据</h3>
<ul>
<li>抓取监控指标：OpenTSDB</li>
<li>抓取用户交互数据: Facebook和StumbleUpon</li>
<li>遥测技术: Mozilla和Trend Micro</li>
<li>广告效果和点击流</li>
</ul>
<h3 id="内容服务">内容服务</h3>
<p>Twitter帖子, Facebook帖子，Instagram帖子和微博。</p>
<ul>
<li>Url短链接: StumbleUpon</li>
<li>用户模型服务: Runa用户模型服务</li>
</ul>
<h3 id="信息交换">信息交换</h3>
<p>Facebook的短信系统。 用户读写的所有短信都存在HBase列。 </p>
<p>Facebook短信系统要求: 高的写吞吐量，计数器吞吐量，自动分库</p>
<p>参考： </p>
<ul>
<li><a href="https://www.facebook.com/note.php?note_id=454991608919" target="_blank" rel="external">https://www.facebook.com/note.php?note_id=454991608919</a></li>
<li>“Hadoop goes realtime at Facebook” <a href="http://borthakur.com/ftp/RealtimeHadoopSigmod2011.pdf" target="_blank" rel="external">http://borthakur.com/ftp/RealtimeHadoopSigmod2011.pdf</a></li>
</ul>
<h2 id="你好HBase">你好HBase</h2>
<p>Hbase搭建在Apache Hadoop和Apache ZooKeeper上面，用java编写的。 可运行在3种模式：单机， 伪分布式和全分布式。</p>
<h3 id="快速安装">快速安装</h3>
<ol>
<li>下载。 <a href="http://hbase.apache.org/" target="_blank" rel="external">http://hbase.apache.org/</a></li>
<li>export HBASE_HOME=</li>
<li>$HBASE_HOME/bin/start-hbase.sh </li>
<li>默认写数据在/tmp下. 可写配置/etc/hbase/conf/hbase-site.xml</li>
<li>后台简易页面。  <a href="http://localhost:60010" target="_blank" rel="external">http://localhost:60010</a></li>
</ol>
<h3 id="命令行交互">命令行交互</h3>
<pre><code><span class="variable">$ </span>hbase shell                                                                                                                             <span class="number">13</span><span class="symbol">:</span><span class="number">24</span><span class="symbol">:</span><span class="number">45</span>
<span class="constant">HBase</span> <span class="constant">Shell</span>; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.
<span class="constant">Type</span> <span class="string">"exit&lt;RETURN&gt;"</span> to leave the <span class="constant">HBase</span> <span class="constant">Shell</span>
<span class="input"><span class="prompt">Version 0.98.10-hadoop2, rb18bc4b06f3eb90f592c906e78fb6461548ae627, Sun Feb  1 05:48:33 UTC 2015

hbase(main):001:0&gt;</span> list</span>
<span class="constant">TABLE</span>
<span class="number">2015</span>-<span class="number">02</span>-09 <span class="number">13</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">04</span>,<span class="number">209</span> <span class="constant">WARN</span>  [main] util.<span class="constant">NativeCodeLoader</span><span class="symbol">:</span> <span class="constant">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">5500</span> seconds
<span class="output"><span class="status">
=&gt;</span> []</span>
<span class="input"><span class="prompt">hbase(main):002:0&gt;</span> create <span class="string">'mytable'</span>, <span class="string">'cf'</span></span>
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">2180</span> seconds
<span class="output"><span class="status">
=&gt;</span> <span class="constant">Hbase::Table</span> - mytable</span>
<span class="input"><span class="prompt">hbase(main):003:0&gt;</span> list</span>
<span class="constant">TABLE</span>
mytable
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">00</span>8<span class="number">0</span> seconds
<span class="output"><span class="status">
=&gt;</span> [<span class="string">"mytable"</span>]</span>
<span class="input"><span class="prompt">hbase(main):004:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'first'</span>, <span class="string">'cf:message'</span>, <span class="string">'hello HBase'</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0770 seconds

hbase(main):005:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'second'</span>, <span class="string">'cf:foo'</span>, <span class="number">0x0</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0120 seconds

hbase(main):006:0&gt;</span> put <span class="string">'mytable'</span>, <span class="string">'third'</span>, <span class="string">'cf:bar'</span>, <span class="number">3.14159</span></span>
<span class="input"><span class="prompt">0 row(s) in 0.0090 seconds

hbase(main):007:0&gt;</span> get <span class="string">'mytable'</span>, <span class="string">'first'</span></span>
<span class="constant">COLUMN</span>                                        <span class="constant">CELL</span>
<span class="symbol">cf:</span>message                                   timestamp=<span class="number">1423459575172</span>, value=hello <span class="constant">HBase</span>
<span class="input"><span class="prompt">1 row(s) in 0.0180 seconds

hbase(main):008:0&gt;</span> scan <span class="string">'mytable'</span></span>
<span class="constant">ROW</span>                                           <span class="constant">COLUMN</span>+<span class="constant">CELL</span>
first                                        column=<span class="symbol">cf:</span>message, timestamp=<span class="number">1423459575172</span>, value=hello <span class="constant">HBase</span>
second                                       column=<span class="symbol">cf:</span>foo, timestamp=<span class="number">1423459599179</span>, value=<span class="number">0</span>
third                                        column=<span class="symbol">cf:</span>bar, timestamp=<span class="number">1423459615603</span>, value=<span class="number">3.14159</span>
<span class="input"><span class="prompt">3 row(s) in 0.0160 seconds

hbase(main):009:0&gt;</span> quit    </span>
</code></pre><h1 id="2-_入门">2. 入门</h1>
<p>本章目标:</p>
<ul>
<li>学习HBase的逻辑数据模型(logical data model)</li>
<li>如何进行HBase模式(Schema)设计</li>
</ul>
<p>代码参考:  <a href="https://github.com/hbaseinaction/twitbase" target="_blank" rel="external">https://github.com/hbaseinaction/twitbase</a></p>
<h2 id="从头开始">从头开始</h2>
<p>TwitBase存储3种简单的核心数据元素: 用户(user), 推贴(twit)和关系(relationship).</p>
<h3 id="创建表">创建表</h3>
<pre><code><span class="input"><span class="prompt">hbase(main):002:0&gt;</span> create <span class="string">'users'</span>, <span class="string">'info'</span></span>
<span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">10.2700</span> seconds
<span class="output"><span class="status">
=&gt;</span> <span class="constant">Hbase::Table</span> - users</span>
<span class="input"><span class="prompt">hbase(main):003:0&gt;</span> list</span>
<span class="constant">TABLE</span>
mytable
users
<span class="number">2</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">0040</span> seconds
<span class="output"><span class="status">
=&gt;</span> [<span class="string">"mytable"</span>, <span class="string">"users"</span>]</span>
<span class="input"><span class="prompt">hbase(main):004:0&gt;</span> describe <span class="string">'users'</span></span>
<span class="constant">Table</span> users is <span class="constant">ENABLED</span>
users
<span class="constant">COLUMN</span> <span class="constant">FAMILIES</span> <span class="constant">DESCRIPTION</span>
{<span class="constant">NAME</span> =&gt; <span class="string">'info'</span>, <span class="constant">BLOOMFILTER</span> =&gt; <span class="string">'ROW'</span>, <span class="constant">VERSIONS</span> =&gt; <span class="string">'1'</span>, <span class="constant">IN_MEMORY</span> =&gt; <span class="string">'false'</span>, <span class="constant">KEEP_DELETED_CELLS</span> =&gt; <span class="string">'FALSE'</span>, <span class="constant">DATA_BLOCK_ENCODING</span> =&gt; <span class="string">'NONE'</span>, <span class="constant">TTL</span> =&gt; <span class="string">'FOREVER'</span>, <span class="constant">COMPRESSION</span> =&gt; <span class="string">'NONE
'</span>, <span class="constant">MIN_VERSIONS</span> =&gt; <span class="string">'0'</span>, <span class="constant">BLOCKCACHE</span> =&gt; <span class="string">'true'</span>, <span class="constant">BLOCKSIZE</span> =&gt; <span class="string">'65536'</span>, <span class="constant">REPLICATION_SCOPE</span> =&gt; <span class="string">'0'</span>}
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0</span>.<span class="number">0350</span> seconds
</code></pre><h3 id="建立连接">建立连接</h3>
<pre><code>Configuration myConf = HBaseConfiguration.create();
myConf.<span class="keyword">set</span>(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"serverip"</span>);
HTableInterface usersTable = <span class="keyword">new</span> HTable(myConf, <span class="string">"users"</span>);
</code></pre><h3 id="连接管理">连接管理</h3>
<p>创建一个表实例是个开销很大的操作， 需要占用一些网络资源。使用连接池更好一些，使用HTablePool比直接使用HTable更常见：</p>
<pre><code>HTablePool pool = new HTablePool();
HTableInterface usersTabel = pool.getTable(<span class="string">"users"</span>);
<span class="keyword">...</span> //work withe the table
usersTable.close();
</code></pre><p>当你完成工作表时，连接资源会返回到连接池里。</p>
<h2 id="数据操作">数据操作</h2>
<p>行键(rowkey): Hbase的行唯一标识符。<br>HBase Api有5个基本命令: Get, Put, Delete, Scan和Increment.</p>
<h3 id="Hbase写路径">Hbase写路径</h3>
<p>在Hbase中，无论是增加新行还是修改已有行，内部流程都是相同的。 Hbase接到命令后存入变化信息，或者写入失败抛出异常。</p>
<p>默认，执行写入时写到两个地方: 预写式日志（write-ahead log, WAL) 和MemStore. 以保证数据持久化。两个地方信息都写入并确认后，才认为写动作完成。</p>
<p>MemStore是内存里的写入缓冲区，HBase中数据在永久写入之前都在这里累积。当MemStore填满后，其中的数据会刷写到硬盘，生成一个HFile.</p>
<p>HFile是Hbase使用的底层存储格式。Hfile对应列族，一个列族可以有多个HFile，但一个HFile不能存多个列族的数据。<br>在集群的每个节点上， 每个列族有一个MemStore.</p>
<p>大型分布式系统中硬件故障很常见，HBase也不例外。若MemStore还没有刷写，服务器就崩溃了， 内存没有写入硬盘的数据就会丢失。<br>使用WAL恢复。</p>
<p>// 待补</p>
<h3 id="Hbase读路径">Hbase读路径</h3>
<p>想快速访问数据，通用的原则是数据保持有序并尽可能保存在内存里。</p>
<p>Hbase实现了这两个目标， 大多情况下读操作可以做到毫秒级。</p>
<p>BlockCache是优化HBase性能的一个重要部分。</p>
<p>首先检查MemStore, 然后检查BlockCache, 最后访问硬盘上的HFile.</p>
<h3 id="合并:_HBase的后台工作">合并: HBase的后台工作</h3>
<p>Delete命令并不立即删除内容，只是打上删除的标记。因为HFile是不能改变的，直到执行一次大合并(major compaction), 这时被删除记录占用的空间才会释放。</p>
<p>合并分为两种：大合并()和小合并().</p>
<p>小合并把多个小HFile合并生成一个大HFile. 因为读出一个完整的行可能引用很多文件，限制HFile的数量对于读性能很重要。</p>
<p>大合并将处理给定region的一个列族的所有HFile.</p>
<p>参考: “Visualizing HBase Flushes and Compactions” Bruno Dumon.</p>
<h3 id="有时间版本的数据">有时间版本的数据</h3>
<p>HBase默认只存储3个版本，可以基于列族设置。</p>
<h3 id="数据模型概括">数据模型概括</h3>
<p>逻辑实体如下：</p>
<ul>
<li>表</li>
<li>行</li>
<li>列族</li>
<li>列限定符</li>
<li>单元</li>
<li>时间版本</li>
</ul>
<h2 id="数据坐标">数据坐标</h2>
<p>HBase使用的坐标依次是: 行键，列族，列限定符，时间版本。 4个坐标</p>
<h2 id="数据模型">数据模型</h2>
<p>半结构化数据。</p>
<p>HBase的半结构化逻辑模型里数据构成是松耦合的，这一点有利于物理分散存储。<br>当然也导致HBase不能实施关系约束(constraint)并不支持多行事务(multirow transaction).</p>
<h1 id="3-_分布式的HBase,HDFS和MapReduce">3. 分布式的HBase,HDFS和MapReduce</h1>
<p>HBase在两方面依赖Hadoop.</p>
<ol>
<li>Hadoop MapReduce提供了分布式计算框架，支持高吞吐量数据访问。</li>
<li>HDFS作为HBase的存储层，支持可用性(availability)和可靠性(reliability).</li>
</ol>
<h2 id="一个MapReduce的例子">一个MapReduce的例子</h2>
<h2 id="MapReduce概览">MapReduce概览</h2>
<ul>
<li>拆解。 hadoop只能以行为单位拆解</li>
<li>map阶段处理</li>
<li>洗牌阶段(shuffle step)</li>
<li>排序阶段(sort step)</li>
<li>聚合工作·</li>
</ul>
<h3 id="MapReduce内部处理">MapReduce内部处理</h3>
<ul>
<li>JobTracker进程扮演着应用监管的角色，负责管理集群上运行的MapReduce应用。作业提交给JobTracker来执行，管理分配工作负载。</li>
<li>Map阶段和Reduce阶段定义的工作由另一个TaskTracker的进程来执行</li>
</ul>
<h2 id="分布式模式的HBase">分布式模式的HBase</h2>
<p>Hbse中的表由行和列组成的。</p>
<p>表会切分小一点儿的数据单位(Region), 然后分配到多台服务器上。</p>
<p>托管region的服务器叫做RegionServer.</p>
<p>RegionServer和HDFS DataNode典型情况下并列配置在同一物理硬件上。<br>RegionServer本质上是HDFS客户端，在上面存储和访问数据。 主(master)进程分配region给RegionServer.<br>每个RegionServer一般托管多个region.</p>
<h3 id="如何找到Region">如何找到Region</h3>
<p>HBase有两个特殊的表：-Root-和.META.</p>
<p>当客户端要访问某行时，先找到-ROOT-表，查找上面地方可以找到负责某行的region. </p>
<h2 id="HBase和MapReduce">HBase和MapReduce</h2>
<h2 id="信息汇总">信息汇总</h2>
<h2 id="大规模条件下的可用性和可靠性">大规模条件下的可用性和可靠性</h2>
<h1 id="4-_HBase表设计">4. HBase表设计</h1>
<h2 id="如何开始模式(schema)设计">如何开始模式(schema)设计</h2>
<p>考虑以下问题:</p>
<ul>
<li>表应该有多少个列族</li>
<li>列族使用什么数据</li>
<li>每个列族应该有多少列</li>
<li>列名是什么？</li>
<li>单元存放什么数据</li>
<li>每个单元存储多少个时间版本</li>
<li>行键的结构是什么？应该包含什么信息</li>
</ul>
<h3 id="问题建模">问题建模</h3>
<p>一个列族的所有列在硬盘上存放在一起，使用这种特性把不同访问模式的列放在不同列族中，以便隔离他们。</p>
<p>提前多做准备工作总是有好处的</p>
<h1 id="5-_使用协处理器扩展HBase">5. 使用协处理器扩展HBase</h1>
<h1 id="6-_其他HBase客户端选择">6. 其他HBase客户端选择</h1>
<h1 id="7-_通过实例学习HBase:_OpenTSDB">7. 通过实例学习HBase: OpenTSDB</h1>
<h1 id="8-_在HBase上查询地理信息系统">8. 在HBase上查询地理信息系统</h1>
<h1 id="9-_部署HBase">9. 部署HBase</h1>
<h1 id="10-_运维">10. 运维</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/08/hbase实战/" data-id="6x2xv8qg5o07bomx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hbase/">hbase</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hadoop权威指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/07/hadoop权威指南/" class="article-date">
  <time datetime="2015-02-07T12:20:54.000Z" itemprop="datePublished">2月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/07/hadoop权威指南/">hadoop权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_初始Hadoop">1. 初始Hadoop</h1>
<p>已经有了大量的数据， 问题是如何存储和分析这些数据。</p>
<h2 id="数据存储和分析">数据存储和分析</h2>
<p>容量快速增长的同时，磁盘的访问速度却未能与时俱进。</p>
<p>多个磁盘数据的并行读写， 需要解决以下问题：</p>
<ul>
<li>硬盘故障。 使用备份（例如RAID冗余磁盘阵列），另外Hadoop文件系统（HDFS).</li>
<li>大多数分析任务需要以某种方式结合大部分数据共同完成分析任务。 MapReduce提出了一个编程模型。</li>
</ul>
<p>Hadoop提供了一个可靠的共享存储和分析系统。</p>
<h2 id="与其它系统的比较">与其它系统的比较</h2>
<h3 id="关系数据库">关系数据库</h3>
<p>为何不使用数据库对大量磁盘上的大规模数据进行批量计算呢？为何需要MapReduce?</p>
<p>答案来自于磁盘的另一个趋势: 寻址时间的提高远远慢于传输速率的提高。</p>
<ul>
<li>如果数据的访问模式包含大量的磁盘寻址，那么读取大量数据集所花的时间势必会更长。（与流式读取比较， 流式读取主要取决于传输速率）</li>
<li>若数据库只更新一小部分记录（B树), 效率比MapReduce效率低得多，因为需要使用”排序/合并”来重建数据库。</li>
</ul>
<p>MapReduce比较适合以批处理的方式处理需要分析整个数据集的问题。而RDBMS适用于“点查询”和更新，数据集被索引后，数据库系统能够提供较低延迟的数据检索和快速的少量数据库更新。<br>另一个区别：它们操作的数据集的结构化程度。</p>
<h3 id="网格计算">网格计算</h3>
<h2 id="Hadoop发展简史">Hadoop发展简史</h2>
<p>Hadoop是Apache Lucence创始人Doug Cutting创建的， Lucence是一个广泛使用的文本搜索系统库。<br>Hadoop起源于Apache Nutch, 一个开源的网络搜索引擎，本身也是Lucence项目的一部分。</p>
<ul>
<li>Nutch始于2002年, 一个可以运行的网页爬取工具和搜索引擎很快“浮出水面”, 但这一架构可扩展度不够， 不能解决数十亿网页的搜索问题. </li>
<li>2003年发表的一篇论文提供了帮助， 文中描述了谷歌产品架构（谷歌分布式文件系统, GFS), 可以解决他们在网页爬取和索引过程中产生的超大文件的存储需求。<br>特别关键的是, GFS能够节省系统管理（如管理存储节点）所花的大量时间。</li>
<li>2004年，他们开始着手实现Nutch的分布式文件系统（NDFS).</li>
<li>2004年，谷歌发布论文介绍MapReduce系统</li>
<li>2005年初， Nutch开发人员在Nutch上实现了一个MapReduce系统</li>
<li>2006年2月，Nutch开发人员将NDFS和MapReduce从Nutch移出形成Lucence的一个子项目，称为Hadoop. 大约同时Doug Cutting加入雅虎。</li>
<li>2008年2月，Yahoo!宣布其搜索引擎使用的索引在一个拥有1万个内核的Hadoop集群上构建的。</li>
<li>2008年4月，Hadoop打破世界纪录，</li>
</ul>
<h2 id="Apache_Hadoop和Hadoop生态圈">Apache Hadoop和Hadoop生态圈</h2>
<p>Hadoop项目：</p>
<ul>
<li>Common: 一组分布式文件系统和通用I/O的组件和接口（序列化，Java RPC和持久化数据结构）</li>
<li>Avro: 一种支持高效，跨语言的RPC以及永久存储数据结构的序列化系统。</li>
<li>MapReduce: 分布式数据模型和执行环境，运行于大型商用机集群。</li>
<li>HDFS: 分布式文件系统</li>
<li>Pig: 一种数据流语言和运行环境，用于检索非常大的数据集，Pig运行在MapReduce和HDFS的集群上</li>
<li>Hive: 一种分布式，按列存储的数据仓库。 Hive管理HDFS中存储的数据，并提供基于SQL的查询语言用以查询数据。</li>
<li>HBase: 一种分布式，按列存储的数据库。使用HDFS作为底层存储，同事支持MapReduce的批量式计算和点查询。</li>
<li>Zookeeper: 一个分布式，高可用的协调服务。</li>
<li>Sqoop: 在数据库和HDFS之间高效传输数据的工具.</li>
</ul>
<h1 id="2-_关于MapReduce">2. 关于MapReduce</h1>
<p>MapReduce是一个可用于数据处理的编程模型。</p>
<h2 id="一个气象数据集">一个气象数据集</h2>
<h2 id="使用Unix工具进行数据分析">使用Unix工具进行数据分析</h2>
<h2 id="使用Hadoop分析数据">使用Hadoop分析数据</h2>
<h3 id="map阶段和reduce阶段">map阶段和reduce阶段</h3>
<h3 id="Java_MapReduce">Java MapReduce</h3>
<p>需要三样东西:</p>
<ul>
<li>map函数</li>
<li>reduce函数</li>
<li>用了运行作业的代码</li>
</ul>
<p>Mapper:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTemperatureMapper</span> <span class="keyword">extends</span> <span class="title">MapReduceBase</span> 
    <span class="keyword">implements</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> inst MISSING = <span class="number">9999</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output,
        Reporter reporter) <span class="keyword">throws</span> IOException {

        String line = value.toString();
        String year = line.substring(<span class="number">15</span>,<span class="number">19</span>);
        <span class="keyword">int</span> airTemperature;

        <span class="keyword">if</span>(line.charAt(<span class="number">87</span>) == <span class="string">'+'</span>){
            airTemperature = Integer.parseInt(line.substring(<span class="number">88</span>,<span class="number">92</span>);
        }<span class="keyword">else</span>{
            airTemperature = Integer.parseInt(line.substring(<span class="number">87</span>,<span class="number">92</span>);
        }
        String quality = liine.substring(<span class="number">92</span>,<span class="number">93</span>);
        <span class="keyword">if</span>(airTemperature != MISSING &amp;&amp; quality.matches(<span class="string">"[01459]"</span>)){
            output.collect(<span class="keyword">new</span> Text(year), <span class="keyword">new</span> IntWritable(airTemperature));
        }
    }
}
</code></pre><p>Reducer:</p>
<p>public class MaxTemperatureReducer extends MapReduceBase<br>    implements Reducer<text, intwritable=""> output, Reporter reporter)</text,></p>
<h2 id="横向扩展">横向扩展</h2>
<h2 id="Hadoop的Steaming">Hadoop的Steaming</h2>
<h2 id="Hadoop的Pipes">Hadoop的Pipes</h2>
<h1 id="3-_Hadoop分布式文件系统">3. Hadoop分布式文件系统</h1>
<h1 id="4-_Hadoop_I/O">4. Hadoop I/O</h1>
<h1 id="5-_MapReduce应用开发">5. MapReduce应用开发</h1>
<h1 id="6-_MapReduce的工作机制">6. MapReduce的工作机制</h1>
<h1 id="7-_MapReduce的类型与格式">7. MapReduce的类型与格式</h1>
<h1 id="8-_MapReduce的特性">8. MapReduce的特性</h1>
<h1 id="9-_构建Hadoop集群">9. 构建Hadoop集群</h1>
<h1 id="10-_管理Hadoop">10. 管理Hadoop</h1>
<h1 id="11-_Pig简介">11. Pig简介</h1>
<h1 id="12-_Hive简介">12. Hive简介</h1>
<h1 id="13-_HBase">13. HBase</h1>
<h1 id="14-_Zookeeper">14. Zookeeper</h1>
<h1 id="15-_开源Sqoop">15. 开源Sqoop</h1>
<h1 id="16-_实例分析">16. 实例分析</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/07/hadoop权威指南/" data-id="1b7yam8klxq1x4yi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ice协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/19/Ice协议/" class="article-date">
  <time datetime="2015-01-19T00:32:01.000Z" itemprop="datePublished">1月 19 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/Ice协议/">Ice协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据编码（Data_Encoding)">数据编码（Data Encoding)</h1>
<h1 id="协议消息（Protocol_Messages)">协议消息（Protocol Messages)</h1>
<h1 id="协议压缩（Protocol_Compressing)">协议压缩（Protocol Compressing)</h1>
<h1 id="协议和编码版本">协议和编码版本</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/01/19/Ice协议/" data-id="yawn65lgew7cjccf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ice/">Ice</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring3-0就这么简单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/02/Spring3-0就这么简单/" class="article-date">
  <time datetime="2014-12-02T03:08:56.000Z" itemprop="datePublished">12月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/02/Spring3-0就这么简单/">Spring3.0就这么简单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_快速入门">1. 快速入门</h1>
<p>spring是分层的Java SE/EE应用一站式的轻量级开源框架，以<strong> 反转控制(IOC) </strong>和 <strong> 面向切片(AOP) </strong> 为内核,<br>提供了展现层Spring MVC, 持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</p>
<p>好的设计优于具体实现，代码应易于测试。</p>
<p>Spring好处：</p>
<ul>
<li>方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀的框架</li>
<li>降低Java EE API的使用难度。</li>
<li>java源码是经典的学习范例。</li>
</ul>
<h3 id="Spring体系结构">Spring体系结构</h3>
<p>5个主要模块:</p>
<ol>
<li>IOC</li>
<li>AOP</li>
<li>数据访问和集成</li>
<li>web及远程操作</li>
<li>web及远程访问(Spring MVC)</li>
</ol>
<h1 id="2-_Spring_IoC容器">2. Spring IoC容器</h1>
<p>Ioc: 通过容器来控制业务对象之间的依赖关系，而非传统实现中， 由代码直接操控。</p>
<p>控制反转：控制权由应用代码中转到了外部容器。</p>
<p>优点：降低了业务对象之间的依赖程度。</p>
<p>BeanFactory是Spring框架最核心的接口，提供了高级Ioc的配置机制。<br>ApplicationContext建立在BeanFactory基础之上， 提供了更多面向应用的功能。(应用上下文）</p>
<h3 id="BeanFactory">BeanFactory</h3>
<p>spring 配置文件:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"UTF-8"</span> ?&gt;</div><div class="line">&lt;beans <span class="variable">xmlns=</span><span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    xmlns:<span class="variable">xsi=</span><span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    xmlns:<span class="variable">p=</span><span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    xsi:<span class="variable">schemaLocation=</span><span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"car"</span> <span class="variable">class=</span><span class="string">"com.smart.Car"</span></div><div class="line">         p:<span class="variable">brand=</span><span class="string">"红旗CA72"</span></div><div class="line">         p:<span class="variable">maxSpeed=</span><span class="string">"200"</span>/&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"myBeanPostProcessor"</span> <span class="variable">class=</span><span class="string">"com.smart.context.MyBeanPostProcessor"</span>/&gt;</div><div class="line">   &lt;bean <span class="variable">id=</span><span class="string">"myBeanFactoryPostProcessor"</span> <span class="variable">class=</span><span class="string">"com.smart.context.MyBeanFactoryPostProcessor"</span>/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>

<p>使用BeanFactory:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> BeanFactoryTest {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) throws Throwable{</div><div class="line">       ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">       Resource res = resolver.getResource(<span class="string">"classpath:com/smart/beanfactory/beans.xml"</span>);</div><div class="line">       System.<span class="keyword">out</span>.println(res.getURL());</div><div class="line">       BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(res);</div><div class="line">       System.<span class="keyword">out</span>.println(<span class="string">"init BeanFactory."</span>);</div><div class="line"></div><div class="line">       Car car = bf.getBean(<span class="string">"car"</span>,Car.class);</div><div class="line">       System.<span class="keyword">out</span>.println(<span class="string">"car bean is ready for use!"</span>);</div><div class="line">       car.introduce();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="ApplicationContext">ApplicationContext</h3>
<p>相对BeanFactory, ApplicationContext初始化比较简单:</p>
<pre><code>ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/context/beans.xml"</span>);
</code></pre><p>还可以指定一组配置文件:</p>
<pre><code>ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"conf/beans1.xml"</span>,<span class="string">"conf/beans2.xml"</span>});
</code></pre><p>BeanFactory在初始化容器时，并未初始化Bean, 直到第一次访问某个Bean才实例化Bean.<br>而ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean.</p>
<h3 id="WebApplicationContext">WebApplicationContext</h3>
<p>WebApplicationContext是专门为Web应用准备的，允许从Web根目录的路径中装载配置文件，完成初始化工作。</p>
<p>它需要ServletContext实例。 在web.xml中配置自启动的Servlet或Web容器监听器(ServletContextListener), 借助它们任何一个<br>完成Spring WEb应用上下文的工作。</p>
<p>配置监听器引导：</p>
<pre><code><span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:spring-config.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>
        org.springframework.web.context.ContextLoaderListener
    <span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
</code></pre><p>配置自启动的Servlet引导：</p>
<h3 id="集合类型属性">集合类型属性</h3>
<pre><code><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"boss1"</span> <span class="attribute">class</span>=<span class="value">"com.smart.attr.Boss"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"car"</span> <span class="attribute">ref</span>=<span class="value">"car"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"favorites"</span>&gt;</span>
        <span class="comment">&lt;!-- list&gt;
            &lt;value&gt;看报&lt;/value&gt;
            &lt;value&gt;赛车&lt;/value&gt;
            &lt;value&gt;高尔夫&lt;/value&gt;
            &lt;/list --&gt;</span>
        <span class="tag">&lt;<span class="title">set</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobs"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">map</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span> &gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>AM<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>会见客户<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span>&gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>PM<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>公司内部会议<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">map</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mails"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">props</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"jobMail"</span>&gt;</span>john-office@baobaotao.com<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"lifeMail"</span>&gt;</span>john-life@baobaotao.com<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobTime"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">map</span>&gt;</span>
            <span class="tag">&lt;<span class="title">entry</span>&gt;</span>
                <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="tag">&lt;<span class="title">value</span>&gt;</span>会见客户<span class="tag">&lt;/<span class="title">value</span>&gt;</span> <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>124<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">map</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</code></pre><p>对应Boss类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Boss {
    <span class="keyword">private</span> String name ;
    <span class="keyword">private</span> <span class="keyword">int</span> age;
    <span class="keyword">private</span> Car car = <span class="keyword">new</span> Car();
    <span class="keyword">private</span> Map jobs = <span class="keyword">new</span> HashMap();
    <span class="keyword">private</span> Properties mails = <span class="keyword">new</span> Properties();
    <span class="keyword">private</span> Map&lt;String,Integer&gt; jobTime = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>() {
        <span class="keyword">return</span> age;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
    }
    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getJobTime</span>() {
        <span class="keyword">return</span> jobTime;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobTime</span>(Map&lt;String, Integer&gt; jobTime) {
        <span class="keyword">this</span>.jobTime = jobTime;
    }
    <span class="keyword">public</span> Properties <span class="title">getMails</span>() {
        <span class="keyword">return</span> mails;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMails</span>(Properties mails) {
        <span class="keyword">this</span>.mails = mails;
    }
    <span class="keyword">public</span> Map <span class="title">getJobs</span>() {
        <span class="keyword">return</span> jobs;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobs</span>(Map jobs) {
        <span class="keyword">this</span>.jobs = jobs;
    }
<span class="comment">//  private List favorites = new ArrayList();</span>
<span class="comment">//</span>
<span class="comment">//  public List getFavorites() {</span>
<span class="comment">//      return favorites;</span>
<span class="comment">//  }</span>
<span class="comment">//  public void setFavorites(List favorites) {</span>
<span class="comment">//      this.favorites = favorites;</span>
<span class="comment">//  }</span>
    <span class="keyword">private</span> Set favorites = <span class="keyword">new</span> HashSet();
    <span class="keyword">public</span> Car <span class="title">getCar</span>() {
        <span class="keyword">return</span> car;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span>(Car car) {
        <span class="keyword">this</span>.car = car;
    }
    <span class="keyword">public</span> String <span class="title">toString</span>(){
        String temp =<span class="string">"car:"</span>+car+<span class="string">"\n"</span>;
        temp += <span class="string">"favorites.size:"</span>+favorites.size()+<span class="string">"\n"</span>;
        temp += <span class="string">"jobs.size:"</span>+jobs.size();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">public</span> Set <span class="title">getFavorites</span>() {
        <span class="keyword">return</span> favorites;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFavorites</span>(Set favorites) {
        <span class="keyword">this</span>.favorites = favorites;
    }
}
</code></pre><h3 id="配置集合类型的Bean">配置集合类型的Bean</h3>
<pre><code><span class="tag">&lt;<span class="title">util:list</span> <span class="attribute">id</span>=<span class="value">"favoriteList1"</span> <span class="attribute">list-class</span>=<span class="value">"java.util.LinkedList"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">util:list</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:set</span> <span class="attribute">id</span>=<span class="value">"favoriteSet1"</span>  &gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>看报<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>赛车<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>高尔夫<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">util:set</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:map</span> <span class="attribute">id</span>=<span class="value">"emails1"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"AM"</span> <span class="attribute">value</span>=<span class="value">"会见客户"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"PM"</span> <span class="attribute">value</span>=<span class="value">"公司内部会议"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">util:map</span>&gt;</span>

<span class="tag">&lt;<span class="title">util:properties</span> <span class="attribute">id</span>=<span class="value">"emailProps1"</span>
<span class="attribute">location</span>=<span class="value">"classpath:com/smart/fb/mails.properties"</span> /&gt;</span>
</code></pre><h3 id="自动装配">自动装配</h3>
<p><bean>元素提供自动装配的属性：autowire=”&lt;自动装配类型&gt;”</bean></p>
<p>4种自动装配类型：</p>
<ul>
<li>byName</li>
<li>byType</li>
<li>constructor</li>
<li>autodetect</li>
</ul>
<p><beans>元素标签中的default-autowire属性可以配置全局自动装配。</beans></p>
<h3 id="Bean作用域">Bean作用域</h3>
<ol>
<li>singleton</li>
<li>prototype</li>
<li>request</li>
<li>session</li>
<li>globalSession</li>
</ol>
<h3 id="基于注解的配置">基于注解的配置</h3>
<ul>
<li>@Component</li>
<li>@Repository: 用于对DAO实现类进行标注</li>
<li>@Service: 用于对Service实现类进行标注</li>
<li>@Controller: 用于对Controller实现类进行标注</li>
</ul>
<p>使用注解配置信息启动Spring容器：</p>
<pre><code>&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.yuqiao.hellomvc.dao"</span>/&gt;
&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.yuqiao.hellomvc.dao"</span> resorce-pattern=<span class="string">"anno/*.class"</span>/&gt;
</code></pre><p>默认情况下, resorce-pattern=”<em>*/</em>.class”</p>
<p>Spring通过@Autowired注解实现Bean的依赖注入。<br>若容器没有一个和标注变量类型匹配的Bean， Spring容器启动时讲抛出NoSuchBeanDefinitionException异常，<br>若希望不抛出该异常，那么就可以使用@Autowired(require=false)进行标注。</p>
<p>使用@Qualifier指定注入Bean名称。</p>
<h1 id="3-_Spring_AOP">3. Spring AOP</h1>
<h2 id="aop_概述">aop 概述</h2>
<p>aop应用场景受限, 一般只适用于那些具有横切逻辑的应用场景：性能监测，访问控制， 事务管理及日志记录。</p>
<h3 id="aop术语">aop术语</h3>
<ul>
<li>连接点(JoinPoint)</li>
<li>切点(PointCut)</li>
<li>增强(Advice)</li>
<li>目标对象(Target)</li>
<li>引介(introduce)</li>
<li>织入(Weaving)</li>
<li>代理(Proxy)</li>
<li>切面(Aspect) </li>
</ul>
<h2 id="创建增强类">创建增强类</h2>
<p>Spring支持5种类型的增强:</p>
<ul>
<li>前置增强(org.springframework.aop.BeforeAdvice)</li>
<li>后置增强(org.springframework.aop.AfterReturningAdvice)</li>
<li>环绕增强(org.springframework.intercept.MethodInterceptor)</li>
<li>异常抛出增强(org.springframework.aop.ThrowsAdvice)</li>
<li>引介增强(org.springframework.aop.INtroductionInterceptor)</li>
</ul>
<h2 id="创建切面">创建切面</h2>
<p>支持两种方法配置器:</p>
<ul>
<li>静态方法配置器</li>
<li>动态方法配置器</li>
</ul>
<h3 id="切点类型">切点类型</h3>
<ul>
<li>静态方法切点</li>
<li>动态方法切点</li>
<li>注解切点</li>
<li>表达式切点</li>
<li>流程切点</li>
<li>复合切点</li>
</ul>
<h3 id="切面类型">切面类型</h3>
<ul>
<li>Advisor(一般切面)</li>
<li>PointcutAdvisor(切点切面)</li>
<li>IntroductionAdvisor(引介切面)</li>
</ul>
<h3 id="静态普通方法名匹配切面">静态普通方法名匹配切面</h3>
<p>在Waiter#greetTo()织入增强，切面类实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Method method, Class&lt;?&gt; targetClass) {</div><div class="line">        <span class="keyword">return</span> <span class="string">"greetTo"</span>.equals(method.getName());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFilter() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span>(Class&lt;?&gt; clazz) {</div><div class="line">                <span class="keyword">return</span> Waiter.class.isAssignableFrom(clazz);</div><div class="line">            }</div><div class="line">        };</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>配置切面:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"greetingAdvisor"</span> class=<span class="string">"com.yuqiao.advice.GreetingAdvisor"</span></div><div class="line">        p:advice-<span class="keyword">ref</span>=<span class="string">"greetingBeforeAdvice"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"parent"</span> abstract=<span class="string">"true"</span></div><div class="line">        class=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span></div><div class="line">        p:interceptorNames=<span class="string">"greetingAdvisor"</span></div><div class="line">        p:proxyTargetClass=<span class="string">"true"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"waiter2"</span> parent=<span class="string">"parent"</span> p:target-<span class="keyword">ref</span>=<span class="string">"nativeWaiter"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"seller1"</span> parent=<span class="string">"parent"</span> p:target-<span class="keyword">ref</span>=<span class="string">"seller"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="静态正则表达式方法匹配切面">静态正则表达式方法匹配切面</h3>
<p>为seller定义切面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"regexAdvisor"</span> class=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span></div><div class="line">        p:advice-<span class="keyword">ref</span>=<span class="string">"greetingBeforeAdvice"</span>&gt;</div><div class="line">    &lt;property name=<span class="string">"patterns"</span>&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;value&gt;.*greet.*&lt;/value&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=<span class="string">"seller2"</span> class=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span></div><div class="line">        p:interceptorNames=<span class="string">"regexAdvisor"</span></div><div class="line">        p:target-<span class="keyword">ref</span>=<span class="string">"seller"</span></div><div class="line">        p:proxyTargetClass=<span class="string">"true"</span>/&gt;&lt;ap</div></pre></td></tr></table></figure>

<h2 id="自动创建代理">自动创建代理</h2>
<p>前面都是使用ProxyFactoryBean创建织入切面的代理， 每个bean都需要该配置， 比较麻烦。</p>
<p>spring提供了自动代理机制。 使用BeanPostProcessor， 根据一定规则自动在容器实例化Bean时为匹配的Bean生成代理实例. 分类：</p>
<ul>
<li>基于Bean配置名规则的自动代理创建器。实现类为BeanNameAutoProxyCreator.</li>
<li>基于Advisor陪陪机制。DefaultAdvisorAutoProxyCreator.</li>
<li>基于Bean中AspectJ注解标签的自动代理创建器。</li>
</ul>
<h3 id="BeanNameAutoProxyCreator">BeanNameAutoProxyCreator</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="variable">class=</span><span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span></div><div class="line">        p:<span class="variable">beanNames=</span><span class="string">"*er"</span></div><div class="line">        p:<span class="variable">interceptorNames=</span><span class="string">"greetingBeforeAdvice"</span></div><div class="line">        p:<span class="variable">optimize=</span><span class="string">"true"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="DefaultAdvisorAutoProxyCreator">DefaultAdvisorAutoProxyCreator</h3>
<pre><code>&lt;bean <span class="keyword">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>/&gt;
</code></pre><h2 id="基于@AspectJ配置切面">基于@AspectJ配置切面</h2>
<h3 id="@AspectJ语法基础">@AspectJ语法基础</h3>
<p>Spring支持9个@AspectJ切点表达函数</p>
<ul>
<li>execution()</li>
<li>@annotation()</li>
<li>args()</li>
<li>@args()</li>
<li>within()</li>
<li>target()</li>
<li>@within()</li>
</ul>
<h1 id="4-_使用Spring_JDBC访问数据库">4. 使用Spring JDBC访问数据库</h1>
<p>由于JDBC api过于底层，开发者不但要编写数据操作代码，还需要编写JDBC连接，处理异常，释放资源等的代码。</p>
<p>Spring JDBC通过模板和回调机制大大降低了JDBC的复杂度。</p>
<p>创建一张表:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DriverManagerDataSource <span class="keyword">ds</span> = <span class="keyword">new</span> DriverManagerDataSource();</div><div class="line"><span class="keyword">ds</span>.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line"><span class="keyword">ds</span>.setUrl(<span class="string">"jdbc:mysql://localhost:3306/sampledb"</span>);</div><div class="line"><span class="keyword">ds</span>.setUsername(<span class="string">"root"</span>);</div><div class="line"></div><div class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</div><div class="line">jdbcTemplate.setDataSource(<span class="keyword">ds</span>);</div><div class="line"></div><div class="line">String sql = <span class="string">"create table t_user(user_id int primary key, user_name varchar(60))"</span>;</div><div class="line">jdbcTemplate.<span class="keyword">execute</span>(sql);</div></pre></td></tr></table></figure>

<p>一般情况下，在DAO类中使用JdbcTemplate, 在XML配置文件中配置好JdbcTemplate,然后直接在DAO中注入即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.yuqiao.hellomvc.dao;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="annotation">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginLogDao</span> </span>{</div><div class="line">    <span class="annotation">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertLoginLog</span>(LoginLog loginLog) {</div><div class="line">        String sqlStr = <span class="string">"INSERT INTO t_login_log(user_id,ip,login_datetime) "</span></div><div class="line">                + <span class="string">"VALUES(?,?,?)"</span>;</div><div class="line">        Object[] args = {loginLog.getUserId(), loginLog.getIp(),</div><div class="line">                loginLog.getLoginDate()};</div><div class="line">        jdbcTemplate.update(sqlStr, args);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Spring配置文件定义jdbcTemplate:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></div><div class="line">      destroy-<span class="keyword">method</span>=<span class="string">"close"</span></div><div class="line">      p:driverClassName=<span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">      p:url=<span class="string">"jdbc:mysql://localhost:3306/sampledb31"</span></div><div class="line">      p:username=<span class="string">"root"</span></div><div class="line">      p:password=<span class="string">""</span>/&gt;</div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"jdbcTemplate"</span> class=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span></div><div class="line">      p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div></pre></td></tr></table></figure>

<p>配置一般分为4个步骤:</p>
<ol>
<li><p>定义DataSource.</p>
</li>
<li><p>定义JdbcTemplate. 可以控制JDBC api的属性.</p>
<ul>
<li>queryTimeout. 查询数据的最大超时时间。</li>
<li>fetchSize. ResultSet每次返回的行数.</li>
<li>maxRows:</li>
<li>ignoreWarnings:</li>
</ul>
</li>
<li><p>声明一个抽象的<bean>，以便所有DAO复用配置。</bean></p>
</li>
<li><p>配置具体的DAO.</p>
</li>
</ol>
<h2 id="基本的数据操作">基本的数据操作</h2>
<h3 id="返回数据库的表自增主键值">返回数据库的表自增主键值</h3>
<p>KeyHolder是一个回调接口，Spring用他保存新增记录对应的主键。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpace</span>(<span class="keyword">final</span> ViewSpace viewSpace){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"INSERT INTO t_view_space (space_name, description, address, user_id) VALUES(?,?,?,?)"</span>;</div><div class="line">    KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</div><div class="line">    jdbcTemplate.update(<span class="keyword">new</span> PreparedStatementCreator() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span>(Connection connection) <span class="keyword">throws</span> SQLException {</div><div class="line">            PreparedStatement ps = connection.prepareStatement(sql);</div><div class="line">            ps.setString(<span class="number">1</span>, viewSpace.getSpaceName());</div><div class="line">            ps.setString(<span class="number">2</span>, viewSpace.getDescription());</div><div class="line">            ps.setString(<span class="number">3</span>, viewSpace.getAddress());</div><div class="line">            ps.setInt(<span class="number">4</span>, viewSpace.getUser());</div><div class="line">            <span class="keyword">return</span> ps;</div><div class="line">        }</div><div class="line">    },keyHolder);</div><div class="line">    viewSpace.setSpaceId(keyHolder.getKey().intValue());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在jdbc3.0之前， PreparedStatement不能绑定主键。用户必须在插入数据库后马上执行另一条获取新增主键的查询语句。<br>mysql: SELECT LAST_INSERT_ID();</p>
<h3 id="批量更改数据">批量更改数据</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpaces</span>(<span class="keyword">final</span> List&lt;ViewSpace&gt; viewSpaceList){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"INSERT INTO t_view_space (space_name, description, address, user_id) VALUES(?,?,?,?)"</span>;</div><div class="line">    jdbcTemplate.batchUpdate(sql, <span class="keyword">new</span> BatchPreparedStatementSetter() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span>(PreparedStatement ps, <span class="keyword">int</span> i) <span class="keyword">throws</span> SQLException {</div><div class="line">            ViewSpace viewSpace = viewSpaceList.get(i);</div><div class="line">            ps.setString(<span class="number">1</span>, viewSpace.getSpaceName());</div><div class="line">            ps.setString(<span class="number">2</span>, viewSpace.getDescription());</div><div class="line">            ps.setString(<span class="number">3</span>, viewSpace.getAddress());</div><div class="line">            ps.setInt(<span class="number">4</span>, viewSpace.getUser());</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span>() {</div><div class="line">            <span class="keyword">return</span> viewSpaceList.size();</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="查询数据">查询数据</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ViewSpace <span class="title">getViewSpace</span>(<span class="keyword">final</span> <span class="keyword">int</span> id){</div><div class="line">    <span class="keyword">final</span> String sql = <span class="string">"SELECT space_name, description, address, user_id from t_view_space where space_id=?"</span>;</div><div class="line">    <span class="keyword">final</span> ViewSpace vs = <span class="keyword">new</span> ViewSpace();</div><div class="line">    jdbcTemplate.query(sql, <span class="keyword">new</span> Object[]{id}, <span class="keyword">new</span> RowCallbackHandler() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span>(ResultSet resultSet) <span class="keyword">throws</span> SQLException {</div><div class="line">            vs.setSpaceId(id);</div><div class="line">            vs.setSpaceName(resultSet.getString(<span class="string">"space_name"</span>));</div><div class="line">            vs.setDescription(resultSet.getString(<span class="string">"description"</span>));</div><div class="line">            vs.setAddress(resultSet.getString(<span class="string">"address"</span>));</div><div class="line">            vs.setUser(resultSet.getInt(<span class="string">"user_id"</span>));</div><div class="line">        }</div><div class="line">    });</div><div class="line">    <span class="keyword">return</span> vs;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>RowCallbackHandler 和RowMapper<t>比较。</t></p>
<p>单值查询接口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewSpaceNum</span>(){</div><div class="line">    String sql = <span class="string">"select COUNT(*) FROM  t_view_space"</span>;</div><div class="line">    <span class="keyword">return</span> jdbcTemplate.queryForInt(sql);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编写sql语句时，用大写方式编写SQL的关键字和函数， 用小写的形式编写表名，字段名等非语义的元素。</p>
<p>调用存储过程： execute</p>
<h2 id="BLOB/CLOB类型数据的操作">BLOB/CLOB类型数据的操作</h2>
<h1 id="5-_集成Hibernate">5. 集成Hibernate</h1>
<h1 id="6-_Spring的事务管理">6. Spring的事务管理</h1>
<h2 id="数据库事务基础知识">数据库事务基础知识</h2>
<p>一荣俱荣，一损俱损。体现事务的思想，很多复杂的事务要分步进行，但他们组成一个整体，要么整体生效，要么整体失效。</p>
<p>数据库事务需要满足4个特性（ACID):原子性(Atomic), 一致性(Consistency), 隔离性(Isolation)和持久性(Durability).</p>
<p>一致性是目标，其它都是达到这个目标的措施或者手段。</p>
<p>数据库系统一般采用重执行日志保证原子性，一致性和持久性。重执行日志记录了数据库变化的每一个动作，数据库在一个事务中执行一部分操作后发生错误退出，数据库即可根据重执行日志车险已经执行的操作。<br>数据库管理系统采用数据库锁机制保证事务的隔离性。</p>
<p>Connection#getMetaData()获取DatbaMataData对象，该对象的supportsTransactions(), supportsTransactionIsolationLevel(int level)查看底层数据库的事务支持情况。</p>
<h3 id="Jdbc对事务的处理">Jdbc对事务的处理</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="type">Connection</span> conn;</div><div class="line"><span class="keyword">try</span>{</div><div class="line">    conn = <span class="type">DriverManager</span>.getConnection();</div><div class="line">    conn.setAutoCommit(<span class="literal">false</span>);</div><div class="line">    conn.setTransactionIsolation(<span class="type">Connection</span>.<span class="type">TRANSACTION_SERIALIZABLE</span>);</div><div class="line">    <span class="type">Statement</span> <span class="type">stmt</span> = conn.createStatement();</div><div class="line">    <span class="type">int</span> rows = <span class="type">stmt</span>.executeUpdate(<span class="string">"INSERT INTO t_viewspace VALUES(1,'XXXX')"</span>);</div><div class="line">    rows = <span class="type">stmt</span>.executeUpdate(<span class="string">"UPDATE t_viewpoint set ticket = ticket +10"</span>);</div><div class="line">    conn.commit();</div><div class="line">}catch (<span class="type">Exception</span> e){</div><div class="line">    conn.rollback();</div><div class="line">}<span class="keyword">finally</span> {</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Spring对事务管理的处理">Spring对事务管理的处理</h2>
<p>Spring为事务管理提供了一致的编程模板, 在高层次建立了同意的事务抽象。提供了TransactionTemplate。</p>
<p>Spring事务管理的亮点在于声明式事务管理。</p>
<h3 id="事务管理关键抽象">事务管理关键抽象</h3>
<p>Spring事务管理SPI(Service Provider Interface)的抽象层主要包括三个接口：</p>
<ul>
<li><p>PlatformTransactionManager: 根据TransactionDefinition提供的事务属性配置信息，创建事务，并用TransationStatus描述这个激活事务的状态。定义了3方法:</p>
<ul>
<li>getTransaction(definition)</li>
<li>commit(stutus)</li>
<li>rollback(status)</li>
</ul>
</li>
<li><p>TransactionDefinition: 描述事务的隔离级别，超时时间，是否为只读事务和事务传播规则等控制事务具体行为的事务属性。</p>
</li>
<li>TransactionStatus: 代表一个事务的具体运行状态。</li>
</ul>
<h3 id="事务管理实现类">事务管理实现类</h3>
<p>Spring将事务管理委托给底层具体的持久化实现框架完成。</p>
<p>Spring JDBC和iBatis都是基于数据源的Connection访问数据库，所以可以使用DataSourceTransactionManager.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"dataSource"</span></div><div class="line">        class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></div><div class="line">        destroy-<span class="keyword">method</span>=<span class="string">"close"</span></div><div class="line">        p:driverClassName=<span class="string">"${jdbc.driverClassName}"</span></div><div class="line">        p:url=<span class="string">"${jdbc.url}"</span></div><div class="line">        p:username=<span class="string">"${jdbc.username}"</span></div><div class="line">        p:password=<span class="string">"${jdbc.password}"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"txManager"</span></div><div class="line">        class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></div><div class="line">        p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div></pre></td></tr></table></figure>

<h3 id="事务同步管理器">事务同步管理器</h3>
<p>Spring将JDBC的Connection,Hibernate的Session等访问数据库的连接或会话对象统称为资源。资源在同一时刻是不能多线程共享的。<br>为了让Dao,Service类可能做到singleton，Spring的事务同步管理类TransactionSynchronizationManager使用ThreadLocal管理为不同事务线程提供了<br>独立的资源副本。</p>
<p>Spring框架为不同的持久化技术提供了一套从TransactionSynchronizationManager中获取对应线程绑定资源的工具类。<br>DataSourceUtils.getConnection可以从指定的数据源中获取和当前线程绑定的Connection.</p>
<h3 id="事务传播行为">事务传播行为</h3>
<h2 id="编程式的事务管理">编程式的事务管理</h2>
<p>很少用。 Spring提供了TransactionTemplate.</p>
<h2 id="使用xml配置声明式事务">使用xml配置声明式事务</h2>
<p>Spring的声明式事务管理是通过Spring AOP实现的，通过事务的声明性信息，Spring负责将事务管理增强逻辑动态织入业务方法相应连接点中。<br>这些逻辑包括获取线程绑定资源，开始事务，提交/回滚事务，进行异常转换和处理工作。</p>
<h3 id="一个被实施事务增强的服务接口">一个被实施事务增强的服务接口</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IViewSpace {</div><div class="line">    <span class="keyword">void</span> addViewSpace(ViewSpace space);</div><div class="line">    <span class="keyword">void</span> updateViewSpace(ViewSpace space);</div><div class="line">    ViewSpace getViewSpace(<span class="keyword">int</span> spaceId);</div><div class="line">    <span class="keyword">int</span> getViewSpaceNum();</div><div class="line">    <span class="keyword">void</span> deleteViewSpace(<span class="keyword">int</span> spaceId);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们希望对addViewSpace和updateViewSpace拥有写事务的能力， 而另外两个拥有读事务的能力。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Transactional</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewSpaceImpl</span> <span class="keyword">implements</span> <span class="title">IViewSpace</span> </span>{</div><div class="line">    <span class="keyword">private</span> ViewSpaceDao viewSpaceDao;</div><div class="line">    <span class="keyword">private</span> ViewPointDao viewPointDao;</div><div class="line"></div><div class="line">    <span class="annotation">@Transactional</span>(readOnly=<span class="keyword">true</span>)</div><div class="line">    <span class="keyword">public</span> ViewSpace <span class="title">getViewSpace</span>(<span class="keyword">int</span> spaceId) {</div><div class="line">        <span class="keyword">return</span> viewSpaceDao.getViewSpace( spaceId);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewSpace</span>(ViewSpace viewSpace) {</div><div class="line">        viewSpaceDao.updateViewSpace(viewSpace);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewSpaceNum</span>() {</div><div class="line">        <span class="keyword">return</span> viewSpaceDao.getViewSpaceNum();</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewSpaceDao</span>(ViewSpaceDao viewSpaceDao) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao = viewSpaceDao;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPointDao</span>(ViewPointDao viewPointDao) {</div><div class="line">        <span class="keyword">this</span>.viewPointDao = viewPointDao;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewSpace</span>(ViewSpace space) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao.addViewSpace(space);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteViewSpace</span>(<span class="keyword">int</span> spaceId) {</div><div class="line">        <span class="keyword">this</span>.viewSpaceDao.deleteViewSpace(spaceId);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>ViewSpaceImpl是一个POJO, 只是简单使用持久层的多个DAO类。</p>
<h3 id="使用原始的TransactionProxyFactoryBean">使用原始的TransactionProxyFactoryBean</h3>
<p>了解TransactionProxyFactoryBean有助于跟直观</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--1. 引入dao和DataSource的配置文件--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"classpath:applicationContext-dao.xml"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--2. 声明事务管理器--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"txManager"</span></span></div><div class="line">    <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--3. 需要实施事务增强的目标业务bean--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"viewSpaceTarget"</span></span></div><div class="line">        <span class="attribute">class</span>=<span class="value">"com.smart.service.impl.ViewSpaceImpl"</span></div><div class="line">        <span class="attribute">p:viewSpaceDao-ref</span>=<span class="value">"viewSpaceDao"</span></div><div class="line">        <span class="attribute">p:viewPointDao-ref</span>=<span class="value">"viewPointDao"</span>/&gt;</div><div class="line"><span class="comment">&lt;!--4. 使用事务代理工程类为目标业务Bean提供事务增强--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"viewSpaceService"</span></span></div><div class="line">    <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span></div><div class="line">    <span class="attribute">p:transactionManager-ref</span>=<span class="value">"txManager"</span></div><div class="line">    <span class="attribute">p:target-ref</span>=<span class="value">"viewSpaceTarget"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"get*"</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>异常回滚/提交规则</p>
<p><prop>内的值为事务属性配置信息， 格式如下：</prop></p>
<pre><code>PROPAGATION_REQUIRED, ISOLATION, readOnly, -<span class="keyword">Exception</span>, +<span class="keyword">Exception</span>
</code></pre><h3 id="基于tx/aop命名空间的配置">基于tx/aop命名空间的配置</h3>
<p>Spring基于Schema的配置中,添加了一个tx命名空间， 在配置文件中医明确结构化的方式定义事务属性，<br>大大提高配置事务属性的便利性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">import</span> resource=<span class="string">"classpath:applicationContext-dao.xml"</span> /&gt;</div><div class="line">&lt;!--①不再需要为了事务<span class="type">AOP</span>增强的实施而改名换姓--&gt;</div><div class="line">&lt;bean id=<span class="string">"viewSpaceService"</span></div><div class="line">    class=<span class="string">"com.smart.service.impl.ViewSpaceImpl"</span></div><div class="line">    p:viewSpaceDao-<span class="keyword">ref</span>=<span class="string">"viewSpaceDao"</span></div><div class="line">    p:viewPointDao-<span class="keyword">ref</span>=<span class="string">"viewPointDao"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--<span class="number">2</span>. 事务管理器--&gt;</div><div class="line">&lt;bean id=<span class="string">"txManager"</span></div><div class="line">    class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></div><div class="line">    p:dataSource-<span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</div><div class="line"></div><div class="line">&lt;aop:config&gt;</div><div class="line">    &lt;!--③-<span class="number">1</span>通过aop定义事务增强切面--&gt;</div><div class="line">    &lt;aop:pointcut id=<span class="string">"serviceMethod"</span></div><div class="line">                    expression=<span class="string">"execution(* com.smart.service.*Service.*(..))"</span> /&gt;</div><div class="line">    &lt;!--③-<span class="number">2</span>引用事务增强--&gt;</div><div class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>=<span class="string">"serviceMethod"</span> advice-<span class="keyword">ref</span>=<span class="string">"txAdvice"</span> /&gt;</div><div class="line">&lt;/aop:config&gt;</div><div class="line"></div><div class="line">&lt;!--④事务增强--&gt;</div><div class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"txManager"</span>&gt;</div><div class="line">    &lt;!--④-<span class="number">1</span>事务属性定义--&gt;</div><div class="line">    &lt;tx:attributes&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"get*"</span> read-only=<span class="string">"false"</span>/&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"add*"</span> rollback-<span class="keyword">for</span>=<span class="string">"Exception"</span> /&gt;</div><div class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"update*"</span>/&gt;</div><div class="line">    &lt;/tx:attributes&gt;</div><div class="line">&lt;/tx:advice&gt;</div></pre></td></tr></table></figure>

<p><tx:method> 元素：</tx:method></p>
<ul>
<li>name</li>
<li>progagation</li>
<li>isolation</li>
<li>timeout</li>
<li>read-only</li>
<li>rollback-for</li>
<li>no-rollback-for</li>
</ul>
<h2 id="使用注解配置声明式事务">使用注解配置声明式事务</h2>
<h1 id="7-_Spring_MVC">7. Spring MVC</h1>
<h2 id="概述">概述</h2>
<p>围绕DispatcherServlet核心展开，DispatcherServlet是Spring MVC的总导演，总策划，它负责截获请求并将其分派给相应的处理器处理。</p>
<p>Spring MVC 包括:</p>
<ul>
<li>注解控制器</li>
<li>请求及响应的相信处理</li>
<li>视图解析</li>
<li>本地化解析</li>
<li>删除文件解析</li>
<li>异常处理</li>
<li>表单标签绑定</li>
</ul>
<h3 id="体系结构">体系结构</h3>
<ol>
<li>client发起一个HTTP请求, 若匹配到DispatcherServlet的请求映射路径(web.xml中指定). web容器将该请求转交给DispatcherServlet处理。</li>
<li>DispatcherServlet收到该请求后，将根据请求的信息(Url, http方法, 请求报文头, 请求参数, Cookie等)及HandlerMapping的配置找到处理请求的处理器（Handler).</li>
<li>通过HandlerAdapter对Handler进行封装， 再以统一的适配器接口调用Handler.</li>
<li>Handler完成业务逻辑的处理后将返回一个ModelAndView给DispatcherServlet, ModelAndView包括了视图逻辑名和模型数据信息.</li>
<li>ModelAndView中包含的“逻辑视图名”而非真正的视图对象, DispatcherServlet借由ViewResolver完成逻辑视图到真实视图对象的解析工作。</li>
<li>当得到真实的视图对象view后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。</li>
<li>最终client获取得到的响应消息可能是一个普通的html页面， 也可能是一个xml或json串，甚至是一张图片或一个pdf文档等不同的媒体形式。</li>
</ol>
<h3 id="配置DispatcherServlet">配置DispatcherServlet</h3>
<ol>
<li>如何截获特定的http请求，交由spring MVC框架处理？</li>
</ol>
<p>配置DispatcherServlet,截获特定的URL请求</p>
<p>在web.xml配置一个Servlet, 并通过<servlet-mapping>指定器处理的url.</servlet-mapping></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--1. 业务层和持久层的配置文件，被父Spring容器使用--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:/conf/applicationContext.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--2. 声明DispatcherServlet. 默认自动加载/WEB-INF/viewspace-servlet.xml--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>viewspace<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--3. 为Dispatcher匹配的URL模式. 指定DispatcherServlet处理所有URL以.html为后缀的HTTP请求--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>viewspace<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>

<p>DispatcherServlet遵循“契约优于配置”的原则，在大多数情况下， 无须精心额外的配置。</p>
<p><servlet>的<init-param>参数:</init-param></servlet></p>
<ul>
<li>namespace</li>
<li>contextConfigLocation</li>
<li>publishContent</li>
<li>publishEvents</li>
</ul>
<h2 id="注解驱动的控制器">注解驱动的控制器</h2>
<h1 id="8-_单元测试">8. 单元测试</h1>
<h2 id="概述-1">概述</h2>
<h3 id="基本概念">基本概念</h3>
<p>被测系统(System Under Test):</p>
<p>测试替身(Test Double): 使用测试替身，也可称为Mock, 减少被测对象的依赖。</p>
<p>测试夹具(Test Fixture): 在测试方法之前自动进行初始化，和资源回收的工作。 @BeforeMethod, @AfterMethod, @Test, @BeforeClass, @AfterClass</p>
<p>测试用例(Test Case)</p>
<p>测试套件(TEst Suite)</p>
<h2 id="TestNG快速进阶">TestNG快速进阶</h2>
<h3 id="异常测试">异常测试</h3>
<p>使用expetedExceptions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> AutoNameAdviceTest {</div><div class="line">    <span class="keyword">private</span> User user;</div><div class="line">    @Test(enabled = <span class="keyword">true</span>, expectedExceptions = NullPointerException.class)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUser</span>(){</div><div class="line">        user= <span class="keyword">new</span> User();</div><div class="line">        assertNotNull(user.getLastIp());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="超时测试">超时测试</h3>
<p>若在指定时间完成， 就通过测试.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Test</span>(timeOut = <span class="number">10</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeout</span>(){</div><div class="line">    user= <span class="keyword">new</span> User();</div><div class="line">    assertNotNull(user);</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        Thread.sleep(<span class="number">11</span>);</div><div class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">        e.printStackTrace();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="参数化测试">参数化测试</h3>
<h1 id="9-_敏捷开发技术">9. 敏捷开发技术</h1>
<h1 id="10-_自己动手打造服务平台框架">10. 自己动手打造服务平台框架</h1>
<h1 id="11-_实战案例开发">11. 实战案例开发</h1>
<pre><code>      p:<span class="variable">proxyTargetClass=</span><span class="string">"true"</span>/&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2014/12/02/Spring3-0就这么简单/" data-id="vnksoj35p9u4whw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Programming-Erlang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/21/Programming-Erlang/" class="article-date">
  <time datetime="2014-11-21T00:09:31.000Z" itemprop="datePublished">11月 21 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/21/Programming-Erlang/">Programming Erlang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言">前言</h1>
<p>Erlang是函数式编程语言，在Erlang里，改变进程的状态是允许的，但一个进程改变另一个进程的状态则不行。<br>Erlang里没有互斥，没有同步方法，也没有内存共享式编程的各种设备。</p>
<p>每个进程能且只能用一种方法交互，就是<strong>交换消息</strong> . </p>
<p>编写Erlang程序时，实现的方式不是让单个进程执行所有任务， 而是生成大量只做简单事情的小进程，并让他们通信。</p>
<p>本书介绍并发性，分布，容错和函数式编程，阐述如何编写一个没有锁和互斥，只是纯粹使用消息传到的分布式并发系统，<br>如何在多核CPU上自动加速程序， 如何编写让人们互相交流的分布式应用程序。<br>还介绍了如何编写容错和分布式系统的设计模式，如何给并发性建模,再把这些模型映射到计算机程序上。</p>
<h1 id="1-_什么是并发">1. 什么是并发</h1>
<h2 id="给并发建模">给并发建模</h2>
<p>编程模型基于对现实世界的观察。</p>
<h2 id="并发的益处">并发的益处</h2>
<ol>
<li>性能分析</li>
<li>可扩展性</li>
<li>容错性</li>
<li>清晰性</li>
</ol>
<h1 id="2-_Erlang速览">2. Erlang速览</h1>
<h2 id="进程，m模块和编译">进程，m模块和编译</h2>
<p>例子(hello.erl)：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="pp"><span class="keyword">-module</span><span class="params">(hello)</span></span>.</div><div class="line"><span class="pp"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>])</span></span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="function_name">io:format</span>(<span class="string">"Hello world~n"</span>).</div></pre></td></tr></table></figure>

<p>shell运行：</p>
<pre><code><span class="prompt">1&gt; </span><span class="function_or_atom">c</span>(<span class="function_or_atom">hello</span>).
{<span class="ok">ok</span>,<span class="function_or_atom">hello</span>}
<span class="prompt">2&gt; </span><span class="function_or_atom">hello:start</span>().
<span class="variable">Hello</span> <span class="function_or_atom">world</span>
<span class="ok">ok</span>
<span class="prompt">3&gt; </span>
</code></pre><p>c(hello)命令编译hello.erl文件里的代码。</p>
<p>编译:</p>
<pre><code>$ erlc hello.erl                                                                                                  
$ erl -noshell <span class="operator">-s</span> hello start <span class="operator">-s</span> init stop                                                                       
Hello world
</code></pre><p>$erl … 命令加载hello模块并执行hello:start()函数， 随后执行了init:stop(), 这个表达式终止了Erlang会话。</p>
<p>Erlang的基本并发单元：进程。<br>一个进程是一个轻量级的虚拟机，只能通过发送和接收消息来与其他进程通信。</p>
<h2 id="你好，并发">你好，并发</h2>
<h3 id="文件服务器进程">文件服务器进程</h3>
<p>文件服务器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-<span class="built_in">module</span>(afile_server).</div><div class="line">-<span class="reserved">export</span>([start/<span class="number">1</span>,<span class="keyword">loop</span>/<span class="number">1</span>]).</div><div class="line"></div><div class="line">start<span class="function"><span class="params">(Dir)</span> -&gt;</span> spawn(afile_server, <span class="keyword">loop</span>, [Dir]).</div><div class="line"></div><div class="line"><span class="keyword">loop</span><span class="function"><span class="params">(Dir)</span> -&gt;</span></div><div class="line">    receive</div><div class="line">        {Client, list_dir}<span class="function"> -&gt;</span></div><div class="line">            Client ! {self(), <span class="attribute">file</span>:list_dir(Dir)};</div><div class="line">        {Client, {get_file, File} }<span class="function"> -&gt;</span></div><div class="line">            Full = <span class="attribute">filename</span>:join(Dir, File),</div><div class="line">            Client ! {self(), <span class="attribute">file</span>:read_file(Full)}</div><div class="line">    end,</div><div class="line">    <span class="keyword">loop</span>(Dir).</div></pre></td></tr></table></figure>

<p>模式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">loop(Dir) -&gt;</div><div class="line">    %% 等待指令</div><div class="line">    receive</div><div class="line">        Command -&gt;</div><div class="line">            <span class="keyword">...</span> 做点什么 <span class="keyword">...</span></div><div class="line">    end,</div><div class="line">    loop(Dir).</div></pre></td></tr></table></figure>

<p>shell测试：</p>
<pre><code><span class="prompt">1&gt; </span><span class="function_or_atom">c</span>(<span class="function_or_atom">afile_server</span>).
{<span class="ok">ok</span>,<span class="function_or_atom">afile_server</span>}
<span class="prompt">2&gt; </span><span class="variable">FileServer</span> = <span class="function_or_atom">afile_server:start</span>(<span class="string">"."</span>)
<span class="prompt">2&gt; </span>.
&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;
<span class="prompt">3&gt; </span><span class="variable">FileServer</span> <span class="exclamation_mark">!</span> {<span class="function_or_atom">self</span>(), <span class="function_or_atom">list_dir</span>}.
{&lt;<span class="number">0.32</span>.<span class="number">0</span>&gt;,<span class="function_or_atom">list_dir</span>}
<span class="prompt">4&gt; </span><span class="function_or_atom">receive</span> <span class="variable">X</span> <span class="arrow">-&gt;</span> <span class="variable">X</span> <span class="function_or_atom">end</span>.
{&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;,
{<span class="ok">ok</span>,[<span class="string">"afile_server.beam"</span>,<span class="string">"afile_server.erl"</span>,<span class="string">"hello.beam"</span>,
    <span class="string">"hello.erl"</span>]}
</code></pre><h3 id="客户端代码">客户端代码</h3>
<p>客户端模块的目的：隐藏底层通信的细节。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="pp"><span class="keyword">-module</span><span class="params">(afile_client)</span></span>.</div><div class="line"><span class="pp"><span class="keyword">-export</span><span class="params">([ls/<span class="number">1</span>,get_file/<span class="number">2</span>])</span></span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">ls</span><span class="params">(<span class="variable">Server</span>)</span>-&gt;</span></div><div class="line">    <span class="variable">Server</span> ! <span class="tuple">{<span class="function_name">self</span>(), list_dir}</span>,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        <span class="tuple">{<span class="variable">Server</span>, <span class="variable">FileList</span>}</span> -&gt;</div><div class="line">            <span class="variable">FileList</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">get_file</span><span class="params">(<span class="variable">Server</span>, <span class="variable">File</span>)</span> -&gt;</span></div><div class="line">    <span class="variable">Server</span> ! <span class="tuple">{<span class="function_name">self</span>(), <span class="tuple">{get_file, <span class="variable">File</span>}</span>}</span>,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        <span class="tuple">{<span class="variable">Server</span>, <span class="variable">Content</span>}</span> -&gt;</div><div class="line">            <span class="variable">Content</span></div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>

<h1 id="3-_基本概念">3. 基本概念</h1>
<p>Erlang的遍历不可变，一次性赋值变量。</p>
<h2 id="停止Erlang_shell">停止Erlang shell</h2>
<p>q().</p>
<h2 id="简单的整数运算">简单的整数运算</h2>
<h2 id="变量">变量</h2>
<p>变量名必须以<strong>大写字母</strong>开头.</p>
<p>Erlang的变量不会变。</p>
<p>变量绑定和模式匹配。</p>
<p>没有副作用意味着可以让程序并行。</p>
<h2 id="浮点数">浮点数</h2>
<h2 id="原子">原子</h2>
<h2 id="元组">元组</h2>
<h2 id="列表">列表</h2>
<h2 id="字符串">字符串</h2>
<h2 id="模式匹配">模式匹配</h2>
<h1 id="4-_模块和函数">4. 模块和函数</h1>
<h2 id="模块是存放代码的地方">模块是存放代码的地方</h2>
<ul>
<li>逗号(,)分隔函数调用，数据构造和模式中的参数。</li>
<li>分号(;)分隔子句。</li>
<li>句号(.)分各个函数整体。</li>
</ul>
<h2 id="fun:_基本的抽象单元">fun: 基本的抽象单元</h2>
<h1 id="5-_记录与映射组">5. 记录与映射组</h1>
<h1 id="6-_顺序程序的错误处理">6. 顺序程序的错误处理</h1>
<h1 id="7-_二进制与位语法">7. 二进制与位语法</h1>
<h1 id="8-_Erlang顺序编程补遗">8. Erlang顺序编程补遗</h1>
<h1 id="9-_类型">9. 类型</h1>
<h1 id="10-_编译和运行程序">10. 编译和运行程序</h1>
<h1 id="11-_现实世界中的并发">11. 现实世界中的并发</h1>
<h1 id="12-_并发编程">12. 并发编程</h1>
<h1 id="13-_并发程序中的错误">13. 并发程序中的错误</h1>
<h1 id="14-_分布式编程">14. 分布式编程</h1>
<h1 id="15-_接口技术">15. 接口技术</h1>
<h1 id="16-_文件编程">16. 文件编程</h1>
<h1 id="17-_套接字编程">17. 套接字编程</h1>
<h1 id="18-_用WebSocket和Erlang进行浏览">18. 用WebSocket和Erlang进行浏览</h1>
<h1 id="19-_用ETS和DETS存储编程">19. 用ETS和DETS存储编程</h1>
<h1 id="20-_Mnesia:_Erlang数据库">20. Mnesia: Erlang数据库</h1>
<h1 id="21-_性能分析，调试与跟踪">21. 性能分析，调试与跟踪</h1>
<h1 id="22-_OTP介绍">22. OTP介绍</h1>
<h1 id="23-_用OTP构建系统">23. 用OTP构建系统</h1>
<h1 id="24-_编程术语">24. 编程术语</h1>
<h1 id="25-_第三方程序">25. 第三方程序</h1>
<h1 id="26-_多核CPU编程">26. 多核CPU编程</h1>
<h1 id="27-_福尔摩斯的最后一案">27. 福尔摩斯的最后一案</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2014/11/21/Programming-Erlang/" data-id="so1gv6al5i4a57vi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Erlang/">Erlang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Pratical-Vim" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/17/Pratical-Vim/" class="article-date">
  <time datetime="2014-11-17T13:33:49.000Z" itemprop="datePublished">11月 17 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/17/Pratical-Vim/">Pratical Vim</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Vim解决问题的方式">1. Vim解决问题的方式</h1>
<h2 id="不要自我重复">不要自我重复</h2>
<p>使用.命令</p>
<p>减少无关的移动：在行尾添加内容这些常见操作，提供一个专门的命令：A</p>
<p>使移动可以重复： ;命令会重复上次f命令查找的字符</p>
<h2 id="执行，重复，回退">执行，重复，回退</h2>
<table>
<thead>
<tr>
<th>用途</th>
<th>操作</th>
<th>重复</th>
<th>回退</th>
</tr>
</thead>
<tbody>
<tr>
<td>做出一个修改</td>
<td>{edit}</td>
<td>.</td>
<td>u</td>
</tr>
<tr>
<td>在行内操作下一指定字符</td>
<td>f{char}/t{char}</td>
<td>;</td>
<td>,</td>
</tr>
<tr>
<td>执行替换</td>
<td>:s/target/replacement</td>
<td>&amp;</td>
<td>u</td>
</tr>
<tr>
<td>执行一系列修改</td>
<td>qx{changes}q</td>
<td>@x</td>
<td>u</td>
</tr>
</tbody>
</table>
<h1 id="2-_普通模式">2. 普通模式</h1>
<h2 id="停顿时请移开画笔">停顿时请移开画笔</h2>
<p>就像画家只花一小部分时间涂色一样， 程序员也只花一小部分时间编写代码。绝大多数时间用来思考，阅读已经在代码中穿梭浏览。<br>而且当确定需要修改时，也不一定要切换到插入模式，我们可以重新调整代码的格式，复制它们，移动其位置或是删除它们。<br>在普通模式中， 我们有众多的工具可以利用。</p>
<h2 id="把撤销单元切成块">把撤销单元切成块</h2>
<p>更喜欢用<esc>o, 而不是<cr></cr></esc></p>
<h2 id="构造可重复的修改">构造可重复的修改</h2>
<p>删除单词： dbx bdw daw</p>
<p>daw 可以发挥.命令的最大威力， 推荐用daw.</p>
<h2 id="用次数做简单的算术运算">用次数做简单的算术运算</h2>
<p>180<c-x></c-x></p>
<h2 id="能够重复，就别用次数">能够重复，就别用次数</h2>
<p>删除两单词：d2w 2dw dw.</p>
<p>只在必要时采用次数</p>
<h2 id="双剑合璧，天下无敌">双剑合璧，天下无敌</h2>
<p>vim的请打很多程度上源自操作符与动作命令相结合。</p>
<p>操作符 + 动作命令 = 操作 </p>
<pre><code>d<span class="list">{motion}</span>: dl daw dap
c<span class="list">{motion}</span>:
y<span class="list">{motion}</span>

g~ gu gU
</code></pre><p>vim的语法有个额外规则：当一个操作符命令被连续调用两次时，它会作用于当前行， 如dd, &gt;&gt;.<br>gU有个特殊的情况， gUU作用于当前行，而不用gUgU.</p>
<p>操作符命令：</p>
<pre><code>c
d
y
g~
gu
gU
&gt;
&lt;
<span class="header">=   自动缩进</span>
!   使用外部程序过滤{motion}所跨越的行
</code></pre><p>可以定义自己的操作符， Tim Pope的commentary.vim定义新的操作符\<br>参考： h :map-operator</p>
<p>自定义动作命令, 参考Kana Natsuno的textobj-entire插件，增加了两文本对象ie和ae.<br>参考：h omap-info</p>
<p>操作符待决模式</p>
<h1 id="3-_插入模式">3. 插入模式</h1>
<p>在插入模式中即时更正错误：</p>
<pre><code><span class="input"><span class="prompt">&lt;C-h&gt;</span> 删除前一个字符</span>
<span class="input"><span class="prompt">&lt;C-w&gt;</span> 删除前一个单词</span>
<span class="input"><span class="prompt">&lt;C-u&gt;</span> 删到行首</span>
</code></pre><p>返回普通模式：</p>
<pre><code><span class="input"><span class="prompt">&lt;Esc&gt;</span> </span>
<span class="input"><span class="prompt">&lt;C-[&gt;</span> 切换到普通模式</span>
<span class="input"><span class="prompt">&lt;C-o&gt;</span> 切换到插入-普通模式</span>
</code></pre><p>插入普通模式：能让我妈执行一次普通模式的命令. (重新回到插入模式）</p>
<p>不离开插入模式，粘贴寄存器中的文本： <c-r>0<br>问题：会出现不必要的缩进或换行。 —&gt; <c-r><c-p>{register}</c-p></c-r></c-r></p>
<p>随时随地做计算：<c-r>=6*35<cr></cr></c-r></p>
<p>用字符编码插入非常用字符:</p>
<pre><code>按键               | 用途
-------------------|------------------------------------
&lt;<span class="keyword">C</span>-v&gt;<span class="list">{123}</span>         | 以十进制编码插入字符 例如: &lt;<span class="keyword">C</span>-v&gt;<span class="number">65</span> A
&lt;<span class="keyword">C</span>-v&gt;u<span class="list">{1234}</span>       | 以十六进制编码插入字符 例如: &lt;<span class="keyword">C</span>-v&gt;u00bf  ¿ 
&lt;<span class="keyword">C</span>-v&gt;<span class="list">{nondigit}</span>    | 按原意插入非数字字符
&lt;<span class="keyword">C</span>-k&gt;<span class="list">{char1}</span><span class="list">{char2}</span>| 插入以二合字母表示的字符. &lt;<span class="keyword">C</span>-k&gt;<span class="number">12</span> ½
</code></pre><p>c查询字符编码： 在字符上按命令ga</p>
<p>二合字符集：h digraphs-default</p>
<p>命令：:digraphs查看可用的二合字母列表。 :h digraphs-table</p>
<p>t替换模式替换又有文本: R命令（由普通模式进入替换模式）</p>
<p>虚拟替换模式：gR命令。会把制表符当做一组空格进行处理。</p>
<p>单次版本：r和gr.</p>
<h1 id="4-_可视模式">4. 可视模式</h1>
<p>三种不同的可视模式： 操作字符文本， 行文本，块文本。</p>
<p>激活可视模式：</p>
<pre><code>按键  <span class="string">| 用途</span>
------<span class="string">|------------------------</span>
v     <span class="string">| 激活面向字符的可视模式</span>
V     <span class="string">| 激活面向行的可视模式</span>
&lt;C-v&gt; <span class="string">| 激活面向列块的可视模式</span>
gv    <span class="string">| 重选上次的高亮选区</span>
</code></pre><p>在可视模式间切换:</p>
<pre><code><span class="input"><span class="prompt">按键          | 用途
--------------|----------------
&lt;Esc&gt;</span> / &lt;<span class="constant">C</span>-[&gt; | 回到普通模式</span>
<span class="input"><span class="prompt">v / V / &lt;C-v&gt;</span> | 切换到普通模式</span>
<span class="input"><span class="prompt">v             | 
V             |
&lt;C-v&gt;</span>         |
o             | 切换高亮选区的活动端</span>
</code></pre><p>vit 选择标签里的内容, gUit</p>
<p>只要可能，最好用操作符命令，而不是可视命令。</p>
<p>用面向内部的可视模式编辑表格数据。</p>
<h1 id="5-_命令行模式">5. 命令行模式</h1>
<p>Ex命令， :h ex-cmd-index 可获取完整列表</p>
<p>特殊按键: <c-w>, <c-u>, <c-v>, <c-k>, <c-r>{register}</c-r></c-k></c-v></c-u></c-w></p>
<p>使用’:t’和’:m’命令复制和移动行</p>
<p>在指定范围上执行普通模式命令. :%normal A;</p>
<p>重复上次的Ex命令： @：</p>
<p>把当前单词插入到命令行中：<c-r><c-w></c-w></c-r></p>
<p>回溯历史命令。 在.vimrc可以设置保存的上限： set history=200</p>
<h1 id="6-_管理多个文件">6. 管理多个文件</h1>
<p>缓冲区相关命令:</p>
<pre><code><span class="symbol">:ls</span> 列出载入到内存中的缓冲区的列表。
<span class="symbol">:bn</span>  切换到下一个缓冲区
<span class="symbol">:bprev</span> 
<span class="symbol">:bfirst</span>
<span class="symbol">:blast</span>
<span class="symbol">:b</span> <span class="constant">N</span>
<span class="symbol">:bd</span> 
</code></pre><p>用参数列表将缓冲区分组： :args</p>
<pre><code>:args <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.md
</code></pre><p>将工作区切分成窗口：</p>
<pre><code><span class="input"><span class="prompt">&lt;C-w&gt;</span> s  水平切分</span>
<span class="input"><span class="prompt">&lt;C-w&gt;</span> v  垂直切分</span>
<span class="input"><span class="prompt">&lt;C-w&gt;</span> c  g关闭当前窗口. <span class="symbol">:clo</span>[se] </span>
<span class="input"><span class="prompt">&lt;C-w&gt;</span> o  只保留当前窗口. <span class="symbol">:on</span>[ly]</span>
<span class="symbol">:sp</span> {file} 水平切分，并在新窗口载入{file}
<span class="symbol">:vsp</span> {file} 垂直切分，并在新窗口载入{file}
</code></pre><p>用标签页将窗口分组</p>
<h1 id="7-_打开和保存文件">7. 打开和保存文件</h1>
<p>使用netrw管理文件系统.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2014/11/17/Pratical-Vim/" data-id="8eby20mex83fqb1i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/">Vim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tool/">tool</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git子模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/29/Git子模块/" class="article-date">
  <time datetime="2014-10-29T01:46:39.000Z" itemprop="datePublished">10月 29 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/29/Git子模块/">Git子模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="external">参考</a></p>
<h1 id="子模块">子模块</h1>
<p>经常有这样的事情，当你在一个项目上工作时，你需要在其中使用另外一个项目。也许它是一个第三方开发的库或者是你独立开发和并在多个父项目中使用的。这个场景下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。</p>
<p>Git 通过子模块处理这个问题。子模块允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h1 id="初步">初步</h1>
<ol>
<li><p>添加子模块。 通过git submodule add将外部项目加为子模块:</p>
<pre><code> $ git submodule add git:<span class="comment">//github.com/chneukirchen/rack.git rack</span>
 Initialized empty Git repository <span class="keyword">in</span> /opt/subtest/rack/.git/
 remote: Counting objects: <span class="number">3181</span>, <span class="keyword">done</span>.
 remote: Compressing objects: <span class="number">100</span>% (<span class="number">1534</span>/<span class="number">1534</span>), <span class="keyword">done</span>.
 remote: Total <span class="number">3181</span> (delta <span class="number">1951</span>), reused <span class="number">2623</span> (delta <span class="number">1603</span>)
 Receiving objects: <span class="number">100</span>% (<span class="number">3181</span>/<span class="number">3181</span>), <span class="number">675.42</span> KiB | <span class="number">422</span> KiB/s, <span class="keyword">done</span>.
 Resolving deltas: <span class="number">100</span>% (<span class="number">1951</span>/<span class="number">1951</span>), <span class="keyword">done</span>.
</code></pre></li>
</ol>
<p>加入子模块后，运行git status, 会看到以下两项。</p>
<pre><code>$ git status
<span class="preprocessor"># On branch master</span>
<span class="preprocessor"># Changes to be committed:</span>
<span class="preprocessor">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span>
<span class="preprocessor">#</span>
<span class="preprocessor">#      new file:   .gitmodules</span>
<span class="preprocessor">#      new file:   rack</span>
<span class="preprocessor">#</span>
</code></pre><p>会生成一个.gitmodules文件。这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录。</p>
<p>这个文件跟其他文件一样也是处于版本控制之下的，就像你的.gitignore文件一样。它跟项目里的其他文件一样可以被推送和拉取。这是其他克隆此项目的人获知子模块项目来源的途径。</p>
<p>在看文件rack:</p>
<pre><code>$ git diff <span class="comment">--cached rack</span>
diff <span class="comment">--git a/rack b/rack</span>
<span class="built_in">new</span> <span class="built_in">file</span> mode <span class="number">160000</span>
index <span class="number">0000000.</span><span class="number">.08</span>d709f
<span class="comment">--- /dev/null</span>
+++ b/rack
@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@
+Subproject commit <span class="number">08</span>d709f78b8c5b0fbeb7821e37fa53e69afcf433
</code></pre><p>尽管rack是你工作目录里的子目录，但 Git 把它视作一个子模块，当你不在那个目录里时并不记录它的内容。取而代之的是，Git 将它记录成来自那个仓库的一个特殊的提交。当你在那个子目录里修改并提交时，子项目会通知那里的 HEAD 已经发生变更并记录你当前正在工作的那个提交；通过那样的方法，当其他人克隆此项目，他们可以重新创建一致的环境。</p>
<p>这是关于子模块的重要一点：你记录他们当前确切所处的提交。你不能记录一个子模块的master或者其他的符号引用。</p>
<ol>
<li><p>克隆一个带子模块的项目<br>这里你将克隆一个带子模块的项目。当你接收到这样一个项目，你将得到了包含子项目的目录，但里面没有文件：</p>
<p> $ git clone git://github.com/schacon/myproject.git<br> Initialized empty Git repository in /opt/myproject/.git/<br> remote: Counting objects: 6, done.<br> remote: Compressing objects: 100% (4/4), done.<br> remote: Total 6 (delta 0), reused 0 (delta 0)<br> Receiving objects: 100% (6/6), done.<br> $ cd myproject<br> $ ls -l<br> total 8<br> -rw-r—r—  1 schacon  admin   3 Apr  9 09:11 README<br> drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack<br> $ ls rack/<br> $</p>
</li>
</ol>
<p>rack目录存在了，但是是空的。你必须运行两个命令：git submodule init来初始化你的本地配置文件，git submodule update来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2014/10/29/Git子模块/" data-id="zuzr02a3ba2shyf2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tool/">tool</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Erlang/" style="font-size: 12.50px;">Erlang</a><a href="/tags/Ice/" style="font-size: 12.50px;">Ice</a><a href="/tags/Vim/" style="font-size: 12.50px;">Vim</a><a href="/tags/golang/" style="font-size: 12.50px;">golang</a><a href="/tags/hadoop/" style="font-size: 15.00px;">hadoop</a><a href="/tags/hbase/" style="font-size: 12.50px;">hbase</a><a href="/tags/java/" style="font-size: 17.50px;">java</a><a href="/tags/javascript/" style="font-size: 15.00px;">javascript</a><a href="/tags/node/" style="font-size: 12.50px;">node</a><a href="/tags/program/" style="font-size: 15.00px;">program</a><a href="/tags/scala/" style="font-size: 12.50px;">scala</a><a href="/tags/scalao/" style="font-size: 10.00px;">scalao</a><a href="/tags/think/" style="font-size: 12.50px;">think</a><a href="/tags/tool/" style="font-size: 15.00px;">tool</a><a href="/tags/分布式系统/" style="font-size: 12.50px;">分布式系统</a><a href="/tags/如何记笔记/" style="font-size: 12.50px;">如何记笔记</a><a href="/tags/笔记/" style="font-size: 20.00px;">笔记</a><a href="/tags/管理/" style="font-size: 12.50px;">管理</a><a href="/tags/读书笔记/" style="font-size: 12.50px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/19/代码的未来/">代码的未来</a>
          </li>
        
          <li>
            <a href="/2015/03/17/深入理解JVM虚拟机/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
          </li>
        
          <li>
            <a href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
          </li>
        
          <li>
            <a href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Peter Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>
