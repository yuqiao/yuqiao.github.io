<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Joe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="enjoy life">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe's Blog">
<meta property="og:url" content="http://yuqiao.github.io/">
<meta property="og:site_name" content="Joe's Blog">
<meta property="og:description" content="enjoy life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe's Blog">
<meta name="twitter:description" content="enjoy life">

  
    <link rel="alternative" href="/atom.xml" title="Joe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Carpe Diem</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yuqiao.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ProgrammingScala" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/27/ProgrammingScala/" class="article-date">
  <time datetime="2015-03-26T23:45:26.000Z" itemprop="datePublished">3月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/27/ProgrammingScala/">ProgrammingScala</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Zero_to_Sixty:_Introducing_Scala">1. Zero to Sixty: Introducing Scala</h1>
<h2 id="A_Taste_of_Concurrency">A Taste of Concurrency</h2>
<ol>
<li><p>Shape class</p>
<p> case class Point(x:Double=0.0, y:Double=0.0)<br> abstract class Shape(){<br> def draw(f:String =&gt; Unit): Unit = f(s”draw: ${this.toString}”)<br> }<br> case class Circle(center:Point, radius: Double) extends Shape<br> case class Rectangle(lowerLeft:Point, height: Double, width: Double) extends Shape<br> case class Triangle(point1:Point, point2:Point, point3:Point) extends Shape</p>
</li>
<li><p>biz Actor</p>
<p> object Messages {<br> object Exit<br> object Finished<br> case class Response(message:String)<br> }</p>
<p> import akka.actor.Actor</p>
<p> class DrawingActor extends Actor{</p>
<pre><code> <span class="keyword">import</span> <span class="type">Messages</span>.<span class="number">_</span>
 <span class="keyword">override</span> def receive = {
     <span class="keyword">case</span> s:<span class="type">Shape</span> =&gt;
     s.draw(str =&gt; <span class="built_in">println</span>(s<span class="string">"DrawingActor: $str"</span>))
     sender ! <span class="type">Response</span>(s<span class="string">"DrawingActor: $s draw"</span>)
     <span class="keyword">case</span> <span class="type">Exit</span> =&gt;
     <span class="built_in">println</span>(s<span class="string">"DrawingActor: exiting ..."</span>)
     sender ! <span class="type">Finished</span>
     <span class="keyword">case</span> unexpected =&gt;
     val res = <span class="type">Response</span>(s<span class="string">"ERROR: Unkwown Message: $unexpected"</span>)
     <span class="built_in">println</span>(s<span class="string">"DrawingActor: $unexpected"</span>)
     sender ! res
 }
</code></pre><p> }</p>
</li>
<li><p>actor driver :</p>
<p> private object Start<br> object ActorDriver {<br>   def main(args: Array[String]) {</p>
<pre><code> val <span class="keyword">system</span> = ActorSystem(<span class="string">"DrawingActorSystem"</span>, ConfigFactory.<span class="built_in">load</span>())
 val drawer = <span class="keyword">system</span>.actorOf(Props(<span class="built_in">new</span> DrawingActor),<span class="string">"drawingActore"</span>)
 val driver = <span class="keyword">system</span>.actorOf(Props(<span class="built_in">new</span> ActorDriver(drawer)), <span class="string">"drawingService"</span>)
 driver ! Start
</code></pre><p>   }<br> }<br> class ActorDriver(drawActor: ActorRef) extends Actor{<br>   import Messages._<br>   override def receive = {</p>
<pre><code> <span class="keyword">case</span> Start =&gt;
   drawActor ! Circle(Point(<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>)
   drawActor ! Rectangle(Point(<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>, <span class="number">5</span>)
   drawActor ! <span class="number">3.14159</span>
   drawActor ! Triangle(Point(<span class="number">0</span>,<span class="number">0</span>), Point(<span class="number">2</span>,<span class="number">0</span>), Point(<span class="number">1</span>,<span class="number">2</span>))
   drawActor ! <span class="keyword">Exit</span>
 <span class="keyword">case</span> Finished =&gt;
   println(<span class="string">"ShapeDrawingDriver: cleaning up..."</span>)
   context.system.shutdown()
 <span class="keyword">case</span> response: Response =&gt;
   println(<span class="string">"ShapeDrawingDriver Response = "</span> + response)
 <span class="keyword">case</span> unexpected =&gt;
   println(<span class="string">"ShapeDrawingDriver: ERROR: Received an unexpected message ="</span> + unexpected)
</code></pre><p>   }<br> }</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/27/ProgrammingScala/" data-id="wq3b6ptmlpm3px1f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sbt学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/22/sbt学习/" class="article-date">
  <time datetime="2015-03-22T07:41:45.000Z" itemprop="datePublished">3月 22 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/22/sbt学习/">sbt学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运行">运行</h1>
<p>sbt 将会自动找到以下内容：</p>
<ul>
<li>项目根目录下的源文件</li>
<li>src/main/scala 或 src/main/java 中的源文件</li>
<li>src/test/scala 或 src/test/java 中的测试文件</li>
<li>src/main/resources 或 src/test/resources 中的数据文件</li>
<li>lib 中的 jar 文件</li>
</ul>
<p>定义build:</p>
<pre><code>lazy val root = (project <span class="keyword">in</span> <span class="type">file</span>(<span class="string">"."</span>)).
    settings(
        <span class="property">name</span> := <span class="string">"hello"</span>,
        <span class="property">version</span> := <span class="string">"1.0"</span>,
        scalaVersion := <span class="string">"2.11.4"</span>
    )
</code></pre><p>设置sbt版本，创建hello/project/build.properties强制指定一个版本的sbt:</p>
<pre><code><span class="attribute">sbt.version</span>=<span class="string">0.13.8</span>
</code></pre><h3 id="批处理模式：">批处理模式：</h3>
<pre><code><span class="variable">$ </span>sbt clean compile <span class="string">"testOnly TestA TestB"</span>
</code></pre><p>在这个例子中，testOnly 有两个参数 TestA 和 TestB。这个命令会按顺序执行（clean， compile， 然后 testOnly）</p>
<h3 id="持续构建和测试">持续构建和测试</h3>
<p>为了加快编辑-编译-测试循环，你可以让 sbt 在你保存源文件时自动重新编译或者跑测试。 在命令前面加上前缀 ~ 后，每当有一个或多个源文件发生变化时就会自动运行该命令。例如，在交互模式下尝试：</p>
<blockquote>
<p>~ compile</p>
</blockquote>
<p>按回车键停止监视变化。 你可以在交互模式或者批处理模式下使用 ~ 前缀。</p>
<h3 id="常用命令">常用命令</h3>
<ul>
<li>clean   删除所有生成的文件 （在 target 目录下）。</li>
<li>compile 编译源文件（在 src/main/scala 和 src/main/java 目录下）。</li>
<li>test    编译和运行所有测试。</li>
<li>console 进入到一个包含所有编译的文件和所有依赖的 classpath 的 Scala 解析器。输入 :quit， Ctrl+D （Unix），或者 Ctrl+Z （Windows） 返回到 sbt。</li>
<li>run &lt;参数&gt;* 在和 sbt 所处的同一个虚拟机上执行项目的 main class。</li>
<li>package 将 src/main/resources 下的文件和 src/main/scala 以及 src/main/java 中编译出来的 class 文件打包成一个 jar 文件。</li>
<li>help &lt;命令&gt; 显示指定的命令的详细帮助信息。如果没有指定命令，会显示所有命令的简介。</li>
<li>reload  重新加载构建定义（build.sbt， project/<em>.scala， project/</em>.sbt 这些文件中定义的内容)。在修改了构建定义文件之后需要重新加载。</li>
</ul>
<h3 id="命令历史记录">命令历史记录</h3>
<ul>
<li>! 线上你是记录命令</li>
<li>!! 重复执行前一条命令</li>
<li>!n 执行下标为n的命令</li>
<li>!string 执行最近执行以string大头的命令</li>
<li>!?string 执行最近执行过的包含sting的命令</li>
</ul>
<h1 id="-sbt构建定义">.sbt构建定义</h1>
<p>构建定义有三种风格。</p>
<ul>
<li>多工程 .sbt 构建定义</li>
<li>bare .sbt 构建定义</li>
<li>.scala 构建定义</li>
</ul>
<p>sbt在检查项目和处理构建定义文件之后，形成一个Project定义。</p>
<p>如何在build.sbt定义设置</p>
<p>build.sbt 定义了一个 Project，它持有一个名为settings的scala表达式列表。</p>
<p>下面是一个例子：</p>
<pre><code><span class="keyword">lazy</span> <span class="keyword">val</span> commonSettings = Seq(
organization := <span class="string">"com.example"</span>,
version := <span class="string">"0.1.0"</span>,
scalaVersion := <span class="string">"2.11.4"</span>
)

<span class="keyword">lazy</span> <span class="keyword">val</span> root = (project <span class="keyword">in</span> file(<span class="string">"."</span>)).
settings(commonSettings: _*).
settings(
    name := <span class="string">"hello"</span>
)
</code></pre><p>有三种类型的key:</p>
<ul>
<li>SettingKey[T]: 一个key对应一个只计算一次的value.</li>
<li>TaskKey[T]: 一个key对应一个称之为task的value, 每次都会重新计算</li>
<li>InputKey[T]: 一个key对应一个可以接收命令行参数的task.</li>
</ul>
<h3 id="内置的keys">内置的keys</h3>
<p>build.sbt会隐式包含import sbt.Keys._, 可以通过name取到sbt.Keys.name.</p>
<p>注：使用lazy val而不是val可以避免初始化顺序的问题。</p>
<h3 id="Task_vs_Setting_keys">Task vs Setting keys</h3>
<p>TaskKey[T]是用来定义task的，类似compile, package这样的操作。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://www.scala-sbt.org/0.13/tutorial/zh-cn/" target="_blank" rel="external">http://www.scala-sbt.org/0.13/tutorial/zh-cn/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/22/sbt学习/" data-id="sntkq1iycjpog9y0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ScalaInDepth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/22/ScalaInDepth/" class="article-date">
  <time datetime="2015-03-22T02:20:20.000Z" itemprop="datePublished">3月 22 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/22/ScalaInDepth/">ScalaInDepth</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_scala_-_一种混合式编程语言">1 scala - 一种混合式编程语言</h1>
<h1 id="2_核心规则">2 核心规则</h1>
<h1 id="3_样式-_编程规范">3 样式- 编程规范</h1>
<h1 id="4_面向对象编程">4 面向对象编程</h1>
<h1 id="5_利用隐式转换">5 利用隐式转换</h1>
<h1 id="6_类型系统">6 类型系统</h1>
<h1 id="7_隐式转换和类型系统结合应用">7 隐式转换和类型系统结合应用</h1>
<h1 id="8_Scala集合库">8 Scala集合库</h1>
<h1 id="9_Actors">9 Actors</h1>
<h1 id="10_Scala和Java集成">10 Scala和Java集成</h1>
<h1 id="11_函数式编程">11 函数式编程</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/22/ScalaInDepth/" data-id="u9671w1563lzhbba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-代码的未来" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/19/代码的未来/" class="article-date">
  <time datetime="2015-03-19T08:06:04.000Z" itemprop="datePublished">3月 19 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/代码的未来/">代码的未来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/19/代码的未来/" data-id="6kzq8e5d3084oda1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/program/">program</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解JVM虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/17/深入理解JVM虚拟机/" class="article-date">
  <time datetime="2015-03-17T09:29:50.000Z" itemprop="datePublished">3月 17 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_走近Java">1. 走近Java</h1>
<h2 id="1-1_概述">1.1 概述</h2>
<p>Java不仅仅是一门编程语言, 它还是一个由一系列计算机软件和规范形成的技术体系.</p>
<p>java优点:</p>
<ul>
<li>结构严谨, 编写对象</li>
<li>摆脱了硬件平台的束缚</li>
<li>提供了相对安全的内存管理和访问机制, 避免绝大部分的内存泄露和指针越界问题</li>
<li>实现了热点代码检测和运行时编译及优化, 使java应用随着运行时间的增加而获取更高的性能</li>
<li>有一套完善的应用程序接口, 还有无数第三方类库</li>
</ul>
<h2 id="1-2_Java技术体系">1.2 Java技术体系</h2>
<p>Sun官方定义的Java技术体系:</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机</li>
<li>Class文件格式</li>
<li>Java API类库</li>
<li>第三方Java类库</li>
<li>实现了热点代码检测和运行时编译及优化, 使java应用随着运行时间的增加而获取更高的性能</li>
<li>有一套完善的应用程序接口, 还有无数第三方类库</li>
</ul>
<h2 id="1-3_Java发展史">1.3 Java发展史</h2>
<h2 id="1-4_展望Java技术的未来">1.4 展望Java技术的未来</h2>
<h3 id="模块化">模块化</h3>
<h3 id="混合语言">混合语言</h3>
<h3 id="多核并发">多核并发</h3>
<h2 id="1-5_实战:_自己编译JDK">1.5 实战: 自己编译JDK</h2>
<h1 id="2-_Java_内存区域与内存溢出异常">2. Java 内存区域与内存溢出异常</h1>
<h2 id="2-2_运行时数据区域">2.2 运行时数据区域</h2>
<ul>
<li><p>执行引擎</p>
</li>
<li><p>本地库接口</p>
</li>
<li><p>运行时数据区域</p>
<ul>
<li>方法区 Method Area， 用以存储虚拟机加载的类信息， 常量，静态变量，即时编译器编译后的代码等数据. </li>
<li>堆 Heap</li>
<li>程序计数器 Program Couter Register</li>
<li>虚拟机栈 VM Stack</li>
<li>本地方法栈 Native method Stack</li>
</ul>
</li>
<li><p>直接内存</p>
</li>
</ul>
<h3 id="程序计数器">程序计数器</h3>
<p>一块较小的内存空间, 作用可以看做是当前线程所执行的字节码的行号指示器.<br>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.<br>分支, 循环, 跳转,异常处理, 线程恢复等基础功能需要这个计数器来完成.</p>
<p>每条线程都有自己一个独立的程序计数器. “线程私有”的内存.</p>
<h3 id="Java虚拟机栈">Java虚拟机栈</h3>
<p>线程私有.</p>
<p>描述的是java方法执行的内存模型: 每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表,<br>操作数栈,动态链接, 方法出口等信息.<br>每一个方法被调用直至执行完成的过程, 就对应着在虚拟机栈中从入栈到出栈的过程.</p>
<h3 id="Java虚拟机栈-1">Java虚拟机栈</h3>
<p>线程私有.<br>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.<br>分支, 循环, 跳转,异常处理, 线程恢复等基础功能需要这个计数器来完成.</p>
<p>每条线程都有自己一个独立的程序计数器. “线程私有”的内存.</p>
<h3 id="Java堆">Java堆</h3>
<p>采用分代收集算法。 堆可细分为：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>划分的目的：更好地回收内存，更快地分配内存</p>
<p>-Xms, -Xmx 来配置堆大小。</p>
<h2 id="OutOfMemoryError异常">OutOfMemoryError异常</h2>
<h3 id="Java堆溢出">Java堆溢出</h3>
<p>配置：</p>
<ul>
<li>-Xms</li>
<li>-Xmx</li>
<li>-XX:+HeapDumpOnOutOfMemeoryError</li>
</ul>
<p>堆溢出时， 异常堆栈信息”java.lang.OutOfMemoryError”会进一步提示”java heap space”</p>
<p>解决该异常：</p>
<ul>
<li>通过内存映象分析工具对dump出来的堆转储快照进行分析。</li>
<li>若是内存泄露， 进一步通过该工具查看泄露对象打GC Roots的引用链，从而找到泄露对象是通过怎样的路径与GC Roots相关联而导致无法垃圾收集。</li>
<li>若不存在泄露， 需要检查虚拟机的堆参数（-Xms，-Xmx)</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3>
<p>栈容量由-Xss参数设定。</p>
<p>由两类异常：</p>
<ul>
<li>线程请求的深度大于虚拟机所允许的最大深度， 抛出StackOverflowError异常</li>
<li>虚拟机在扩展栈是无法申请到足够的内存空间， 抛出OutOfMemoryError</li>
</ul>
<h3 id="运行时常量池异常/方法区溢出">运行时常量池异常/方法区溢出</h3>
<p>溢出时， 异常堆栈信息”java.lang.OutOfMemoryError”会进一步提示”PermGen space”</p>
<p>配置：</p>
<ul>
<li>-XX:PermSize</li>
<li>-XX:MaxPermSize</li>
</ul>
<h1 id="3-_垃圾收集器与内存分配策略">3. 垃圾收集器与内存分配策略</h1>
<h2 id="对象已死？">对象已死？</h2>
<h3 id="引用计数算法">引用计数算法</h3>
<p>很难解决对象之间的相互引用的问题。</p>
<h3 id="根搜索算法">根搜索算法</h3>
<p>GC Roots Tracing 判定对象是否存活。</p>
<p>基本思路：</p>
<pre><code>通过一系列名为<span class="string">"GC Roots"</span>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为”引用链“(Reference Chain). 
当一个对象到GC <span class="keyword">Roots</span>没有任何引用链相连，则证明此对象是不可用的。被判定为可回收对象。
</code></pre><h3 id="Java引用">Java引用</h3>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h3 id="生存还是死亡？">生存还是死亡？</h3>
<p>根搜索不可达的对象， 并非是”非死不可”, 暂时处于缓刑阶段。要真正宣告对象死亡， 至少经历两次标记。</p>
<ol>
<li>根搜索不到， 第一次标记</li>
<li>是否有必要执行finalize()方法， 第二次标记。</li>
</ol>
<p>被判定有必要执行finalize()方法， 对象会被添加名为F-Queue的对了之中， 并在稍后有一条虚拟机自动建立的低优先级的Finalize线程执行。<br>若某个对象在finalize()方法中死循环，那么F-Queue后面的对象都将永久处于等待状态。</p>
<p>永久代的垃圾收集主要回收两部分内容： 废弃常量和无用的类。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<h3 id="标记-清除算法">标记-清除算法</h3>
<p>标记出所需要回收的对象，在标记完成后统一回收掉。 </p>
<p>缺点:</p>
<ul>
<li>效率问题: 标记和清除的效率不高</li>
<li>空间问题: 产生大量不连续的内存碎片</li>
</ul>
<h3 id="复制算法">复制算法</h3>
<p>将可用的内存按容量划分为大小相等的两块，每次使用其中一块。当这块内存用完，将存活的对象复制到另一块上面，然后在把已使用的内存空间一次清理掉。</p>
<p>代价： 可用内存缩小到原来的一半。</p>
<p>使用这种方式来回收新生代， 因为新生代的对象98%是朝生夕死的。</p>
<p>实际划分： 一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden空间和一块Survivor. 回收时讲Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上。</p>
<p>一般Eden:Survivor空间之比是8：1， 那么空间浪费只有10%。</p>
<p>若Survivor空间没有足够的空间存放上一次新生代存活下来的对象， 那么这些对象通过分配担保机制进入老年代。</p>
<h3 id="标记-整理算法">标记-整理算法</h3>
<p>让所有存活的对象向一段移动，然后清理端边界以外的内存。</p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>根据对象的存活周期不同将内存划分为几块。根据各个年代的特点采用最恰当的收集算法。</p>
<h2 id="垃圾收集器">垃圾收集器</h2>
<p>垃圾收集器是内存回收的具体实现。</p>
<h3 id="Serial收集器">Serial收集器</h3>
<h1 id="4-_虚拟机性能监控与故障处理工具">4. 虚拟机性能监控与故障处理工具</h1>
<h2 id="jps">jps</h2>
<ul>
<li>-l</li>
<li>-m</li>
</ul>
<h2 id="jstat">jstat</h2>
<p>例子</p>
<pre><code><span class="tag">jstat</span> <span class="tag">-gcutil</span> <span class="attr_selector">[进程id]</span> <span class="attr_selector">[毫秒数]</span> <span class="attr_selector">[打印次数]</span>

<span class="attr_selector">[admin@v189230231.sqa.zmf ~]</span>$ <span class="tag">jstat</span> <span class="tag">-gcutil</span> 6671 250 10
<span class="tag">S0</span>     <span class="tag">S1</span>     <span class="tag">E</span>      <span class="tag">O</span>      <span class="tag">P</span>     <span class="tag">YGC</span>     <span class="tag">YGCT</span>    <span class="tag">FGC</span>    <span class="tag">FGCT</span>     <span class="tag">GCT</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
</code></pre><p>说明：</p>
<ul>
<li>S0: Survivor 0</li>
<li>S1: Survivor 1</li>
<li>E: Eden空间</li>
<li>O: Old 老年代</li>
<li>YGC: 新生代gc 次数</li>
<li>YGCT:  新生代gc 时间. 单位为秒</li>
<li>FGC： full gc 次数</li>
<li>FGCT： full gc 时间</li>
</ul>
<h2 id="jstack">jstack</h2>
<h1 id="5-_调优案例分析与实战">5. 调优案例分析与实战</h1>
<h1 id="6-_类文件结构">6. 类文件结构</h1>
<h1 id="7-_虚拟机类加载机制">7. 虚拟机类加载机制</h1>
<h1 id="8-_虚拟机字节码执行引擎">8. 虚拟机字节码执行引擎</h1>
<h1 id="9-_类加载及执行子系统的案例与实战">9. 类加载及执行子系统的案例与实战</h1>
<h1 id="10-_早期(编译期)优化">10. 早期(编译期)优化</h1>
<h1 id="11-_晚期(编译期)优化">11. 晚期(编译期)优化</h1>
<h1 id="12-_Java内存模型与线程">12. Java内存模型与线程</h1>
<h1 id="13-_线程安全与锁优化">13. 线程安全与锁优化</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/17/深入理解JVM虚拟机/" data-id="0l16szcs6cqupp2w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-思考，快与慢" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/15/思考，快与慢/" class="article-date">
  <time datetime="2015-03-15T06:50:05.000Z" itemprop="datePublished">3月 15 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一_系统1，_系统2">一 系统1， 系统2</h1>
<h1 id="1_一张愤怒的脸和一张乘法题">1 一张愤怒的脸和一张乘法题</h1>
<h1 id="2_电影的主角和配角">2 电影的主角和配角</h1>
<h1 id="3_惰性思维和延迟满足的矛盾">3 惰性思维和延迟满足的矛盾</h1>
<h1 id="4_联想的神奇力量">4 联想的神奇力量</h1>
<h1 id="5_你的直觉有可能是错觉">5 你的直觉有可能是错觉</h1>
<h1 id="6_意料之外与情理之中">6 意料之外与情理之中</h1>
<h1 id="7_字母“B”和数字“13”">7 字母“B”和数字“13”</h1>
<h1 id="8_我们究竟是如何作出判断的">8 我们究竟是如何作出判断的</h1>
<h1 id="9_目标问题与启发性问题形影不离">9 目标问题与启发性问题形影不离</h1>
<h1 id="二_启发性与偏见">二 启发性与偏见</h1>
<h1 id="10_大数法则与小数定律">10 大数法则与小数定律</h1>
<h1 id="11_锚定效应在生活中随处可见">11 锚定效应在生活中随处可见</h1>
<h1 id="12_科学地利用可得性启发法">12 科学地利用可得性启发法</h1>
<h1 id="13_焦虑情绪与风险政策的设计">13 焦虑情绪与风险政策的设计</h1>
<h1 id="14_猜一下，汤姆的专业是什么">14 猜一下，汤姆的专业是什么</h1>
<h1 id="15_琳达问题的社会效应">15 琳达问题的社会效应</h1>
<h1 id="16_因果关系比统计学信息更有说服力">16 因果关系比统计学信息更有说服力</h1>
<h1 id="17_所有表现都会回归平均值">17 所有表现都会回归平均值</h1>
<h1 id="18_如何让自觉性预测更恰当有效">18 如何让自觉性预测更恰当有效</h1>
<h1 id="三_过度自信与决策错误">三 过度自信与决策错误</h1>
<h1 id="19_“知道”的错觉">19 “知道”的错觉</h1>
<h1 id="20_未来是不可预测">20 未来是不可预测</h1>
<h1 id="21_直觉判断与公式运算，_孰优孰劣">21 直觉判断与公式运算， 孰优孰劣</h1>
<h1 id="22_什么时候可以相信专家的直觉？">22 什么时候可以相信专家的直觉？</h1>
<h1 id="23_努力养成采纳外部意见的决策习惯">23 努力养成采纳外部意见的决策习惯</h1>
<h1 id="24_乐观主义是一把双刃剑">24 乐观主义是一把双刃剑</h1>
<h1 id="四_选择与风险">四 选择与风险</h1>
<h1 id="25_事关财富和风险的选择">25 事关财富和风险的选择</h1>
<h1 id="26_更人性化的前景理论">26 更人性化的前景理论</h1>
<h1 id="27_禀赋效应与市场交易">27 禀赋效应与市场交易</h1>
<h1 id="28_公平性_—_经济交易的参照物">28 公平性 — 经济交易的参照物</h1>
<h1 id="29_对结果可能性的权衡">29 对结果可能性的权衡</h1>
<h1 id="30_被过分关注的罕见事件">30 被过分关注的罕见事件</h1>
<h1 id="31_能带来长远收益的风险政策">31 能带来长远收益的风险政策</h1>
<h1 id="32_心理账户是如何影响我们的选择的？">32 心理账户是如何影响我们的选择的？</h1>
<h1 id="33_评估结果的逆转">33 评估结果的逆转</h1>
<h1 id="34_善用框架效应，让生活更美好">34 善用框架效应，让生活更美好</h1>
<h1 id="五_两个自我">五 两个自我</h1>
<h1 id="35_体验效用于决策效用的不一致">35 体验效用于决策效用的不一致</h1>
<h1 id="36_人生如戏">36 人生如戏</h1>
<h1 id="37_你有多幸福">37 你有多幸福</h1>
<h1 id="38_思考生活">38 思考生活</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/15/思考，快与慢/" data-id="br7hz20kqfycig0p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/think/">think</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go并发编程实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/14/Go并发编程实战/" class="article-date">
  <time datetime="2015-03-14T10:54:05.000Z" itemprop="datePublished">3月 14 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_初识Go语言">1 初识Go语言</h1>
<h2 id="Go语言特性">Go语言特性</h2>
<ul>
<li>开放源代码</li>
<li>虽为静态类型，编译型语言，但Go语言的语法趋于脚本化，非常简洁。</li>
<li>卓越的跨平台支持</li>
<li>全自动的垃圾回收机制</li>
<li>原生的先进并发编程模型和机制</li>
<li>拥有函数式编程范式的特性，函数为一等代码块</li>
<li>无继承层次的轻量级面向对象编程范式</li>
<li>内涵完善，全面的软件工程共计</li>
<li>代码风格强制统一。</li>
<li>程序编译和运行程序都非常快</li>
<li>标准库丰富</li>
</ul>
<h2 id="Go语言优缺点">Go语言优缺点</h2>
<p>优点：</p>
<ul>
<li>相对于c/c++来讲，Go语言拥有清晰的依赖管理和全自动的垃圾回收机制</li>
<li>相对于Java而言，Go语言拥有简明的类型系统， 函数式编程和先进的并发编程类型: 代码更小更简洁,可重用性</li>
<li>性能比脚本语言快</li>
</ul>
<p>缺点：</p>
<ul>
<li>分布式计算，成熟度不比Erlang</li>
<li>程序运行速度，与java不相上下，但不比c</li>
<li>第三方库，不比java, python, ruby.</li>
<li>go并发模型很强大，但有些编写规则需要了解。否则，很容易踩入“坑”。</li>
<li>垃圾回收，会造成停顿。</li>
</ul>
<h1 id="2_Go语言环境搭建">2 Go语言环境搭建</h1>
<h2 id="安装和设置">安装和设置</h2>
<p>目录：</p>
<ul>
<li>api</li>
<li>bin</li>
<li>doc</li>
<li>misc</li>
<li>pkg</li>
<li>src</li>
<li>test</li>
</ul>
<p>环境变量：</p>
<ul>
<li>GOROOT</li>
</ul>
<h2 id="工程结构">工程结构</h2>
<p>Go是一门推崇软件工程理念的编程语言， 为开发周期的每个环节都提供了完备的工具和支持。</p>
<h3 id="工作区">工作区</h3>
<p>包含3个目录:</p>
<ul>
<li>src</li>
<li>pkg</li>
<li>bin</li>
</ul>
<p>命令源文件: 声明为属于main代码包，有main函数的文件。</p>
<h3 id="GOPATH">GOPATH</h3>
<h3 id="源码文件">源码文件</h3>
<h3 id="代码包">代码包</h3>
<h2 id="标准命令">标准命令</h2>
<ul>
<li>build</li>
<li>clean</li>
<li>install</li>
<li>env</li>
<li>fix</li>
<li>fmt</li>
<li>get</li>
<li>list</li>
<li>run</li>
<li>test</li>
<li>version</li>
</ul>
<p>标记：</p>
<ul>
<li>-a: 强行重新构建所有涉及的Go语言代码包</li>
<li>-n: 使命令指示打印，而不真正执行</li>
<li>-v:</li>
<li>-x</li>
</ul>
<h1 id="3_词法与数据结构">3 词法与数据结构</h1>
<h2 id="基本词法">基本词法</h2>
<p>5类词法元素:</p>
<ul>
<li>标识符</li>
<li>关键字</li>
<li>操作符</li>
<li>分隔符</li>
<li>字面量</li>
</ul>
<p>Go语言的所有源代码必须由Unicode编码规范的UTF-8编码格式编码。</p>
<p>接收操作符:  &lt;-</p>
<h3 id="b表达式">b表达式</h3>
<ul>
<li>基本表达式</li>
<li>选择表达式 .</li>
<li>索引符号和索引表达式</li>
<li>切片表达式： a[x:y:z]</li>
<li>类型断言：v, ok := x.(T)</li>
<li>调用</li>
<li><p>可变长参数： </p>
<p>  func appendIfAbsent(s []string, t …string) [] string<br>  appendIfAbsent([]string{“a”,”b”}, s…)</p>
</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>bool</li>
<li>byte</li>
<li>rune</li>
<li>int/uint</li>
<li>int8/uint8</li>
<li>int16/uint16</li>
<li>int32/uint32</li>
<li>int64/uint64</li>
<li>float32</li>
<li>float64</li>
<li>complex64</li>
<li>complex128</li>
<li>string </li>
</ul>
<h3 id="数组">数组</h3>
<ol>
<li><p>类型表示法: [n]T</p>
</li>
<li><p>值表示法: </p>
<ul>
<li>[6]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
<li>[…]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
</ul>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="切片">切片</h3>
<p>可看做对数组的一种包装形式</p>
<ol>
<li><p>类型表示法: []T</p>
</li>
<li><p>值表示法: []string{“GO”, “Python”}</p>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="字典">字典</h3>
<h3 id="函数与方法">函数与方法</h3>
<h3 id="接口">接口</h3>
<pre><code><span class="typedef"><span class="keyword">type</span> <span class="type">Interface</span> interface <span class="container">{
    <span class="type">Len</span>() <span class="title">int</span>
}</span></span>
<span class="typedef"><span class="keyword">type</span> <span class="type">Sortable</span> interface <span class="container">{
    <span class="title">sort</span>.<span class="type">Interface</span>
    <span class="type">Sort</span>()
}</span></span>
</code></pre><h3 id="结构体">结构体</h3>
<p>type Sequence struct {<br>    len int<br>    cap int<br>}</p>
<h3 id="指针">指针</h3>
<h3 id="数据初始化">数据初始化</h3>
<ul>
<li>new</li>
<li>make: 创建切片类型，字典类型和通道类型的值</li>
</ul>
<h2 id="数据的使用">数据的使用</h2>
<h3 id="赋值">赋值</h3>
<h3 id="常量与变量">常量与变量</h3>
<pre><code>const {
    Sunday = itoa
    Monday
    <span class="keyword">...</span>
}
</code></pre><h3 id="内建函数">内建函数</h3>
<ul>
<li>close: 只接受通道类型的值</li>
<li>len, cap</li>
<li>new, make</li>
<li>append, copy: 用于切片类型</li>
<li>delete: 删除一个字典类型的某个键值对</li>
<li>complex, real, imag</li>
<li>panic, recover</li>
<li>print, println</li>
</ul>
<h1 id="4_流程控制方法">4 流程控制方法</h1>
<h2 id="基本流程控制">基本流程控制</h2>
<ul>
<li><p>代码块和作用域</p>
</li>
<li><p>if</p>
</li>
<li><p>switch</p>
</li>
<li><p>for</p>
</li>
</ul>
<h2 id="defer">defer</h2>
<h2 id="异常处理">异常处理</h2>
<h1 id="5_程序测试与文档">5 程序测试与文档</h1>
<h1 id="6_并发编程综述">6 并发编程综述</h1>
<h1 id="7_Goroutine和Channel">7 Goroutine和Channel</h1>
<h1 id="8_同步">8 同步</h1>
<h1 id="9_一个网络爬虫框架的设计和实现">9 一个网络爬虫框架的设计和实现</h1>
<h1 id="Go语言的学习资料">Go语言的学习资料</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/14/Go并发编程实战/" data-id="bshtpwwoj3zsq9u4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript高级程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/12/javascript高级程序设计/" class="article-date">
  <time datetime="2015-03-12T00:12:57.000Z" itemprop="datePublished">3月 12 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_Javascript简介">1 Javascript简介</h1>
<p>Javascript从一个简单的输入验证器发展成了一门强大的语言。</p>
<p>javascript由三部分组成：</p>
<ul>
<li>核心(ECMAScipt)</li>
<li>文档对象模型(DOM)</li>
<li>浏览器对象模型(BOM)</li>
</ul>
<h1 id="2_在HTML中使用Javascript">2 在HTML中使用Javascript</h1>
<h2 id="使用元素">使用<script>元素</h2>
<p><script>定义了6个属性:</p>
<ul>
<li>async</li>
<li>charset</li>
<li>defer</li>
<li>language. 已废弃</li>
<li>src</li>
<li>type</li>
</ul>
<p>标签的位置一般放在<body>元素中页面内容的后面,为了避免延迟。</p>
<p>使用src属性引用外部脚本。最好的做法是引入外部脚本：</p>
<ul>
<li>可维护性</li>
<li>可缓存</li>
<li>适应未来</li>
</ul>
<h2 id="文档模式">文档模式</h2>
<h2 id="元素"><noscript>元素</h2>
<p>用以在不支持javascipt的浏览器中。</p>
<h1 id="3_基本概念">3 基本概念</h1>
<h2 id="语法">语法</h2>
<ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释</li>
<li>严格模式</li>
<li>语句</li>
<li>关键字和保留字</li>
<li>变量：松散类型</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>5种简单类型：</p>
<ul>
<li>Undefined:只有一个值, undefiend. var声明但未初始化. </li>
<li>Null: 只有一个值: null.</li>
<li>Boolean</li>
<li>Number<ul>
<li>浮点数值</li>
<li>数值范围</li>
<li>NaN</li>
<li></li>
</ul>
</li>
<li>String</li>
</ul>
<p>1种复杂数据类型： Object</p>
<p>typeof操作符， 注意它不是函数</p>
<h2 id="流控制语句">流控制语句</h2>
<h2 id="函数">函数</h2>
<h1 id="4_变量，作用域和内存问题">4 变量，作用域和内存问题</h1>
<h1 id="5_引用类型">5 引用类型</h1>
<h1 id="6_面向对象的程序设计">6 面向对象的程序设计</h1>
<h1 id="7_函数表达式">7 函数表达式</h1>
<h1 id="8_BOM">8 BOM</h1>
<h1 id="9_客户端检测">9 客户端检测</h1>
<h1 id="10_DOM">10 DOM</h1>
<h1 id="11_DOM扩展">11 DOM扩展</h1>
<h1 id="12_DOM2和DOM3">12 DOM2和DOM3</h1>
<h1 id="13_事件">13 事件</h1>
<h1 id="14_表单脚本">14 表单脚本</h1>
<h1 id="15_使用Canvas绘图">15 使用Canvas绘图</h1>
<h1 id="16_HTML5脚本编程">16 HTML5脚本编程</h1>
<h1 id="17_错误处理和调试">17 错误处理和调试</h1>
<h1 id="18_Javascript与XML">18 Javascript与XML</h1>
<h1 id="19_E4X(ECMAScipt_for_XML)">19 E4X(ECMAScipt for XML)</h1>
<h1 id="20_JSON">20 JSON</h1>
<h1 id="21_Ajax与Comet">21 Ajax与Comet</h1>
<h1 id="22_高级技巧">22 高级技巧</h1>
<h1 id="23_离线应用与客户端存储">23 离线应用与客户端存储</h1>
<h1 id="24_最佳实践">24 最佳实践</h1>
<h1 id="25_新兴的API">25 新兴的API</h1>
</script></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/12/javascript高级程序设计/" data-id="yl793uiqyiwu57xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-evernote超效率数字笔记术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/10/evernote超效率数字笔记术/" class="article-date">
  <time datetime="2015-03-10T01:05:14.000Z" itemprop="datePublished">3月 10 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/10/evernote超效率数字笔记术/">evernote超效率数字笔记术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/10/evernote超效率数字笔记术/" data-id="iaqmn1ggdogy709x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ProgrammingInScala" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/ProgrammingInScala/" class="article-date">
  <time datetime="2015-03-07T02:47:36.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/ProgrammingInScala/">Scala编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_可扩展的语言">1 可扩展的语言</h1>
<p>增加新的类型:</p>
<pre><code> scala像一个集市而不是大教堂, 它被设计为可以让使用他的人扩展和修改.
</code></pre><p>增加新的控制结构:</p>
<pre><code> 基于actor的并发模型
</code></pre><h2 id="为何使用scala">为何使用scala</h2>
<p>1 兼容的<br>2 简洁的<br>3 高级的</p>
<pre><code> 程序员总是在与代码的复杂性搏斗.只有对工作的代码了如指掌,才能有的放矢的编程开发.
 复杂的代码成了很多软件项目崩溃的原因.
 不幸的是,重要的软件通常需求复杂.复杂性不可避免,那么必须加强管理.
 scala可以通过帮助提升接口的抽象级别来帮助管理复杂性.
</code></pre><p>4 静态类型的</p>
<pre><code> scala通过类型推断避免了冗余性
 通过模式匹配和一些新的编写和组织类型的办法获得了灵活性.
 静态类型系统可以保证消除某些运行时错误.
</code></pre><h1 id="2_Scala入门初探">2 Scala入门初探</h1>
<p>定义方法时, 如果仅仅包含一条语句, 可以连花括号可以不写.</p>
<p>倾向于函数式的编程风格::</p>
<pre><code>    args.<span class="keyword">foreach</span>( arg =&gt; println(arg ) )
    args.<span class="keyword">foreach</span>( println )
</code></pre><p>scala的数组是通过索引值加圆括号进行访问( 不是方括号)</p>
<p>另一个准则: 方法只有一个参数,调用的时候可以省略点和括号::</p>
<pre><code>    <span class="keyword">for</span>( <span class="keyword">i</span> &lt;- <span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> )
        <span class="keyword">print</span>( greetingString(<span class="keyword">i</span>))
</code></pre><p>用括号传递给变量一个或多个值变量时, Scala会把它转换为对apply方法的调用.</p>
<p>类似有update方法调用.</p>
<p>scala对任何事物都追求概念的简洁性, 从数组到表达式,包括带有方法的对象.</p>
<p>方法没有副作用是函数式风格编程的重要概念.</p>
<p>为何列表不支持append, 性能差</p>
<p>Scala程序员的平衡感:</p>
<pre><code> 崇尚val, 不可变量和没有副作用的方法.
 首先想到他们.只有在特定需要和并加以权衡之后才选择var,可变对象和有副作用的方法.
</code></pre><p>从文件里读取文本行:</p>
<pre><code>    <span class="keyword">for</span>( <span class="built_in">line</span> &lt;- Source.fromFile(<span class="string">"scalaProject.iml"</span>).getLines())
      println( <span class="built_in">line</span>.<span class="built_in">length</span> + <span class="string">" "</span> + <span class="built_in">line</span>)
</code></pre><h1 id="4_类和对象">4 类和对象</h1>
<p>保持对象健壮性的重要方法之一: 保证对象的状态.</p>
<p>scala里方法参数的一个重要特征是他们都是val.</p>
<p>方法的推荐风格是尽量避免return语句, 尤其是多条return语句.</p>
<p>scala通常的风格:把操作符放在行尾和不是行头::</p>
<pre><code>    <span class="title">x</span> +
    y +
    z
</code></pre><p>scala不能定义静态成员,而代之定义单例对象.</p>
<h1 id="5_基本类型和操作">5 基本类型和操作</h1>
<p>值类型: Int,Long,Short,Byte,Float,Double,Char, Boolean<br>String</p>
<p>符号字面值:  ‘&lt;标识符&gt;, Symbol(“cybmbal”)</p>
<p>方法调用的空括号可以省略. 惯例是若方法带有副作用就加上括号, 如pringln(). 若没有副作用,就去掉括号.</p>
<p>scala的==与java有差别.</p>
<p>富包装器.</p>
<h1 id="6_函数式对象">6 函数式对象</h1>
<p>函数式对象: 不具有任何可改变状态的对象的类</p>
<p>不可变对象的缺点: 有时需要负责很大的对象表, 而可变对象的更新可以在原址上发生.</p>
<p>为朱构造器定义先决条件. 用require方法.</p>
<p>不建议在标识符结尾使用下划线.</p>
<p>scala的常量名, 习惯只是第一个字母必须大写.</p>
<p>如果无技巧性地使用, 操作符方法和隐式转换都会让客户代码变得难以阅读和理解.</p>
<p>在设计库的时候你应记在脑袋你的目标并不是仅仅让客户代码简洁, 而是让他变得更可读,更易懂.</p>
<h1 id="7_内建控制结构">7 内建控制结构</h1>
<p>由于while循环不产生值,因此他经常被纯函数式语言所舍弃.</p>
<p>for 过滤:</p>
<pre><code>    val filesHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>) ).listFiles
    <span class="keyword">for</span>( <span class="keyword">file</span> &lt;- filesHere <span class="keyword">if</span> <span class="keyword">file</span>.getname.endsWith(<span class="string">".scala"</span>)
        <span class="keyword">println</span>( <span class="keyword">file</span>)

    <span class="keyword">for</span>( 
        <span class="keyword">file</span> &lt;- filesHere
        <span class="keyword">if</span> <span class="keyword">file</span>.isFile;
        <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
    ) <span class="keyword">println</span>(<span class="keyword">file</span>)
</code></pre><p>嵌套枚举:</p>
<pre><code>    <span class="keyword">def</span> fileLines(<span class="keyword">file</span>: java.io.<span class="keyword">File</span>) =
        scala.io.<span class="keyword">Source</span>.fromFile(<span class="keyword">file</span>).getLines.<span class="keyword">toList</span>

    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span>(
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>);     <span class="comment">//必须有分号;</span>
            line &lt;- fileLines(<span class="keyword">file</span>)
            <span class="keyword">if</span> line.trim.matches(pattern)
        )<span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ line.trim )

    <span class="keyword">grep</span> (<span class="string">".*gcd.*"</span>)
</code></pre><p>可以使用花括号代替小括号包裹发生器和过滤器,优点:可以不写分号.</p>
<p>以上有缺点, line.trim多次计算. 可以使用流间变量绑定::</p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span> {
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
            line &lt;- fileLines(<span class="keyword">file</span>)
            trimmed = line.trim
            <span class="keyword">if</span> trimmed.matches(pattern)
        } <span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ trimmed )
</code></pre><p>制造新集合. 使用yield::</p>
<pre><code>    <span class="keyword">for</span> {  子句 } <span class="keyword">yield</span> { 循环体}
</code></pre><p>抛出异常的类型是Nothing.</p>
<p>catch使用模式匹配::</p>
<pre><code>    <span class="keyword">try</span>{
        val f = <span class="keyword">new</span> FileReader(<span class="string">"input.txt"</span>)
    }<span class="keyword">catch</span>{
        <span class="keyword">case</span> ex:FileNotFoundException =&gt; <span class="comment">// 处理丢失的文件</span>
        <span class="keyword">case</span> ex: IOException =&gt; <span class="comment">//处理io错误</span>
    }
</code></pre><p>finally也产生值.</p>
<p>不再使用break和continue</p>
<p>变量范围::</p>
<pre><code>任何定义在花括号里的东西超出括号之后就脱离了范围. ( <span class="keyword">for</span>子句有例外)
</code></pre><h1 id="8_函数和闭包">8 函数和闭包</h1>
<p>函数式编程风格的重要设计原则: 程序应该被解构成若干小的函数.</p>
<p>本地函数可以访问包含其函数的参数.</p>
<p>函数字面值::</p>
<pre><code>    <span class="function"><span class="params">(x: Int)</span> =&gt;</span> x + <span class="number">1</span>
</code></pre><p>想让函数字面量包含多条语句,可以用花括号包住函数体,一行一语句 ::</p>
<pre><code>    <span class="function"><span class="title">increase</span> = <span class="params">(x: Int)</span> =&gt;</span> {
        println(<span class="string">"We"</span>)
        println(<span class="string">"are"</span>)
        println(<span class="string">"here!)
        x + 1
    }</span>
</code></pre><p>其他例子::</p>
<pre><code>    val someNumbers = List( -<span class="number">11</span>, -<span class="number">10</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)
    someNumbers.foreach<span class="function"><span class="params">(  (x:Int) =&gt; println( x ) )</span>
    <span class="title">someNumbers</span>.<span class="title">filter</span><span class="params">( (x:Int) =&gt; x &gt; <span class="number">0</span> )</span></span>
</code></pre><p>函数字面量的短格式. ( 去除参数类型; 去除括号) ::</p>
<pre><code><span class="attribute">    someNumbers.filter( x </span>=<span class="string">&gt; x &gt; 0 )</span>
</code></pre><p>占位符语法(只要每个参数在函数字面量内仅出现一次)::</p>
<pre><code>    someNumbers.<span class="built_in">filter</span>( _ &gt; <span class="number">0</span> )

    val f = (_: <span class="built_in">Int</span> ) + (_ : <span class="built_in">Int</span> )
    f(<span class="number">5</span>, <span class="number">10</span> )
</code></pre><p>还可以用单个下划线代替整个参数列表::</p>
<pre><code>    someNumbers.foreach( println _ )
    def <span class="built_in">sum</span>(<span class="operator">a</span>: Int, b: Int, c:Int ) = <span class="operator">a</span> + b + c
    val <span class="operator">a</span> = <span class="built_in">sum</span> _
    <span class="operator">a</span>( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )

    val b = <span class="built_in">sum</span>( <span class="number">1</span>, _:Int, <span class="number">3</span> )
</code></pre><p> 写一个省略所以参数偏函数表达式, 如 println <em> 或 sum </em>, 在需要函数的地方可进一步去掉占位符::</p>
<pre><code>    someNumbers.<span class="keyword">foreach</span>( println )

    <span class="comment">//但不能这样写: val c = sum</span>
    val d = sum _   <span class="comment">//必须带占位符</span>
</code></pre><h1 id="9_控制抽象">9 控制抽象</h1>
<h2 id="9-1_减少代码重复">9.1 减少代码重复</h2>
<p>所有的函数都可以被分成通用部分, 以及非通用部分. 通用部分是函数体, 而非通用部分必须由参数提供.</p>
<p>高阶函数: 带其他函数做参数的函数- 给你额外的机会去组织和简化代码.</p>
<p>例如:</p>
<pre><code>    object FileMatcher {
        <span class="keyword">def</span> fileHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>)).listFiles
    <span class="keyword">def</span> filesEnding(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(query))
        yield <span class="keyword">file</span>

    <span class="keyword">def</span> filesContain(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.contains(query))
        yield <span class="keyword">file</span>

    }
</code></pre><p>以上filesEnding和FilesContain结构很像.</p>
<pre><code>    def filesMatching(query:<span class="typename">String</span>, matcher: (<span class="typename">String</span>,<span class="typename">String</span>) =&gt;<span class="typename">Boolean</span>) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> matcher(<span class="keyword">file</span>.getName, query))
        yield <span class="keyword">file</span>
</code></pre><p>那么原来两个方法可以简化为:</p>
<pre><code>    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(query,_.<span class="function">endsWith</span>(_))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(query, _.<span class="function">contains</span>(_))</span>
</code></pre><p>使用闭包可以更短.</p>
<pre><code>    def <span class="function">filesMatching</span>(matcher<span class="value">: String =&gt; Boolean) =
        <span class="function">for</span>(file &lt;- fileHere;</span> if <span class="function">matcher</span>(file<span class="class">.getName</span>))
        yield file

    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))</span>
</code></pre><h2 id="9-2_简化客户代码">9.2 简化客户代码</h2>
<p>例子: 判断是否有负数.</p>
<pre><code>    <span class="function"><span class="keyword">def</span> <span class="title">containsNeg</span><span class="params">( nums: List[Int])</span>:</span>Boolean = {
        var exists = false
        <span class="keyword">for</span>(num&lt;-nums)
        <span class="keyword">if</span> (num&lt;<span class="number">0</span>)
            exists = true
        exists   
    }
</code></pre><p>更简洁的方式, 是使用高阶函数exists:</p>
<pre><code>   def containsNeg(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ &lt; <span class="number">0</span>)
   def containsOdd(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ % <span class="number">2</span> == <span class="number">1</span>) 
</code></pre><h2 id="9-3_柯里化(_currying_)">9.3 柯里化( currying )</h2>
<p>例子：</p>
<pre><code>    <span class="keyword">def</span> plainOldSum(x :<span class="keyword">Int</span>, y: <span class="keyword">Int</span>) = x + y
    plainOldSum(<span class="number">1</span>,<span class="number">3</span>)
    <span class="keyword">def</span> curriedSum(x:<span class="keyword">Int</span>)(y:<span class="keyword">Int</span>)= x + y
    curriedSum(<span class="number">1</span>)(<span class="number">3</span>)
    val first = curriedSum(<span class="number">1</span>)_
    first(<span class="number">3</span>)
</code></pre><h2 id="9-4_编写新的控制结构">9.4 编写新的控制结构</h2>
<p>双倍控制结构:</p>
<pre><code>    <span class="keyword">def</span> twice(op: <span class="keyword">Double</span> =&gt;<span class="keyword">Double</span>, x:<span class="keyword">Double</span>) = op(op(x))
    twice(_ + <span class="number">1</span>, <span class="number">5</span>)
</code></pre><p>代码模式: 打开一个资源, 对它进行操作, 然后释放资源: </p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>: <span class="keyword">File</span>)(op: PrintWriter =&gt; Unit){
        val writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">file</span>)
        <span class="keyword">try</span>{
        op(writer)
        }<span class="keyword">finally</span>{
        writer.close()
        }
    }
    val <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"date.txt"</span>)
    <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>){
        writer =&gt; writer.<span class="keyword">println</span>(<span class="keyword">new</span> java.util.Date)
    }
</code></pre><p>scala的任何方法调用, 如果你确实只传入一个参数, 就能可选地使用花括号替代小括号包围参数.<br>目的: 是让客户程序员写出包围在花括号内的函数字面量,.</p>
<h2 id="9-5_传名参数">9.5 传名参数</h2>
<h1 id="10_组合与继承">10 组合与继承</h1>
<h2 id="10-1_二维布局库">10.1 二维布局库</h2>
<h2 id="10-3_定义无参数方法">10.3 定义无参数方法</h2>
<p>scala鼓励使用不带参数且没有副作用的方法定义为无参数方法的风格, 即省略空括号.<br>无论何时当调用有副作用的方法, 应确保包含一对括号.</p>
<p>scala里的字段和方法属于相同的命名空间.这让字段可以重写无参数方法.</p>
<p>scala仅有两个命名空间:</p>
<ul>
<li>值</li>
<li>类型</li>
</ul>
<h1 id="11_Scala的层级">11 Scala的层级</h1>
<p>Scala中每个类都继承超类Any。在底层还定义了： Null和Nothing。 Nothing是所有其他类的子类。</p>
<h2 id="11-1_Scala的类层级">11.1 Scala的类层级</h2>
<p>Any两子类:</p>
<ul>
<li><p>AnyVal: 内建值类的父类， 有9个子类：</p>
<ul>
<li>Byte</li>
<li>Short</li>
<li>Char</li>
<li>Int</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Unit</li>
</ul>
</li>
<li><p>AnyRef：所有引用类的基类，就是java.lang.Object的别名。还继承自一个名为ScalaObject的特别的记号特质（ 用于编译优化）</p>
</li>
</ul>
<h2 id="11-2_原始类型是如何实现的">11.2 原始类型是如何实现的</h2>
<h2 id="11-3_底层类型">11.3 底层类型</h2>
<p>Null类是null引用对象的类型, 是每个引用类的子类. 不兼容值类型.<br>Nothing类型在Scala的类层次的最底层.</p>
<h1 id="12_特质">12 特质</h1>
<p>特质封装了方法和字段的定义,并可以混入到类中重新定义它们.</p>
<h1 id="13_包和引用">13 包和引用</h1>
<p>做程序的时候, 使耦合最小化是很重要的. 减小耦合性的方式之一是使用模块化的风格编写代码.</p>
<h1 id="13-1_包">13.1 包</h1>
<p>scala采用java平台完整的包机制.</p>
<ol>
<li><p>和java相同:</p>
<p> package bobosrockets.navigtion<br> class Navigtor</p>
</li>
<li><p>像C#的命名空间:</p>
<p> package bobosrockets {</p>
<pre><code> <span class="keyword">package</span> navigtion{
     <span class="class"><span class="keyword">class</span> <span class="title">Navigtor</span></span>
     <span class="keyword">package</span> tests{
         <span class="class"><span class="keyword">class</span> <span class="title">NavigtorSuite</span></span>
     }
 }
</code></pre><p> }</p>
</li>
</ol>
<p>顶层包: <em>root</em></p>
<h1 id="13-2_引用">13.2 引用</h1>
<p>import子句让包活对象的成员可以子句通过名称访问而不是通过前缀包访问.<br>例子:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets._</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit._</span>
</code></pre><p>Scala的引用可以出现在任何地方.</p>
<p>可以引用包本身.</p>
<p>可以重命名或隐匿成员:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple =&gt; McIntosh, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.{Date =&gt; SDate}</span>

<span class="preprocessor"><span class="keyword">import</span> Fruits.{Pear =&gt; _, _ }  // 引用了Fruits的所有成员,但Pear除外</span>
</code></pre><h1 id="13-3_隐式引用">13.3 隐式引用</h1>
<p>Scala为每个程序隐式地添加一些引用:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> java.lang._</span>
<span class="preprocessor"><span class="keyword">import</span> scala._</span>
<span class="preprocessor"><span class="keyword">import</span> Predef._</span>
</code></pre><h1 id="13-4_访问修饰符">13.4 访问修饰符</h1>
<p>private[X] 表示”直到”X的私有保护.</p>
<p>private[this]标记的定义仅能在包含了定义同一个对象中被访问.</p>
<p>类的所有访问权限都对伴生对象开放,反过来也是如此.</p>
<h1 id="14_断言和单元测试">14 断言和单元测试</h1>
<h1 id="21_隐式转换和参数">21 隐式转换和参数</h1>
<p>隐式转换只是普通的方法, 但它一修饰符implicit开始.</p>
<p>例子:</p>
<pre><code>    implicit def stringWrpper(<span class="keyword">s</span>: String) = 
            new RandomAccessSe<span class="string">q[Char]</span>  {
            def <span class="keyword">length</span> = <span class="keyword">s</span>.<span class="keyword">length</span>
            def apply(i: Int) = <span class="keyword">s</span>.charAt(i)
    }
</code></pre><p>优点:</p>
<ul>
<li>免费获取所有其它RandomAccessSeq的方法</li>
<li>支持目标类型的转换</li>
</ul>
<p>隐性定义是指编译器为了修正类型错误而允许插入到程序中的定义.<br>例如: 若 x + y不能通过类型检查, 编译器可能会把它改为convert(x) + y</p>
<p>标记规则: 只有标记为implicit的定义才是可用的.</p>
<p>作用域规则: 插入的隐性转换必须以单一标识符的形式处于作用域中,或与转换的源或目标类型关联在一起.</p>
<p>无歧义规则: 隐式转换唯有不存在其他可插入转换的前提下才能插入.</p>
<p>单一调用规则: 只会尝试一个隐式操作, 编译器不会把 x +y 重写成convert1(convert2(x)) + y.</p>
<p>显式操作先行规则: 若编写的代码类型检查无误, 则不会尝试任何隐式操作.</p>
<p>命名隐式转换.</p>
<p>隐式操作在哪里尝试:</p>
<ul>
<li>转换为期望类型</li>
<li>指定(方法)调用者的转换</li>
<li>隐式参数</li>
</ul>
<p>被所有Scala程序隐式引用的scala.Predef对象, 定义了把”较小的”数值类型转变为”较大的”类型的隐式转换.</p>
<h2 id="转换为方法的接受者">转换为方法的接受者</h2>
<p>例子:</p>
<pre><code>    class Rational(n: Int, d: Int) {
        <span class="keyword">...</span>
        def + (that: Rational): Rational = <span class="keyword">...</span>
        def + (that: Int): Rational = <span class="keyword">...</span>
    }
</code></pre><p>执行：</p>
<pre><code>scala&gt; <span class="number">1</span> + oneHalf
&lt;console&gt;:<span class="number">6</span>: error: overloaded <span class="function"><span class="keyword">method</span> <span class="title">value</span> + <span class="title">with</span>
<span class="title">alternatives</span> <span class="params">(Double)</span><span class="title">Double</span> &lt;<span class="title">and</span>&gt; ... <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span>

<span class="title">scala</span>&gt; <span class="title">implicit</span> <span class="title">def</span> <span class="title">intToRational</span><span class="params">(x: Int)</span> = <span class="title">new</span> <span class="title">Rational</span><span class="params">(x, 1)</span>
<span class="title">intToRational</span>:</span> (x: Int)Rational

scala&gt; <span class="number">1</span> + oneHalf
res2: Rational = <span class="number">3</span>/<span class="number">2</span>
</code></pre><h2 id="模拟新的语法">模拟新的语法</h2>
<p>例子:</p>
<pre><code>    <span class="built_in">Map</span>(<span class="number">1</span> <span class="subst">-&gt;</span><span class="string">"one"</span>, <span class="number">2</span> <span class="subst">-&gt;</span><span class="string">"two"</span>, <span class="number">3</span> <span class="subst">-&gt;</span><span class="string">"three"</span>)
</code></pre><p>“-&gt;”不是内建语法, -&gt;只是定义在标准Scala中类ArrowAssoc的方法, 定义了Any到ArrowAssoc的隐式转化.<br>编写 1-&gt;”one”的时候, 编译器会插入1到ArrowAssoc的转换以便找到-&gt;方法.</p>
<pre><code>    package scala
    object Predef {
        class ArrowAssoc[A](x: A) {
            def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)
        }
        implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
        new ArrowAssoc(x)
        <span class="keyword">...</span>
    }
</code></pre><h2 id="隐式参数">隐式参数</h2>
<p>编译器有时会用someCall(a)(b)替换somCall(a) 或者用new someCall(a)(b)替换new someCall(a).<br>从而通过添加缺失参数列表以满足函数调用.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/ProgrammingInScala/" data-id="n7l1932ui6el72wb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Erlang/" style="font-size: 12.50px;">Erlang</a><a href="/tags/Ice/" style="font-size: 12.50px;">Ice</a><a href="/tags/Vim/" style="font-size: 12.50px;">Vim</a><a href="/tags/golang/" style="font-size: 12.50px;">golang</a><a href="/tags/hadoop/" style="font-size: 15.00px;">hadoop</a><a href="/tags/hbase/" style="font-size: 12.50px;">hbase</a><a href="/tags/java/" style="font-size: 17.50px;">java</a><a href="/tags/javascript/" style="font-size: 15.00px;">javascript</a><a href="/tags/node/" style="font-size: 12.50px;">node</a><a href="/tags/program/" style="font-size: 15.00px;">program</a><a href="/tags/scala/" style="font-size: 17.50px;">scala</a><a href="/tags/scalao/" style="font-size: 10.00px;">scalao</a><a href="/tags/think/" style="font-size: 12.50px;">think</a><a href="/tags/tool/" style="font-size: 15.00px;">tool</a><a href="/tags/分布式系统/" style="font-size: 12.50px;">分布式系统</a><a href="/tags/如何记笔记/" style="font-size: 12.50px;">如何记笔记</a><a href="/tags/笔记/" style="font-size: 20.00px;">笔记</a><a href="/tags/管理/" style="font-size: 12.50px;">管理</a><a href="/tags/读书笔记/" style="font-size: 12.50px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/27/ProgrammingScala/">ProgrammingScala</a>
          </li>
        
          <li>
            <a href="/2015/03/22/sbt学习/">sbt学习</a>
          </li>
        
          <li>
            <a href="/2015/03/22/ScalaInDepth/">ScalaInDepth</a>
          </li>
        
          <li>
            <a href="/2015/03/19/代码的未来/">代码的未来</a>
          </li>
        
          <li>
            <a href="/2015/03/17/深入理解JVM虚拟机/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Peter Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>
