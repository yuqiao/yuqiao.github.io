<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Joe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="enjoy life">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe's Blog">
<meta property="og:url" content="http://yuqiao.github.io/">
<meta property="og:site_name" content="Joe's Blog">
<meta property="og:description" content="enjoy life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe's Blog">
<meta name="twitter:description" content="enjoy life">

  
    <link rel="alternative" href="/atom.xml" title="Joe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Carpe Diem</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yuqiao.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-思考，快与慢" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/15/思考，快与慢/" class="article-date">
  <time datetime="2015-03-15T06:50:05.000Z" itemprop="datePublished">3月 15 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一_系统1，_系统2">一 系统1， 系统2</h1>
<h1 id="1_一张愤怒的脸和一张乘法题">1 一张愤怒的脸和一张乘法题</h1>
<h1 id="2_电影的主角和配角">2 电影的主角和配角</h1>
<h1 id="3_惰性思维和延迟满足的矛盾">3 惰性思维和延迟满足的矛盾</h1>
<h1 id="4_联想的神奇力量">4 联想的神奇力量</h1>
<h1 id="5_你的直觉有可能是错觉">5 你的直觉有可能是错觉</h1>
<h1 id="6_意料之外与情理之中">6 意料之外与情理之中</h1>
<h1 id="7_字母“B”和数字“13”">7 字母“B”和数字“13”</h1>
<h1 id="8_我们究竟是如何作出判断的">8 我们究竟是如何作出判断的</h1>
<h1 id="9_目标问题与启发性问题形影不离">9 目标问题与启发性问题形影不离</h1>
<h1 id="二_启发性与偏见">二 启发性与偏见</h1>
<h1 id="10_大数法则与小数定律">10 大数法则与小数定律</h1>
<h1 id="11_锚定效应在生活中随处可见">11 锚定效应在生活中随处可见</h1>
<h1 id="12_科学地利用可得性启发法">12 科学地利用可得性启发法</h1>
<h1 id="13_焦虑情绪与风险政策的设计">13 焦虑情绪与风险政策的设计</h1>
<h1 id="14_猜一下，汤姆的专业是什么">14 猜一下，汤姆的专业是什么</h1>
<h1 id="15_琳达问题的社会效应">15 琳达问题的社会效应</h1>
<h1 id="16_因果关系比统计学信息更有说服力">16 因果关系比统计学信息更有说服力</h1>
<h1 id="17_所有表现都会回归平均值">17 所有表现都会回归平均值</h1>
<h1 id="18_如何让自觉性预测更恰当有效">18 如何让自觉性预测更恰当有效</h1>
<h1 id="三_过度自信与决策错误">三 过度自信与决策错误</h1>
<h1 id="19_“知道”的错觉">19 “知道”的错觉</h1>
<h1 id="20_未来是不可预测">20 未来是不可预测</h1>
<h1 id="21_直觉判断与公式运算，_孰优孰劣">21 直觉判断与公式运算， 孰优孰劣</h1>
<h1 id="22_什么时候可以相信专家的直觉？">22 什么时候可以相信专家的直觉？</h1>
<h1 id="23_努力养成采纳外部意见的决策习惯">23 努力养成采纳外部意见的决策习惯</h1>
<h1 id="24_乐观主义是一把双刃剑">24 乐观主义是一把双刃剑</h1>
<h1 id="四_选择与风险">四 选择与风险</h1>
<h1 id="25_事关财富和风险的选择">25 事关财富和风险的选择</h1>
<h1 id="26_更人性化的前景理论">26 更人性化的前景理论</h1>
<h1 id="27_禀赋效应与市场交易">27 禀赋效应与市场交易</h1>
<h1 id="28_公平性_—_经济交易的参照物">28 公平性 — 经济交易的参照物</h1>
<h1 id="29_对结果可能性的权衡">29 对结果可能性的权衡</h1>
<h1 id="30_被过分关注的罕见事件">30 被过分关注的罕见事件</h1>
<h1 id="31_能带来长远收益的风险政策">31 能带来长远收益的风险政策</h1>
<h1 id="32_心理账户是如何影响我们的选择的？">32 心理账户是如何影响我们的选择的？</h1>
<h1 id="33_评估结果的逆转">33 评估结果的逆转</h1>
<h1 id="34_善用框架效应，让生活更美好">34 善用框架效应，让生活更美好</h1>
<h1 id="五_两个自我">五 两个自我</h1>
<h1 id="35_体验效用于决策效用的不一致">35 体验效用于决策效用的不一致</h1>
<h1 id="36_人生如戏">36 人生如戏</h1>
<h1 id="37_你有多幸福">37 你有多幸福</h1>
<h1 id="38_思考生活">38 思考生活</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/15/思考，快与慢/" data-id="br7hz20kqfycig0p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/think/">think</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go并发编程实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/14/Go并发编程实战/" class="article-date">
  <time datetime="2015-03-14T10:54:05.000Z" itemprop="datePublished">3月 14 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_初识Go语言">1 初识Go语言</h1>
<h2 id="Go语言特性">Go语言特性</h2>
<ul>
<li>开放源代码</li>
<li>虽为静态类型，编译型语言，但Go语言的语法趋于脚本化，非常简洁。</li>
<li>卓越的跨平台支持</li>
<li>全自动的垃圾回收机制</li>
<li>原生的先进并发编程模型和机制</li>
<li>拥有函数式编程范式的特性，函数为一等代码块</li>
<li>无继承层次的轻量级面向对象编程范式</li>
<li>内涵完善，全面的软件工程共计</li>
<li>代码风格强制统一。</li>
<li>程序编译和运行程序都非常快</li>
<li>标准库丰富</li>
</ul>
<h2 id="Go语言优缺点">Go语言优缺点</h2>
<p>优点：</p>
<ul>
<li>相对于c/c++来讲，Go语言拥有清晰的依赖管理和全自动的垃圾回收机制</li>
<li>相对于Java而言，Go语言拥有简明的类型系统， 函数式编程和先进的并发编程类型: 代码更小更简洁,可重用性</li>
<li>性能比脚本语言快</li>
</ul>
<p>缺点：</p>
<ul>
<li>分布式计算，成熟度不比Erlang</li>
<li>程序运行速度，与java不相上下，但不比c</li>
<li>第三方库，不比java, python, ruby.</li>
<li>go并发模型很强大，但有些编写规则需要了解。否则，很容易踩入“坑”。</li>
<li>垃圾回收，会造成停顿。</li>
</ul>
<h1 id="2_Go语言环境搭建">2 Go语言环境搭建</h1>
<h2 id="安装和设置">安装和设置</h2>
<p>目录：</p>
<ul>
<li>api</li>
<li>bin</li>
<li>doc</li>
<li>misc</li>
<li>pkg</li>
<li>src</li>
<li>test</li>
</ul>
<p>环境变量：</p>
<ul>
<li>GOROOT</li>
</ul>
<h2 id="工程结构">工程结构</h2>
<p>Go是一门推崇软件工程理念的编程语言， 为开发周期的每个环节都提供了完备的工具和支持。</p>
<h3 id="工作区">工作区</h3>
<p>包含3个目录:</p>
<ul>
<li>src</li>
<li>pkg</li>
<li>bin</li>
</ul>
<p>命令源文件: 声明为属于main代码包，有main函数的文件。</p>
<h3 id="GOPATH">GOPATH</h3>
<h3 id="源码文件">源码文件</h3>
<h3 id="代码包">代码包</h3>
<h2 id="标准命令">标准命令</h2>
<ul>
<li>build</li>
<li>clean</li>
<li>install</li>
<li>env</li>
<li>fix</li>
<li>fmt</li>
<li>get</li>
<li>list</li>
<li>run</li>
<li>test</li>
<li>version</li>
</ul>
<p>标记：</p>
<ul>
<li>-a: 强行重新构建所有涉及的Go语言代码包</li>
<li>-n: 使命令指示打印，而不真正执行</li>
<li>-v:</li>
<li>-x</li>
</ul>
<h1 id="3_词法与数据结构">3 词法与数据结构</h1>
<h2 id="基本词法">基本词法</h2>
<p>5类词法元素:</p>
<ul>
<li>标识符</li>
<li>关键字</li>
<li>操作符</li>
<li>分隔符</li>
<li>字面量</li>
</ul>
<p>Go语言的所有源代码必须由Unicode编码规范的UTF-8编码格式编码。</p>
<p>接收操作符:  &lt;-</p>
<h3 id="b表达式">b表达式</h3>
<ul>
<li>基本表达式</li>
<li>选择表达式 .</li>
<li>索引符号和索引表达式</li>
<li>切片表达式： a[x:y:z]</li>
<li>类型断言：v, ok := x.(T)</li>
<li>调用</li>
<li><p>可变长参数： </p>
<p>  func appendIfAbsent(s []string, t …string) [] string<br>  appendIfAbsent([]string{“a”,”b”}, s…)</p>
</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>bool</li>
<li>byte</li>
<li>rune</li>
<li>int/uint</li>
<li>int8/uint8</li>
<li>int16/uint16</li>
<li>int32/uint32</li>
<li>int64/uint64</li>
<li>float32</li>
<li>float64</li>
<li>complex64</li>
<li>complex128</li>
<li>string </li>
</ul>
<h3 id="数组">数组</h3>
<ol>
<li><p>类型表示法: [n]T</p>
</li>
<li><p>值表示法: </p>
<ul>
<li>[6]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
<li>[…]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
</ul>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="切片">切片</h3>
<p>可看做对数组的一种包装形式</p>
<ol>
<li><p>类型表示法: []T</p>
</li>
<li><p>值表示法: []string{“GO”, “Python”}</p>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="字典">字典</h3>
<h3 id="函数与方法">函数与方法</h3>
<h3 id="接口">接口</h3>
<pre><code><span class="typedef"><span class="keyword">type</span> <span class="type">Interface</span> interface <span class="container">{
    <span class="type">Len</span>() <span class="title">int</span>
}</span></span>
<span class="typedef"><span class="keyword">type</span> <span class="type">Sortable</span> interface <span class="container">{
    <span class="title">sort</span>.<span class="type">Interface</span>
    <span class="type">Sort</span>()
}</span></span>
</code></pre><h3 id="结构体">结构体</h3>
<p>type Sequence struct {<br>    len int<br>    cap int<br>}</p>
<h3 id="指针">指针</h3>
<h3 id="数据初始化">数据初始化</h3>
<ul>
<li>new</li>
<li>make: 创建切片类型，字典类型和通道类型的值</li>
</ul>
<h2 id="数据的使用">数据的使用</h2>
<h3 id="赋值">赋值</h3>
<h3 id="常量与变量">常量与变量</h3>
<pre><code>const {
    Sunday = itoa
    Monday
    <span class="keyword">...</span>
}
</code></pre><h3 id="内建函数">内建函数</h3>
<ul>
<li>close: 只接受通道类型的值</li>
<li>len, cap</li>
<li>new, make</li>
<li>append, copy: 用于切片类型</li>
<li>delete: 删除一个字典类型的某个键值对</li>
<li>complex, real, imag</li>
<li>panic, recover</li>
<li>print, println</li>
</ul>
<h1 id="4_流程控制方法">4 流程控制方法</h1>
<h2 id="基本流程控制">基本流程控制</h2>
<ul>
<li><p>代码块和作用域</p>
</li>
<li><p>if</p>
</li>
<li><p>switch</p>
</li>
<li><p>for</p>
</li>
</ul>
<h2 id="defer">defer</h2>
<h2 id="异常处理">异常处理</h2>
<h1 id="5_程序测试与文档">5 程序测试与文档</h1>
<h1 id="6_并发编程综述">6 并发编程综述</h1>
<h1 id="7_Goroutine和Channel">7 Goroutine和Channel</h1>
<h1 id="8_同步">8 同步</h1>
<h1 id="9_一个网络爬虫框架的设计和实现">9 一个网络爬虫框架的设计和实现</h1>
<h1 id="Go语言的学习资料">Go语言的学习资料</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/14/Go并发编程实战/" data-id="bshtpwwoj3zsq9u4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript高级程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/12/javascript高级程序设计/" class="article-date">
  <time datetime="2015-03-12T00:12:57.000Z" itemprop="datePublished">3月 12 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_Javascript简介">1 Javascript简介</h1>
<p>Javascript从一个简单的输入验证器发展成了一门强大的语言。</p>
<p>javascript由三部分组成：</p>
<ul>
<li>核心(ECMAScipt)</li>
<li>文档对象模型(DOM)</li>
<li>浏览器对象模型(BOM)</li>
</ul>
<h1 id="2_在HTML中使用Javascript">2 在HTML中使用Javascript</h1>
<h2 id="使用元素">使用<script>元素</h2>
<p><script>定义了6个属性:</p>
<ul>
<li>async</li>
<li>charset</li>
<li>defer</li>
<li>language. 已废弃</li>
<li>src</li>
<li>type</li>
</ul>
<p>标签的位置一般放在<body>元素中页面内容的后面,为了避免延迟。</p>
<p>使用src属性引用外部脚本。最好的做法是引入外部脚本：</p>
<ul>
<li>可维护性</li>
<li>可缓存</li>
<li>适应未来</li>
</ul>
<h2 id="文档模式">文档模式</h2>
<h2 id="元素"><noscript>元素</h2>
<p>用以在不支持javascipt的浏览器中。</p>
<h1 id="3_基本概念">3 基本概念</h1>
<h2 id="语法">语法</h2>
<ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释</li>
<li>严格模式</li>
<li>语句</li>
<li>关键字和保留字</li>
<li>变量：松散类型</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>5种简单类型：</p>
<ul>
<li>Undefined:只有一个值, undefiend. var声明但未初始化. </li>
<li>Null: 只有一个值: null.</li>
<li>Boolean</li>
<li>Number<ul>
<li>浮点数值</li>
<li>数值范围</li>
<li>NaN</li>
<li></li>
</ul>
</li>
<li>String</li>
</ul>
<p>1种复杂数据类型： Object</p>
<p>typeof操作符， 注意它不是函数</p>
<h2 id="流控制语句">流控制语句</h2>
<h2 id="函数">函数</h2>
<h1 id="4_变量，作用域和内存问题">4 变量，作用域和内存问题</h1>
<h1 id="5_引用类型">5 引用类型</h1>
<h1 id="6_面向对象的程序设计">6 面向对象的程序设计</h1>
<h1 id="7_函数表达式">7 函数表达式</h1>
<h1 id="8_BOM">8 BOM</h1>
<h1 id="9_客户端检测">9 客户端检测</h1>
<h1 id="10_DOM">10 DOM</h1>
<h1 id="11_DOM扩展">11 DOM扩展</h1>
<h1 id="12_DOM2和DOM3">12 DOM2和DOM3</h1>
<h1 id="13_事件">13 事件</h1>
<h1 id="14_表单脚本">14 表单脚本</h1>
<h1 id="15_使用Canvas绘图">15 使用Canvas绘图</h1>
<h1 id="16_HTML5脚本编程">16 HTML5脚本编程</h1>
<h1 id="17_错误处理和调试">17 错误处理和调试</h1>
<h1 id="18_Javascript与XML">18 Javascript与XML</h1>
<h1 id="19_E4X(ECMAScipt_for_XML)">19 E4X(ECMAScipt for XML)</h1>
<h1 id="20_JSON">20 JSON</h1>
<h1 id="21_Ajax与Comet">21 Ajax与Comet</h1>
<h1 id="22_高级技巧">22 高级技巧</h1>
<h1 id="23_离线应用与客户端存储">23 离线应用与客户端存储</h1>
<h1 id="24_最佳实践">24 最佳实践</h1>
<h1 id="25_新兴的API">25 新兴的API</h1>
</script></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/12/javascript高级程序设计/" data-id="yl793uiqyiwu57xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-evernote超效率数字笔记术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/10/evernote超效率数字笔记术/" class="article-date">
  <time datetime="2015-03-10T01:05:14.000Z" itemprop="datePublished">3月 10 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/10/evernote超效率数字笔记术/">evernote超效率数字笔记术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/10/evernote超效率数字笔记术/" data-id="iaqmn1ggdogy709x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ProgrammingInScala" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/ProgrammingInScala/" class="article-date">
  <time datetime="2015-03-07T02:47:36.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/ProgrammingInScala/">Scala编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_可扩展的语言">1 可扩展的语言</h1>
<p>增加新的类型:</p>
<pre><code> scala像一个集市而不是大教堂, 它被设计为可以让使用他的人扩展和修改.
</code></pre><p>增加新的控制结构:</p>
<pre><code> 基于actor的并发模型
</code></pre><h2 id="为何使用scala">为何使用scala</h2>
<p>1 兼容的<br>2 简洁的<br>3 高级的</p>
<pre><code> 程序员总是在与代码的复杂性搏斗.只有对工作的代码了如指掌,才能有的放矢的编程开发.
 复杂的代码成了很多软件项目崩溃的原因.
 不幸的是,重要的软件通常需求复杂.复杂性不可避免,那么必须加强管理.
 scala可以通过帮助提升接口的抽象级别来帮助管理复杂性.
</code></pre><p>4 静态类型的</p>
<pre><code> scala通过类型推断避免了冗余性
 通过模式匹配和一些新的编写和组织类型的办法获得了灵活性.
 静态类型系统可以保证消除某些运行时错误.
</code></pre><h1 id="2_Scala入门初探">2 Scala入门初探</h1>
<p>定义方法时, 如果仅仅包含一条语句, 可以连花括号可以不写.</p>
<p>倾向于函数式的编程风格::</p>
<pre><code>    args.<span class="keyword">foreach</span>( arg =&gt; println(arg ) )
    args.<span class="keyword">foreach</span>( println )
</code></pre><p>scala的数组是通过索引值加圆括号进行访问( 不是方括号)</p>
<p>另一个准则: 方法只有一个参数,调用的时候可以省略点和括号::</p>
<pre><code>    <span class="keyword">for</span>( <span class="keyword">i</span> &lt;- <span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> )
        <span class="keyword">print</span>( greetingString(<span class="keyword">i</span>))
</code></pre><p>用括号传递给变量一个或多个值变量时, Scala会把它转换为对apply方法的调用.</p>
<p>类似有update方法调用.</p>
<p>scala对任何事物都追求概念的简洁性, 从数组到表达式,包括带有方法的对象.</p>
<p>方法没有副作用是函数式风格编程的重要概念.</p>
<p>为何列表不支持append, 性能差</p>
<p>Scala程序员的平衡感:</p>
<pre><code> 崇尚val, 不可变量和没有副作用的方法.
 首先想到他们.只有在特定需要和并加以权衡之后才选择var,可变对象和有副作用的方法.
</code></pre><p>从文件里读取文本行:</p>
<pre><code>    <span class="keyword">for</span>( <span class="built_in">line</span> &lt;- Source.fromFile(<span class="string">"scalaProject.iml"</span>).getLines())
      println( <span class="built_in">line</span>.<span class="built_in">length</span> + <span class="string">" "</span> + <span class="built_in">line</span>)
</code></pre><h1 id="4_类和对象">4 类和对象</h1>
<p>保持对象健壮性的重要方法之一: 保证对象的状态.</p>
<p>scala里方法参数的一个重要特征是他们都是val.</p>
<p>方法的推荐风格是尽量避免return语句, 尤其是多条return语句.</p>
<p>scala通常的风格:把操作符放在行尾和不是行头::</p>
<pre><code>    <span class="title">x</span> +
    y +
    z
</code></pre><p>scala不能定义静态成员,而代之定义单例对象.</p>
<h1 id="5_基本类型和操作">5 基本类型和操作</h1>
<p>值类型: Int,Long,Short,Byte,Float,Double,Char, Boolean<br>String</p>
<p>符号字面值:  ‘&lt;标识符&gt;, Symbol(“cybmbal”)</p>
<p>方法调用的空括号可以省略. 惯例是若方法带有副作用就加上括号, 如pringln(). 若没有副作用,就去掉括号.</p>
<p>scala的==与java有差别.</p>
<p>富包装器.</p>
<h1 id="6_函数式对象">6 函数式对象</h1>
<p>函数式对象: 不具有任何可改变状态的对象的类</p>
<p>不可变对象的缺点: 有时需要负责很大的对象表, 而可变对象的更新可以在原址上发生.</p>
<p>为朱构造器定义先决条件. 用require方法.</p>
<p>不建议在标识符结尾使用下划线.</p>
<p>scala的常量名, 习惯只是第一个字母必须大写.</p>
<p>如果无技巧性地使用, 操作符方法和隐式转换都会让客户代码变得难以阅读和理解.</p>
<p>在设计库的时候你应记在脑袋你的目标并不是仅仅让客户代码简洁, 而是让他变得更可读,更易懂.</p>
<h1 id="7_内建控制结构">7 内建控制结构</h1>
<p>由于while循环不产生值,因此他经常被纯函数式语言所舍弃.</p>
<p>for 过滤:</p>
<pre><code>    val filesHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>) ).listFiles
    <span class="keyword">for</span>( <span class="keyword">file</span> &lt;- filesHere <span class="keyword">if</span> <span class="keyword">file</span>.getname.endsWith(<span class="string">".scala"</span>)
        <span class="keyword">println</span>( <span class="keyword">file</span>)

    <span class="keyword">for</span>( 
        <span class="keyword">file</span> &lt;- filesHere
        <span class="keyword">if</span> <span class="keyword">file</span>.isFile;
        <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
    ) <span class="keyword">println</span>(<span class="keyword">file</span>)
</code></pre><p>嵌套枚举:</p>
<pre><code>    <span class="keyword">def</span> fileLines(<span class="keyword">file</span>: java.io.<span class="keyword">File</span>) =
        scala.io.<span class="keyword">Source</span>.fromFile(<span class="keyword">file</span>).getLines.<span class="keyword">toList</span>

    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span>(
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>);     <span class="comment">//必须有分号;</span>
            line &lt;- fileLines(<span class="keyword">file</span>)
            <span class="keyword">if</span> line.trim.matches(pattern)
        )<span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ line.trim )

    <span class="keyword">grep</span> (<span class="string">".*gcd.*"</span>)
</code></pre><p>可以使用花括号代替小括号包裹发生器和过滤器,优点:可以不写分号.</p>
<p>以上有缺点, line.trim多次计算. 可以使用流间变量绑定::</p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span> {
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
            line &lt;- fileLines(<span class="keyword">file</span>)
            trimmed = line.trim
            <span class="keyword">if</span> trimmed.matches(pattern)
        } <span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ trimmed )
</code></pre><p>制造新集合. 使用yield::</p>
<pre><code>    <span class="keyword">for</span> {  子句 } <span class="keyword">yield</span> { 循环体}
</code></pre><p>抛出异常的类型是Nothing.</p>
<p>catch使用模式匹配::</p>
<pre><code>    <span class="keyword">try</span>{
        val f = <span class="keyword">new</span> FileReader(<span class="string">"input.txt"</span>)
    }<span class="keyword">catch</span>{
        <span class="keyword">case</span> ex:FileNotFoundException =&gt; <span class="comment">// 处理丢失的文件</span>
        <span class="keyword">case</span> ex: IOException =&gt; <span class="comment">//处理io错误</span>
    }
</code></pre><p>finally也产生值.</p>
<p>不再使用break和continue</p>
<p>变量范围::</p>
<pre><code>任何定义在花括号里的东西超出括号之后就脱离了范围. ( <span class="keyword">for</span>子句有例外)
</code></pre><h1 id="8_函数和闭包">8 函数和闭包</h1>
<p>函数式编程风格的重要设计原则: 程序应该被解构成若干小的函数.</p>
<p>本地函数可以访问包含其函数的参数.</p>
<p>函数字面值::</p>
<pre><code>    <span class="function"><span class="params">(x: Int)</span> =&gt;</span> x + <span class="number">1</span>
</code></pre><p>想让函数字面量包含多条语句,可以用花括号包住函数体,一行一语句 ::</p>
<pre><code>    <span class="function"><span class="title">increase</span> = <span class="params">(x: Int)</span> =&gt;</span> {
        println(<span class="string">"We"</span>)
        println(<span class="string">"are"</span>)
        println(<span class="string">"here!)
        x + 1
    }</span>
</code></pre><p>其他例子::</p>
<pre><code>    val someNumbers = List( -<span class="number">11</span>, -<span class="number">10</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)
    someNumbers.foreach<span class="function"><span class="params">(  (x:Int) =&gt; println( x ) )</span>
    <span class="title">someNumbers</span>.<span class="title">filter</span><span class="params">( (x:Int) =&gt; x &gt; <span class="number">0</span> )</span></span>
</code></pre><p>函数字面量的短格式. ( 去除参数类型; 去除括号) ::</p>
<pre><code><span class="attribute">    someNumbers.filter( x </span>=<span class="string">&gt; x &gt; 0 )</span>
</code></pre><p>占位符语法(只要每个参数在函数字面量内仅出现一次)::</p>
<pre><code>    someNumbers.<span class="built_in">filter</span>( _ &gt; <span class="number">0</span> )

    val f = (_: <span class="built_in">Int</span> ) + (_ : <span class="built_in">Int</span> )
    f(<span class="number">5</span>, <span class="number">10</span> )
</code></pre><p>还可以用单个下划线代替整个参数列表::</p>
<pre><code>    someNumbers.foreach( println _ )
    def <span class="built_in">sum</span>(<span class="operator">a</span>: Int, b: Int, c:Int ) = <span class="operator">a</span> + b + c
    val <span class="operator">a</span> = <span class="built_in">sum</span> _
    <span class="operator">a</span>( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )

    val b = <span class="built_in">sum</span>( <span class="number">1</span>, _:Int, <span class="number">3</span> )
</code></pre><p> 写一个省略所以参数偏函数表达式, 如 println <em> 或 sum </em>, 在需要函数的地方可进一步去掉占位符::</p>
<pre><code>    someNumbers.<span class="keyword">foreach</span>( println )

    <span class="comment">//但不能这样写: val c = sum</span>
    val d = sum _   <span class="comment">//必须带占位符</span>
</code></pre><h1 id="9_控制抽象">9 控制抽象</h1>
<h2 id="9-1_减少代码重复">9.1 减少代码重复</h2>
<p>所有的函数都可以被分成通用部分, 以及非通用部分. 通用部分是函数体, 而非通用部分必须由参数提供.</p>
<p>高阶函数: 带其他函数做参数的函数- 给你额外的机会去组织和简化代码.</p>
<p>例如:</p>
<pre><code>    object FileMatcher {
        <span class="keyword">def</span> fileHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>)).listFiles
    <span class="keyword">def</span> filesEnding(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(query))
        yield <span class="keyword">file</span>

    <span class="keyword">def</span> filesContain(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.contains(query))
        yield <span class="keyword">file</span>

    }
</code></pre><p>以上filesEnding和FilesContain结构很像.</p>
<pre><code>    def filesMatching(query:<span class="typename">String</span>, matcher: (<span class="typename">String</span>,<span class="typename">String</span>) =&gt;<span class="typename">Boolean</span>) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> matcher(<span class="keyword">file</span>.getName, query))
        yield <span class="keyword">file</span>
</code></pre><p>那么原来两个方法可以简化为:</p>
<pre><code>    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(query,_.<span class="function">endsWith</span>(_))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(query, _.<span class="function">contains</span>(_))</span>
</code></pre><p>使用闭包可以更短.</p>
<pre><code>    def <span class="function">filesMatching</span>(matcher<span class="value">: String =&gt; Boolean) =
        <span class="function">for</span>(file &lt;- fileHere;</span> if <span class="function">matcher</span>(file<span class="class">.getName</span>))
        yield file

    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))</span>
</code></pre><h2 id="9-2_简化客户代码">9.2 简化客户代码</h2>
<p>例子: 判断是否有负数.</p>
<pre><code>    <span class="function"><span class="keyword">def</span> <span class="title">containsNeg</span><span class="params">( nums: List[Int])</span>:</span>Boolean = {
        var exists = false
        <span class="keyword">for</span>(num&lt;-nums)
        <span class="keyword">if</span> (num&lt;<span class="number">0</span>)
            exists = true
        exists   
    }
</code></pre><p>更简洁的方式, 是使用高阶函数exists:</p>
<pre><code>   def containsNeg(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ &lt; <span class="number">0</span>)
   def containsOdd(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ % <span class="number">2</span> == <span class="number">1</span>) 
</code></pre><h2 id="9-3_柯里化(_currying_)">9.3 柯里化( currying )</h2>
<p>例子：</p>
<pre><code>    <span class="keyword">def</span> plainOldSum(x :<span class="keyword">Int</span>, y: <span class="keyword">Int</span>) = x + y
    plainOldSum(<span class="number">1</span>,<span class="number">3</span>)
    <span class="keyword">def</span> curriedSum(x:<span class="keyword">Int</span>)(y:<span class="keyword">Int</span>)= x + y
    curriedSum(<span class="number">1</span>)(<span class="number">3</span>)
    val first = curriedSum(<span class="number">1</span>)_
    first(<span class="number">3</span>)
</code></pre><h2 id="9-4_编写新的控制结构">9.4 编写新的控制结构</h2>
<p>双倍控制结构:</p>
<pre><code>    <span class="keyword">def</span> twice(op: <span class="keyword">Double</span> =&gt;<span class="keyword">Double</span>, x:<span class="keyword">Double</span>) = op(op(x))
    twice(_ + <span class="number">1</span>, <span class="number">5</span>)
</code></pre><p>代码模式: 打开一个资源, 对它进行操作, 然后释放资源: </p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>: <span class="keyword">File</span>)(op: PrintWriter =&gt; Unit){
        val writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">file</span>)
        <span class="keyword">try</span>{
        op(writer)
        }<span class="keyword">finally</span>{
        writer.close()
        }
    }
    val <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"date.txt"</span>)
    <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>){
        writer =&gt; writer.<span class="keyword">println</span>(<span class="keyword">new</span> java.util.Date)
    }
</code></pre><p>scala的任何方法调用, 如果你确实只传入一个参数, 就能可选地使用花括号替代小括号包围参数.<br>目的: 是让客户程序员写出包围在花括号内的函数字面量,.</p>
<h2 id="9-5_传名参数">9.5 传名参数</h2>
<h1 id="10_组合与继承">10 组合与继承</h1>
<h2 id="10-1_二维布局库">10.1 二维布局库</h2>
<h2 id="10-3_定义无参数方法">10.3 定义无参数方法</h2>
<p>scala鼓励使用不带参数且没有副作用的方法定义为无参数方法的风格, 即省略空括号.<br>无论何时当调用有副作用的方法, 应确保包含一对括号.</p>
<p>scala里的字段和方法属于相同的命名空间.这让字段可以重写无参数方法.</p>
<p>scala仅有两个命名空间:</p>
<ul>
<li>值</li>
<li>类型</li>
</ul>
<h1 id="11_Scala的层级">11 Scala的层级</h1>
<p>Scala中每个类都继承超类Any。在底层还定义了： Null和Nothing。 Nothing是所有其他类的子类。</p>
<h2 id="11-1_Scala的类层级">11.1 Scala的类层级</h2>
<p>Any两子类:</p>
<ul>
<li><p>AnyVal: 内建值类的父类， 有9个子类：</p>
<ul>
<li>Byte</li>
<li>Short</li>
<li>Char</li>
<li>Int</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Unit</li>
</ul>
</li>
<li><p>AnyRef：所有引用类的基类，就是java.lang.Object的别名。还继承自一个名为ScalaObject的特别的记号特质（ 用于编译优化）</p>
</li>
</ul>
<h2 id="11-2_原始类型是如何实现的">11.2 原始类型是如何实现的</h2>
<h2 id="11-3_底层类型">11.3 底层类型</h2>
<p>Null类是null引用对象的类型, 是每个引用类的子类. 不兼容值类型.<br>Nothing类型在Scala的类层次的最底层.</p>
<h1 id="12_特质">12 特质</h1>
<p>特质封装了方法和字段的定义,并可以混入到类中重新定义它们.</p>
<h1 id="13_包和引用">13 包和引用</h1>
<p>做程序的时候, 使耦合最小化是很重要的. 减小耦合性的方式之一是使用模块化的风格编写代码.</p>
<h1 id="13-1_包">13.1 包</h1>
<p>scala采用java平台完整的包机制.</p>
<ol>
<li><p>和java相同:</p>
<p> package bobosrockets.navigtion<br> class Navigtor</p>
</li>
<li><p>像C#的命名空间:</p>
<p> package bobosrockets {</p>
<pre><code> <span class="keyword">package</span> navigtion{
     <span class="class"><span class="keyword">class</span> <span class="title">Navigtor</span></span>
     <span class="keyword">package</span> tests{
         <span class="class"><span class="keyword">class</span> <span class="title">NavigtorSuite</span></span>
     }
 }
</code></pre><p> }</p>
</li>
</ol>
<p>顶层包: <em>root</em></p>
<h1 id="13-2_引用">13.2 引用</h1>
<p>import子句让包活对象的成员可以子句通过名称访问而不是通过前缀包访问.<br>例子:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets._</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit._</span>
</code></pre><p>Scala的引用可以出现在任何地方.</p>
<p>可以引用包本身.</p>
<p>可以重命名或隐匿成员:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple =&gt; McIntosh, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.{Date =&gt; SDate}</span>

<span class="preprocessor"><span class="keyword">import</span> Fruits.{Pear =&gt; _, _ }  // 引用了Fruits的所有成员,但Pear除外</span>
</code></pre><h1 id="13-3_隐式引用">13.3 隐式引用</h1>
<p>Scala为每个程序隐式地添加一些引用:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> java.lang._</span>
<span class="preprocessor"><span class="keyword">import</span> scala._</span>
<span class="preprocessor"><span class="keyword">import</span> Predef._</span>
</code></pre><h1 id="13-4_访问修饰符">13.4 访问修饰符</h1>
<p>private[X] 表示”直到”X的私有保护.</p>
<p>private[this]标记的定义仅能在包含了定义同一个对象中被访问.</p>
<p>类的所有访问权限都对伴生对象开放,反过来也是如此.</p>
<h1 id="14_断言和单元测试">14 断言和单元测试</h1>
<h1 id="21_隐式转换和参数">21 隐式转换和参数</h1>
<p>隐式转换只是普通的方法, 但它一修饰符implicit开始.</p>
<p>例子:</p>
<pre><code>    implicit def stringWrpper(<span class="keyword">s</span>: String) = 
            new RandomAccessSe<span class="string">q[Char]</span>  {
            def <span class="keyword">length</span> = <span class="keyword">s</span>.<span class="keyword">length</span>
            def apply(i: Int) = <span class="keyword">s</span>.charAt(i)
    }
</code></pre><p>优点:</p>
<ul>
<li>免费获取所有其它RandomAccessSeq的方法</li>
<li>支持目标类型的转换</li>
</ul>
<p>隐性定义是指编译器为了修正类型错误而允许插入到程序中的定义.<br>例如: 若 x + y不能通过类型检查, 编译器可能会把它改为convert(x) + y</p>
<p>标记规则: 只有标记为implicit的定义才是可用的.</p>
<p>作用域规则: 插入的隐性转换必须以单一标识符的形式处于作用域中,或与转换的源或目标类型关联在一起.</p>
<p>无歧义规则: 隐式转换唯有不存在其他可插入转换的前提下才能插入.</p>
<p>单一调用规则: 只会尝试一个隐式操作, 编译器不会把 x +y 重写成convert1(convert2(x)) + y.</p>
<p>显式操作先行规则: 若编写的代码类型检查无误, 则不会尝试任何隐式操作.</p>
<p>命名隐式转换.</p>
<p>隐式操作在哪里尝试:</p>
<ul>
<li>转换为期望类型</li>
<li>指定(方法)调用者的转换</li>
<li>隐式参数</li>
</ul>
<p>被所有Scala程序隐式引用的scala.Predef对象, 定义了把”较小的”数值类型转变为”较大的”类型的隐式转换.</p>
<h2 id="转换为方法的接受者">转换为方法的接受者</h2>
<p>例子:</p>
<pre><code>    class Rational(n: Int, d: Int) {
        <span class="keyword">...</span>
        def + (that: Rational): Rational = <span class="keyword">...</span>
        def + (that: Int): Rational = <span class="keyword">...</span>
    }
</code></pre><p>执行：</p>
<pre><code>scala&gt; <span class="number">1</span> + oneHalf
&lt;console&gt;:<span class="number">6</span>: error: overloaded <span class="function"><span class="keyword">method</span> <span class="title">value</span> + <span class="title">with</span>
<span class="title">alternatives</span> <span class="params">(Double)</span><span class="title">Double</span> &lt;<span class="title">and</span>&gt; ... <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span>

<span class="title">scala</span>&gt; <span class="title">implicit</span> <span class="title">def</span> <span class="title">intToRational</span><span class="params">(x: Int)</span> = <span class="title">new</span> <span class="title">Rational</span><span class="params">(x, 1)</span>
<span class="title">intToRational</span>:</span> (x: Int)Rational

scala&gt; <span class="number">1</span> + oneHalf
res2: Rational = <span class="number">3</span>/<span class="number">2</span>
</code></pre><h2 id="模拟新的语法">模拟新的语法</h2>
<p>例子:</p>
<pre><code>    <span class="built_in">Map</span>(<span class="number">1</span> <span class="subst">-&gt;</span><span class="string">"one"</span>, <span class="number">2</span> <span class="subst">-&gt;</span><span class="string">"two"</span>, <span class="number">3</span> <span class="subst">-&gt;</span><span class="string">"three"</span>)
</code></pre><p>“-&gt;”不是内建语法, -&gt;只是定义在标准Scala中类ArrowAssoc的方法, 定义了Any到ArrowAssoc的隐式转化.<br>编写 1-&gt;”one”的时候, 编译器会插入1到ArrowAssoc的转换以便找到-&gt;方法.</p>
<pre><code>    package scala
    object Predef {
        class ArrowAssoc[A](x: A) {
            def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)
        }
        implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
        new ArrowAssoc(x)
        <span class="keyword">...</span>
    }
</code></pre><h2 id="隐式参数">隐式参数</h2>
<p>编译器有时会用someCall(a)(b)替换somCall(a) 或者用new someCall(a)(b)替换new someCall(a).<br>从而通过添加缺失参数列表以满足函数调用.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/ProgrammingInScala/" data-id="n7l1932ui6el72wb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-scala快学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/scala快学/" class="article-date">
  <time datetime="2015-03-07T01:10:50.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/scala快学/">快学scala</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_基础">1 基础</h1>
<h2 id="scala解释器">scala解释器</h2>
<h2 id="声明值和变量">声明值和变量</h2>
<p>变量或函数的类型总是写在变量或函数名称的后面。 使得我们更容易阅读那些负责类型的声明。</p>
<pre><code><span class="keyword">val</span> greeting: String = <span class="keyword">null</span>
<span class="keyword">val</span> greeting: Any = <span class="string">"Hello"</span>
</code></pre><p>可以将多个值或变量放在一起声明:</p>
<pre><code>val xmax, ymax = <span class="number">100</span> <span class="comment">//将xmax和ymax设为100</span>
valgreeting, message: <span class="built_in">String</span> = <span class="literal">null</span>
</code></pre><h2 id="常用类型">常用类型</h2>
<p>7种数值类型： Byte, Char, Short, Int, Long, Float和Double, Boolean</p>
<p>不需要包装类型，基本类型和包装类型自己的转换是scala编译器的工作。</p>
<p>在scala中，我们用方法，而不是强制类型转换， 来做数值类型之间的转换：</p>
<pre><code><span class="number">99.44</span>.toInt <span class="comment">//= 99</span>
<span class="number">99.</span>toChar   <span class="comment">//='c'</span>
</code></pre><h2 id="算术和操作符重载是">算术和操作符重载是</h2>
<p>“a 方法 b”  是 “a.方法(b)” 的简写</p>
<p>scala没有++， — 操作符</p>
<h2 id="apply方法">apply方法</h2>
<p>“hello”(4)是”hello”.apply(4)的缩写。</p>
<p>使用伴生对象的apply方法。</p>
<h2 id="Scaladoc">Scaladoc</h2>
<p>www.scala-lang.org/api<br>或者www.scala-lang.org/downloads#api</p>
<p>类名旁边的O(伴生对象）和C（类）</p>
<p>scala文档小窍门:</p>
<ul>
<li>想使用数值类型， 记得看看RichInt, RichDouble等， 字符串，记得看看StringOps.</li>
<li>数值函数位于scala.math包中。</li>
<li>名称比较奇怪的函数。 如BigInt有个方法unary_-, 就是你定义前置的负操作符-x的方式</li>
<li>标记位implicit的方法对应的是自动（隐式）转换。</li>
<li>方法可以以函数为常数</li>
</ul>
<h1 id="2_控制结构和函数">2 控制结构和函数</h1>
<h2 id="变长参数">变长参数</h2>
<p>使用Int<em>, 若传入的数组后面要加上”:_</em>“转换</p>
<pre><code>def sum(args:<span class="type">Int</span>*) = {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="number">0</span>
  <span class="keyword">for</span>(arg &lt;- args) <span class="literal">result</span> += arg
  <span class="literal">result</span>
}
val s = sum(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>)
val s2 = sum(<span class="number">1</span> to <span class="number">10</span>: _*)
</code></pre><h2 id="懒值">懒值</h2>
<p>但val被声明为lazy时，它的初始化将被推迟，直到我们首次对它取值。</p>
<p>lazy val words = scala.io.Source.fromFile(“/usr/share/dict/words”).mkString</p>
<h2 id="异常">异常</h2>
<p>throws表达式有特殊的类型Nothing.</p>
<h1 id="3_数组相关操作">3 数组相关操作</h1>
<p>要点：</p>
<ul>
<li>长度固定使用Array， 长度可能变化用ArrayBuffer</li>
<li>提供初始值不用使用new</li>
<li>用()来访问元素</li>
<li>用for(elem &lt;- arr)来遍历元素</li>
<li>用for(elem &lt;- arr if …)… yeild .. 来将原数组转型为新数组</li>
<li>scala数组和Java数组可以互操作；用ArrayBuffer, 使用scala.collection.JavaConversions中的转换函数。</li>
</ul>
<h2 id="与java的互操作">与java的互操作</h2>
<p>转成java的List:</p>
<pre><code>import scala.collection.JavaConversions.bufferAsJavaList
val <span class="command"><span class="keyword">command</span> = <span class="title">ArrayBuffer</span>(<span class="string">"ls"</span>, <span class="string">"-la"</span>, <span class="string">"/home/"</span>)</span>
val pb = <span class="built_in">new</span> ProcessBuilder(<span class="command"><span class="keyword">command</span>)</span>
</code></pre><p>将java的List转成BufferArray:</p>
<pre><code>import scala.collection.JavaConversions.asScalaBuffer
<span class="keyword">val</span> cmd:<span class="keyword">mutable</span>.Buffer[String] = pb.command()
</code></pre><h1 id="4_映射和元组">4 映射和元组</h1>
<pre><code>val scores <span class="subst">=</span> <span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
val ms <span class="subst">=</span> scala<span class="built_in">.</span>collection<span class="built_in">.</span>mutable<span class="built_in">.</span><span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
println(scores(<span class="string">"Bob"</span>))
println(scores<span class="built_in">.</span>getOrElse(<span class="string">"yuqiao"</span>, <span class="number">0</span>))
</code></pre><p>与Java的互操作：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap</span>
</code></pre><p>使用zip:</p>
<pre><code>val symbols = Array(<span class="string">"&lt;"</span>, <span class="string">"-"</span>, <span class="string">"&gt;"</span>)
val counts = Array(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)
val <span class="built_in">pairs</span> = symbols.zip(counts)
<span class="keyword">for</span>((k,v)&lt;-<span class="built_in">pairs</span>){
  <span class="built_in">print</span>(k*v)
}
</code></pre><p>使用toMap将对偶集合转换成映射Map.</p>
<h1 id="5_类">5 类</h1>
<p>要点:</p>
<ul>
<li>类中字段自动带有getter和setter方法</li>
<li>可以用定制的getter/setter方法替换掉字段的定义</li>
<li>用@BeanProperty注解来生成JavaBeans的getXXX/setXXX方法</li>
<li>每个类都有一个主要的构造器, 它的参数直接成为类的字段。</li>
<li>辅助构造器是可选的， 叫做this.</li>
</ul>
<p>定义类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>{
    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span>
    <span class="keyword">def</span> increment() { value +=<span class="number">1</span>}
    <span class="keyword">def</span> current() = value
}

<span class="keyword">val</span> myCounter = <span class="keyword">new</span> Counter
myCounter.increment()        <span class="comment">//对改值器使用()</span>
println(myCounter.current)   <span class="comment">//对取值器不使用()</span>
</code></pre><p>在scala中， getter和setter分别是age和age_=</p>
<p>统一访问原则</p>
<p>对象私有字段</p>
<p>Bean属性</p>
<p>主构造器:</p>
<pre><code><span class="keyword">class</span> Person(val name:String, val age: <span class="keyword">Int</span>) {

<span class="keyword">def</span> <span class="keyword">description</span> = name + <span class="string">" is "</span> + age + <span class="string">" years old"</span>
}
</code></pre><p>Martin Odesky建议: 在scala中, 类也接受参数， 就像方法一样。</p>
<p>嵌套类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(val name:String)</span></span>{
        <span class="keyword">val</span> contacts = <span class="keyword">new</span> ArrayBuffer[Member]()
    }

    <span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> ArrayBuffer[Member]()

    <span class="keyword">def</span> join(name:String)={
        <span class="keyword">val</span> m = <span class="keyword">new</span> Member(name)
        members += m
        m
    }
}

<span class="keyword">val</span> chatter = <span class="keyword">new</span> Network
<span class="keyword">val</span> myFace = <span class="keyword">new</span> Network
</code></pre><p>每个实例都有它自己的Member类。chatter.Member和myFace.Member是不同的类。</p>
<p>可以放在Network的伴生对象。</p>
<h1 id="6_对象">6 对象</h1>
<p>scala没有静态方法或静态字段， 可以用object这个语法结构达到同样目的。</p>
<p>枚举通过扩展Enumeration实现：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrafficColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>{
    <span class="keyword">type</span> TrafficColor = Value
    <span class="keyword">val</span> Red, Yellow, Geen = Value
}

<span class="keyword">def</span> doWhat(color: TrafficColor) ={
  <span class="keyword">if</span>(color == Red)  <span class="string">"stop"</span>
  <span class="keyword">else</span> <span class="keyword">if</span>(color==Geen) <span class="string">"go"</span>
  <span class="keyword">else</span> <span class="string">"hurry up"</span>
}

<span class="keyword">def</span> testEnum(): Unit = {
  <span class="keyword">for</span>(c &lt;- TrafficColor.values) println(c.id + <span class="string">":"</span> + c + <span class="string">" "</span> + doWhat(c))
}
</code></pre><h1 id="7_包和引入">7 包和引入</h1>
<p>要点:</p>
<ul>
<li>包也可以像内部类那样嵌套</li>
<li>包路径不是绝对路径</li>
<li>包声明链x.y.z并不自动将中间包x.y变成可见</li>
<li>位于文件顶部不带花括号的包声明在整个文件范围内有效</li>
<li>包对象可以持有函数和变量</li>
<li>引入语句可以引入包，类和对象</li>
<li>引入语句可以出现在任何地方</li>
<li>引入语句可以重命名和隐藏特定成员</li>
<li>java.lang, scala和predef总是被引入</li>
</ul>
<h1 id="8_继承">8 继承</h1>
<p>要点:</p>
<ul>
<li>extends, final关键字和java相同</li>
<li>重写方法必须用override</li>
<li>只有主构造器可以钓鱼超类的主构造器</li>
<li>你可以重写字段</li>
</ul>
<p>类型检查和转换:</p>
<pre><code><span class="keyword">if</span>(p.isInstanceOf[Employee]){
    val s = p.asInstanceOf[Employee]
    <span class="keyword">...</span>
}
</code></pre><p>若想测试p指向的是一个Employee对象但又不是其子类：</p>
<pre><code><span class="keyword">if</span>(p.getClasss == <span class="class"><span class="keyword">class</span><span class="title">Of</span>[<span class="title">Employee</span>])</span>
</code></pre><p>classOf定义在scala.Predef对象中。</p>
<p>模式匹配通常是更好的选择：</p>
<pre><code>p match {
    case s:Employee =&gt; <span class="keyword">...</span> // 将s作为Employee处理
    case _ =&gt; // p 不是Employee
}
</code></pre><p>超类的构造：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(name: String, age: Int, val salary: Double)</span><span class="keyword">extends</span> <span class="title">Person</span><span class="params">(name, age)</span></span>
</code></pre><p>可以用val重写抽象def. 但def只能重写def, var只能重写另一个抽象的var</p>
<p>匿名子类：</p>
<pre><code>val alien = <span class="keyword">new</span> Person(<span class="string">"Fred"</span>) {
    <span class="keyword">def</span> greeting = <span class="string">"Greetings, Earthinling! My name is Fred!"</span>
}

<span class="keyword">def</span> meet(p: Person{<span class="keyword">def</span> greeting: String}){
    <span class="keyword">println</span>(p.name +<span class="string">"says: "</span> + p.greeting)
}
</code></pre><p>抽象类：用abstract标记不能实例化的类。</p>
<p>重写超类的抽象方法， 不需要override.</p>
<p>类可以有抽象字段。</p>
<p>构造顺序和提前定义。 </p>
<p>提前定义， 让你可以在超类的构造器之前初始化子类的val字段：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Ant</span> <span class="keyword">extends</span> </span>{
    <span class="keyword">override</span> <span class="keyword">val</span> range = <span class="number">2</span>
} <span class="keyword">with</span> Creature
</code></pre><h2 id="Scala继承层级">Scala继承层级</h2>
<p>基本类型和Unit， 都扩展自AnyVal<br>类都扩展自AnyRef.</p>
<p>AnyVal和AnyRef的基类是Any。Any是根节点.</p>
<p>Any类定义了isInstanceOf, asInstanceOf方法， 以及用于相等性判断和哈希码的方法<br>AnyRef追加了来着Object类的jai</p>
<h1 id="9_文件和正则表达式">9 文件和正则表达式</h1>
<h1 id="10_特质">10 特质</h1>
<h1 id="11_操作符">11 操作符</h1>
<h1 id="12_高阶函数">12 高阶函数</h1>
<h1 id="13_集合">13 集合</h1>
<h1 id="14_模式匹配和样例类">14 模式匹配和样例类</h1>
<h1 id="15_注解">15 注解</h1>
<h1 id="16_XML处理">16 XML处理</h1>
<h1 id="17_类型参数">17 类型参数</h1>
<h1 id="18_高级类型">18 高级类型</h1>
<h1 id="19_解析">19 解析</h1>
<h1 id="20_Actor">20 Actor</h1>
<h1 id="21_隐式转换和隐式参数">21 隐式转换和隐式参数</h1>
<h1 id="22_定界延续">22 定界延续</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/scala快学/" data-id="vbw899bc9g9rfzk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scalao/">scalao</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何记笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/04/如何记笔记/" class="article-date">
  <time datetime="2015-03-04T06:30:39.000Z" itemprop="datePublished">3月 4 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/04/如何记笔记/">如何记笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="记笔记的目的">记笔记的目的</h1>
<ul>
<li>加深记忆, 稳定心绪. (看书有时候看不进去，通过记笔记，可以稳定心绪)</li>
<li>系统整理书的知识体系</li>
<li>看笔记就能想起书的内容, 可以完整反应书本内容， 可以扔掉原书</li>
</ul>
<h1 id="方法">方法</h1>
<ol>
<li><p>一本书应该被读两遍，而且只读两遍。</p>
<ul>
<li>第一步正常通读，放松欣赏</li>
<li>第二遍写下读书笔记，可以供以后重温，直接看笔记即可</li>
</ul>
</li>
<li><p>按照原书的章节给读书笔记划分章节，甚至保留各章的标题. 写下每章作者到底想说什么。<br>写出作者的逻辑脉络。</p>
</li>
<li><p>颜色和字体的变化可以起到自动突出重点和分类的作用。</p>
</li>
<li><p>要注意给将来使用搜索引擎留下线索。也就是说要把关键字，人名地名组织名等记好</p>
</li>
<li><p>主动式的阅读。在笔记中写下自己对此书的评论。统一做法是把自己的评论全部放在方括号【】中。</p>
</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li>用强力研读书: <a href="http://www.geekonomics10000.com/376" target="_blank" rel="external">http://www.geekonomics10000.com/376</a></li>
<li>三遍读书法: <a href="http://www.codeceo.com/article/how-i-read-programming-books.html" target="_blank" rel="external">http://www.codeceo.com/article/how-i-read-programming-books.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/04/如何记笔记/" data-id="h0er2ax0f7tpdgt7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/如何记笔记/">如何记笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-p专业主义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/p专业主义/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/p专业主义/">专业主义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>专业,你唯一的生存之道.</p>
<h1 id="前言_预言将自我实现">前言 预言将自我实现</h1>
<p>大前研一强调”希波克拉底誓言”对于企业职业价值的意义.<br>我们并不是因为专业技术成为专家, 而是因为”向上帝发誓, 以此为职业” - 把顾客作为出发点而成为专家.</p>
<p>专家阶层的势力迟早会增强, 并动摇日本的产业界.</p>
<p>在职业化的时代，自由竞争越来越健全，真正拥有实力的人越来越受到推崇。</p>
<p>预言: 人人都能成为专家.</p>
<p>你凭什么胜出？<br>未来能够牵动世界大势的，是个人之间的竞争。<br>能否独霸世界舞台，锻造他人无法超越的核心竞争力。<br>你唯一的依恃，就是专业。</p>
<p>你够专业吗？<br>专业不是职业，职业人士不同于专家。<br>细微的差别，却是成败的关键。</p>
<p>真正的专家具备四种能力:</p>
<ul>
<li>先见能力</li>
<li>构思能力</li>
<li>讨论的能力</li>
<li>适应矛盾的能力</li>
</ul>
<h1 id="1-_你够专业吗?">1. 你够专业吗?</h1>
<p>专家要控制自己的情感, 并靠理性而行动. 他们不仅具备较强的专业知识和技能以及较强的理念,<br>而且无一例外地以顾客为第一位,具有无穷的好奇心和永无止境的进取心,严格遵守纪律.<br>以上条件全部具备的人才, 才能成为专家.</p>
<h2 id="专家的定义">专家的定义</h2>
<p>一种健康的危机感正在蔓延, 大家感到”国家和社会已经靠不住了”, 提升自身价值的现象正在萌芽.</p>
<h2 id="被遗忘的”对顾客的誓言”">被遗忘的”对顾客的誓言”</h2>
<p>专家的词源本身”profess”, 意思是”向上帝发誓,以此为职业”</p>
<p>希波克拉底誓言:</p>
<ol>
<li>请允许我行医,我要终生奉行人道主义.</li>
<li>向恩师表达尊敬和感谢之意.</li>
<li>在行医过程中严守良心和尊严.</li>
<li>以患者的健康与生命放在第一位.</li>
<li>严格为患者保守秘密.</li>
<li>保持医学界的名誉与宝贵的传统.</li>
<li>把同事视为兄弟, 不因患者的人种,宗教国籍和社会地位的不同而区别对待.</li>
<li>从受孕之始,即把人的生命作为至高无上之物来尊重.</li>
<li>无论承受怎样的压力, 在运用自己的知识时也不会违背人道主义.</li>
</ol>
<p>企业通过商品与服务销售誓言,那是百分之百地让你满意,顾客购买的就是这种誓言.</p>
<h2 id="顾客无处不在">顾客无处不在</h2>
<p>官僚就是公仆, 所谓”官僚主义”,应该可以理解为为社会和他人献身,但现在这个词被赋予贬义,真是一种讽刺.</p>
<p>“你的工资是顾客给的”. </p>
<p>通过考虑顾客的顾客,可以把目标领域扩展到其他行业, 这就为重新审视现有的方法提供了契机,并且有可能赢得机会,<br>为直接的客户停供独特的价值.</p>
<p>那些仅仅按照公司的规定采取行动的人,不仅无法称之为专家,而且也不利于公司的发展.因此我们应该铭记,<br>从事任何工作都有首先确定自己的顾客,并发誓为顾客作出贡献.</p>
<h2 id="关于授权的误解">关于授权的误解</h2>
<p>被授予权利,行动获得自由后, 人们容易任意行事.这一现象是由于只强调授权的一面,专业主义这辆车的两个车轮未能同时运转.</p>
<p>有几个问题:</p>
<ul>
<li>权限扩大了, 你能够给顾客提供怎样的价值?</li>
<li>你自身具备使用新权力的能力和技能吗?</li>
<li>能力和技能不足, 无法熟练运用新的权力时,你该怎么办?</li>
</ul>
<p>追求权力容易, 但要保持权利则非常困难.</p>
<p>如果感到自己确实需要权力,并且能够运用手中的权力为顾客服务, 我们就应该去争取权力,而不是等待上司授予自己权力.</p>
<p>授权者应在认清下属的能力和技能并考虑此人今后发展的基础上,确定合适的权限范围;把握下属现有的能力水平与权限所要求的能力水平之间的差距,<br>做好亲自缩短这种差距的准备, 然后再把权力交给下属.当然,切记不要连累顾客.</p>
<p>所谓授权,就是对下属进行投资.</p>
<p>专家能够不断创造事业机会。</p>
<p>对顾客而言, 上司和下属的关系是无所谓的, 专家必须经常考虑顾客的利益.</p>
<h2 id="不断学习,_乐此不彼">不断学习, 乐此不彼</h2>
<p>我们需要这样的专家, 他们从基础知识开始进行系统学习, 亲身实践.对新事物反复消化并不断积累经验;<br>经过持续的训练,他们能够把之间学到的知识提供给别人.</p>
<p>绝不认为自己的本领是绝对的, 而是准备花费一生的时间去磨砺自己,并且乐此不彼.</p>
<p>要想获得成功,先要期盼成功,对自己能够获得成功充满自信.与此同时,如果在自信的背后没有好奇心作为助推器提供动力,<br>是无法达到一流境界的.这一点可以说是区分非凡与平凡的决定性因素.</p>
<h2 id="保有好奇心">保有好奇心</h2>
<p>好奇心不足的人,也就是怠慢自己智慧的人,他们几乎无一例外地属于自我防卫型,对变化采取抵制的态度.</p>
<p>不要怠慢自己的智慧.适可而止的心态不仅对本人,对周围的人也是有害的.</p>
<p>浅尝辄止地完成工作,是无法称为专家.</p>
<h2 id="纪律的力量">纪律的力量</h2>
<p>无论如何完善教育制度,如何增加报酬和改善福利, 也不会产生大批的专家.<br>只有纪律—或者称之为价值观更准确些,才能培养出专家.</p>
<p>对专家而言,是不允许妥协的.所谓”妥协”,指的是只考虑自己的情况, 而无视顾客与商业伙伴的利益,凡事过于乐观.</p>
<p>需要专家在”方向”与”程度”方面给出恰如其分的建议.</p>
<p>在21世纪的经济社会中, 我们要与”看不见的空间”作战.我们需要运作的不再是看得见的人或组织;<br>我们的工作是占领看不见的经济领域,打败其中的人或组织(有时可能是自己公司以外了的人或组织, 有时可能是<br>非特定的多数人或组织).</p>
<p>无论前提条件发生多大的变化,都能够认清深层变化的本质,比别人发挥出更大的能力,这样的人才是专家.</p>
<h1 id="2-_先见能力">2. 先见能力</h1>
<p>今后的时代所需要的先见能力, 是能够看清别人看不到的事物的能力.</p>
<h2 id="看不见的新大陆">看不见的新大陆</h2>
<p>眼睛看不见,手触不到的无形的活动将成为主流.过去辉煌的成功经验不仅不再起作用,甚至会成为发展的瓶颈.</p>
<p>工业化社会的经济是有形的,这种有形的经济虽然没有被废弃, 但已经不再是主流.</p>
<p>在”看不见的新大陆”上开展的生存竞争是毫不留情的. 既没有乞怜于人的时间,也看不到能够接受乞求的人.</p>
<h2 id="战略论的功与过">战略论的功与过</h2>
<p>如今的时代,依靠某些精英学习最新理论,制定战略并严格按照战略进行实践,这种做法已经无法推动企业的发展.</p>
<p>宝丽来失败的根本原因是什么?答案就是固守成功的模式.</p>
<p>战略: 制定规划,使自己的公司与竞争对手之间相对力量关系的变化朝着有利于自己公司高效变化的方向发展.</p>
<p>改变这种力量的三种方法:</p>
<ul>
<li>基于成功的关键因素(KFS)的战略. 可以将资源集中于KFS, 凭借自己公司的股份与收益等优势获胜.</li>
<li>基于相对优势的战略. 着眼于竞争条件的不同,以确保优势. </li>
<li>推动新规划的战略. 积极开拓竞争对手所不涉足的业务,开辟市场.</li>
</ul>
<p>战略论分为两种: </p>
<ul>
<li>定位论</li>
<li>核心竞争力理论</li>
</ul>
<p>这些理论是以稳定发展的工业化社会为背景的: 商品经济无论多么复杂,发展得多么迅速, 我们都能捕捉到商品,竞争和市场的动向,<br>在开发新产品的服务以及开拓新业务时,能够具体把握目标客户与市场.</p>
<p>但20世纪末的十几年间,作为战略论前提的顾客,市场,竞争等因素已不再具有固定的定义.</p>
<p>我们应该铭记一点: 那就是依靠固有的模式与陈旧的知识解释史无前例的现象,这种做法将会给事业的发展带来危害.</p>
<h2 id="在正确的时间做正确的事情">在正确的时间做正确的事情</h2>
<p>如今的时代,改写经济常识的并不一定是实力强大的组织,个人也完全有可能做到.</p>
<p>在新大陆中, 以往的战略论已不再适用, 但还是有不少人获得了成功,这是因为他们充分认清了新大陆的本质.<br>我们只能在新的竞争领域的彼岸遥望他们的生硬, 但沿着他们走过的道路前进则毫无意义.</p>
<p>错过了时机, 便不会成功.更何况在”看不见的新大陆”上, 经济环境的变化与20世纪相比加快了数倍,<br>谨慎被动的对企业与国家而言都将导致致命的损失.</p>
<p>推动未来世界运转的, 是个体之间的竞争, 而不再是国家之间或企业之间的竞争. 优秀的个体之间的竞争<br>转瞬之间便能改变世界.类似1990的托沃兹,具备世界一流才能的人,不知会从何处现身.</p>
<h2 id="先见能力的蜕变">先见能力的蜕变</h2>
<p>今后时代需要的先见能力,是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>纵观事业获得成功的诸多示例,给人留下的印象是这些事业都很富有先见性,并且都按照预言家的预言发展的.<br>在这些事例的背后, 我们自始至终都能看到同样的成功模式:</p>
<ol>
<li>明确定义事业领域(范围).</li>
<li>从分析现状入手预测未来的方向, 可简明扼要地阐明假想的论点, 以分析其因果关系.</li>
<li>在可能有多种选择的情况下, 只精选其中的几种.在推行所选择的方案时,采取强制的方法调配人,<br>财,物等方面资源.</li>
<li>不要迷失假说的基本方向, 不要偏离原则, 除非情况彻底发生变化.</li>
</ol>
<p>当时需要不是天才的灵感, 也不是预言家的素质,而是对一系列的逻辑过程毫不松懈地落实的执行能力:<br>定义事业领域, 从分析现状入手, 预测将来的方向.<br>但今后的时代需要的先见能力, 是能够看清眼睛看不到的事物的能力.<br>任何人都能预见到的事业是不会再有什么发展的.</p>
<p>所以不能简单依靠现有的战略论和过去的成功经验, 重要是把精力集中在不断认识前人未曾涉及的世界,<br>并磨练自觉的资质上.</p>
<h2 id="怀疑一切">怀疑一切</h2>
<p>要想学习没有常识的世界中的新常识, 即21世界的规则, 首先必须有意识地让自己习惯对命苦玉溪的一个个常识提出质疑.</p>
<p>众所周知, 人类的大脑具备这样的功能, 它会把新的信息与”过去的经验或积累的部分知识”相对照, 然后加以调整并接受.<br>如果眼前新的现实与大脑中的存储的固有信息无法协调, 便会在无意识中拒绝新的现实(当做没看见);<br>或者通过子句一知半解的知识任意推测,使自己认识到的情况偏离实际(产生错觉).<br>这是人类的一种本能, 目的在于使自己保持冷静.</p>
<p>20世纪充满常识, 而21世纪是一个无常识可言,而且会突然发生变化的时代.<br>若被旧世界的常识所束缚, 就无法在瞬间抓住并正确理解新世界中的新事实,更不可能预见到新的事业.</p>
<p>人的大脑有一种习性, 那就是”只能看到想看的东西”, 因此我们需要特别注意从成功的体验中得到的知识和理论.<br>有可能并不再适用.</p>
<p>知识来自先驱者们的研究与经验,是在反复试验, 反复失败的摸索中获得的.如果已经得到明确的知识, 则说明这块领域已被<br>无数人造访过,已毫无商机可言.<br>此后的商务专家必须比以前更加怀疑常识,并抛弃现有的知识, 也就是坚决养成”不学习”的习惯.</p>
<p>怀疑常识并不是毫无想法, 而是有意识地假设一个相反的观点, 并不断地反复验证, 把20世纪的学习变成一个破坏i类极具<br>创造性的”不学习”的过程.</p>
<p>只有对”看不见的新大陆”有所预见,才能确保自己不会丢掉工作, 获得丰厚的薪水.抛弃先例,养成怀疑常识的习惯,获得洞悉变化本质的能力—<br>即使说这一切是商务专家的生命线,也绝不过分.</p>
<h2 id="享受变化">享受变化</h2>
<p>只有具备享受变化与失败的素质,或者说是从容镇定的心情,好奇心和气魄, 才能成为”打破规则者”, 才可能带来变化.</p>
<p>在新的经济空间里, 对所从事的事业进行取舍是成败的关键. 这需要人们在自己的头脑中一边想象一边完成,<br>因为我们无法依靠别人创造的模式对事业的成败进行取舍.</p>
<p>我们只有经历无数次的失败,遍体鳞伤, 才能学会在新的竞争领域中较为实用的生存技能.</p>
<p>惧怕风险, 企图逃避风险, 这样做是为了种族延续, 是生物的本能.向未知的领域挑战是先驱者们的任务, 也是企业家的乐趣.<br>新的竞争领域就在眼前, 我毫无惧色,因为我能够经常预感到变化, 心情愉快地以失败为食粮拓展自己的世界,<br>对此我感到非常地自豪.</p>
<p>在任何地方, 被称为名人或高手的人大体上都具备: 慎重和大胆两方面的素质.</p>
<h2 id="不怕失败,执着探索">不怕失败,执着探索</h2>
<p>回避争论, 不习惯争论, 对于具备国际水准的专家而言, 是致命的弱点.</p>
<p>害怕新的竞争领域, 不敢投身其中, 是永远也无法掌握新领域的规则的, 而且也无法继续生存下去.</p>
<p>怠于思考的人是无法否定一切的. 他们惧怕失败, 因此不想承认自己是错误的.坦率地承认自己的错误, 意味着对思考永不厌倦.</p>
<p>在向新的竞争领域迈进时, 应具备以假象为支柱反复试验, 不怕失败的姿态. 换言之, 即使失败,也要勇往直前, 坚信下次一定能成功,<br>这种执着的精神是我们的附身符之一.</p>
<p>要认清变化的本质, 首先对身边的变化逐一反复地向自己提问:为什么会这样, 新在什么地方, 从中会产生什么, 其真正的价值何在.<br>然后从中确定课题, 建立假说, 搜集事实一认清这一假说,并进行分析和验证, 重新构建自己的观点.</p>
<h2 id="偏执狂的危机感">偏执狂的危机感</h2>
<p>一个高水平的偏执狂正因为具备了紧张感, 他的感受力才很强.才能通过其卓越的洞察力施展自己的行动能力.</p>
<p>比尔盖茨说过:”如果今天我的决策失误一次, 这家公司明天就会倒闭.如今我依然有这种危机感.”</p>
<p>格鲁夫:”只有偏执狂才能生存.”. 偏执狂: 对组织,对他人的思想或行动抱有怀疑态度.<br>只有那些总以为自己的经营环境危机四伏并时刻关注各种”坏消息”的企业,才有可能免于灭亡.</p>
<p>成功的背后必定潜藏着危机.</p>
<p>未曾开发的新竞争领域前途莫测. 因为不了解, 我们对任何情况都感到非常紧张,这种紧张感能够唤醒我们的知觉, 提高我们对事物的洞察力.<br>分析问题的速度与应对危机的能力.</p>
<p>如果是享受变化, 执着探索以及不效仿20世纪是在”看不见的新大陆”生存必不可少的条件,那么紧张感, 也就是积极的猜疑心理,<br>便是磨砺先见能力的”强心剂”.在”看不见的新大陆”上, 我们需要这种”强心剂”发挥作用, 否则我们便无法跟上变化的速度.</p>
<h2 id="磨练自觉能力">磨练自觉能力</h2>
<h2 id="对事业倾注全力">对事业倾注全力</h2>
<h2 id="“看不见的新大陆”为何看不见">“看不见的新大陆”为何看不见</h2>
<h1 id="3-_构思能力">3. 构思能力</h1>
<h2 id="仅有先见能力是不够的">仅有先见能力是不够的</h2>
<h2 id="成功的必要条件和充分条件">成功的必要条件和充分条件</h2>
<h2 id="把握变化的速度和规模">把握变化的速度和规模</h2>
<h2 id="电子商务的三个关键点">电子商务的三个关键点</h2>
<h2 id="设定满足8亿人市场的标准">设定满足8亿人市场的标准</h2>
<h2 id="未雨绸缪">未雨绸缪</h2>
<h2 id="“and”还是”or”">“and”还是”or”</h2>
<h2 id="勇于自我否定">勇于自我否定</h2>
<h2 id="视成功为过去时">视成功为过去时</h2>
<h2 id="追求”深度经济”">追求”深度经济”</h2>
<h1 id="4-_讨论的能力">4. 讨论的能力</h1>
<h2 id="避免对企业发展无益的讨论">避免对企业发展无益的讨论</h2>
<h2 id="符合逻辑的思考vs-符合逻辑的讨论">符合逻辑的思考vs.符合逻辑的讨论</h2>
<h2 id="讨论的能力可以后天养成">讨论的能力可以后天养成</h2>
<h2 id="逻辑是全球唯一的通用语">逻辑是全球唯一的通用语</h2>
<h2 id="确保提问符合逻辑">确保提问符合逻辑</h2>
<h2 id="倾听的能力与说服的能力">倾听的能力与说服的能力</h2>
<h2 id="不可掉入诡辩的陷阱">不可掉入诡辩的陷阱</h2>
<h2 id="尽情讨论,直到权威者发话">尽情讨论,直到权威者发话</h2>
<h2 id="符合逻辑的反驳">符合逻辑的反驳</h2>
<h2 id="亚里士多德的逻辑学">亚里士多德的逻辑学</h2>
<h2 id="成功始于坚定的信念">成功始于坚定的信念</h2>
<h1 id="5-_适应矛盾的能力">5. 适应矛盾的能力</h1>
<h2 id="企业经营没有唯一的最佳答案">企业经营没有唯一的最佳答案</h2>
<h2 id="经营中包含的矛盾">经营中包含的矛盾</h2>
<h2 id="解决问题的能力与沟通的能力">解决问题的能力与沟通的能力</h2>
<h2 id="集权与分权">集权与分权</h2>
<h2 id="全球化与本地化">全球化与本地化</h2>
<h2 id="竞争与顾客">竞争与顾客</h2>
<h2 id="自由与统帅">自由与统帅</h2>
<h2 id="左脑与右脑">左脑与右脑</h2>
<h1 id="结语">结语</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/p专业主义/" data-id="zwjtonorw13p8bap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/管理/">管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java核心技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/java核心技术/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/java核心技术/">java核心技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_流与文件">1. 流与文件</h1>
<h2 id="流">流</h2>
<p>输入流</p>
<p>输出流</p>
<p>抽象类：InputStream和OutputStream</p>
<h1 id="2-_XML">2. XML</h1>
<h1 id="3-_网络">3. 网络</h1>
<h1 id="4-_数据库编程">4. 数据库编程</h1>
<h1 id="5-_国际化">5. 国际化</h1>
<h1 id="6-_高级swing">6. 高级swing</h1>
<h1 id="7-_高级AWT">7. 高级AWT</h1>
<h1 id="8-_JavaBean构件">8. JavaBean构件</h1>
<h1 id="9-_安全">9. 安全</h1>
<h1 id="10-_脚本，编译与注解处理">10. 脚本，编译与注解处理</h1>
<h1 id="11-_分布式对象">11. 分布式对象</h1>
<h1 id="12-_本地方法">12. 本地方法</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/java核心技术/" data-id="g4fg92x6t3nqeuwt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript权威指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/18/javascript权威指南/" class="article-date">
  <time datetime="2015-02-17T23:57:09.000Z" itemprop="datePublished">2月 18 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/18/javascript权威指南/">javascript权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Javascript概述">1. Javascript概述</h1>
<p>Javascript是面向Web的编程语言。</p>
<p>前端工程师必须掌握的三大技能: </p>
<ul>
<li>描述网页内容的HTML </li>
<li>描述网页样式的css </li>
<li>描述网页行为的Javascript</li>
</ul>
<p>Firefox的插件Firebug: <a href="http://getfirebug.com/" target="_blank" rel="external">http://getfirebug.com/</a></p>
<p>F12唤醒Firefox操作面板 Ctrl+Shift+J唤醒错误控制台(Error Console).</p>
<h2 id="Javascript语言核心">Javascript语言核心</h2>
<p>变量和赋值：</p>
<pre><code><span class="title">var</span> x;
<span class="title">x</span> = <span class="number">0</span>;

<span class="title">x</span>
x = <span class="number">1</span>;
<span class="title">x</span> = <span class="number">0</span>.<span class="number">01</span>;
<span class="title">x</span> = <span class="string">"hello world"</span>;
<span class="title">x</span> = <span class="string">'hello world'</span>;
<span class="title">x</span> = <span class="built_in">true</span>;
<span class="title">x</span> = null;
<span class="title">x</span> = undefined;
</code></pre><p>复杂类型:</p>
<pre><code><span class="keyword">var</span> book = {
    topic: <span class="string">"Javascript"</span>,
    fat: <span class="keyword">true</span>
};

book.topic
book[<span class="string">'fat'</span>]
book.author = <span class="string">'Flanagan'</span>;
book.content = {};

<span class="keyword">var</span> primes = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];
primes[<span class="number">0</span>]
primes.length
primes[primes.length -<span class="number">1</span> ]
primes[<span class="number">4</span>] = <span class="number">9</span>;  <span class="comment">// 通过赋值添加新元素</span>
primes[<span class="number">4</span>] = <span class="number">11</span>;
<span class="keyword">var</span> <span class="keyword">empty</span> = []
<span class="keyword">empty</span>.length

<span class="keyword">var</span> points = [
    {x:<span class="number">0</span>, y:<span class="number">0</span>},
    {x:<span class="number">1</span>, y:<span class="number">1</span>}
];

<span class="keyword">var</span> data = {
    trial1: [ [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],
    trial2: [ [<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]
}
</code></pre><p>表达式：</p>
<pre><code><span class="number">3</span> + <span class="number">2</span>
<span class="number">3</span> - <span class="number">2</span>
<span class="number">3</span> * <span class="number">2</span>
<span class="number">3</span> / <span class="number">2</span>                           <span class="comment">// =&gt; 1.5</span>
points[<span class="number">1</span>].x - points[<span class="number">0</span>].x  
<span class="string">"3"</span> + <span class="string">"2"</span>                       <span class="comment">// =&gt; "32" </span>

<span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span>;
<span class="built_in">count</span> ++;
<span class="built_in">count</span> --;
<span class="built_in">count</span> += <span class="number">2</span>;
<span class="built_in">count</span> *= <span class="number">3</span>;
<span class="built_in">count</span>

<span class="keyword">var</span> x=<span class="number">2</span>, y=<span class="number">3</span>;
x == y
x != y
x &lt; y
<span class="string">"two"</span> &gt; <span class="string">"three"</span>

(x == <span class="number">2</span>) &amp;&amp; (y==<span class="number">3</span>)
</code></pre><p>函数:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">plus1</span><span class="params">(x)</span></span>{
    reutrn x +<span class="number">1</span>;
}
plus1(y)

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{
    <span class="keyword">return</span> x * x;
};

square(plus1(y))
</code></pre><p>将函数和对象合写在一起， 方法：</p>
<pre><code><span class="keyword">var</span> a = [];
a.push(<span class="number">1</span>, <span class="number">2</span> <span class="number">3</span>);
a.reverse();

<span class="comment">// "this"关键字是对定义方法对象的引用</span>
points.dist = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> p1 = <span class="keyword">this</span>[<span class="number">0</span>];
    <span class="keyword">var</span> p2 = <span class="keyword">this</span>[<span class="number">1</span>];
    <span class="keyword">var</span> a = p2.x - p1.x
    <span class="keyword">var</span> b = p2.y - p2.y;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(a*<span class="number">2</span> + b*b ）
points.dist()
</code></pre><p>控制语句：</p>
<pre><code><span class="keyword">function</span> abs(x) {
    <span class="keyword">if</span>(x &gt;=<span class="number">0</span>){
        <span class="keyword">return</span> x;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> -x;
    }
}

//<span class="keyword">...</span>    
    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i+){
        //<span class="keyword">...</span>
    }
    <span class="keyword">while</span>(true){
        //<span class="keyword">...</span>
    }
</code></pre><p>对象：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
}
<span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);

Point.prototype.r = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(
        <span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y);
    };
p.r();
</code></pre><h1 id="2-_词法结构">2. 词法结构</h1>
<h1 id="3-_类型，值和变量">3. 类型，值和变量</h1>
<h1 id="4-_表达式和运算符">4. 表达式和运算符</h1>
<h1 id="5-_语句">5. 语句</h1>
<h1 id="6-_对象">6. 对象</h1>
<p>对象是一种复合值: 将很多值聚合在一起， 可通过名字访问这些值。</p>
<p>对象可以看做属性的无序集合，每个属性都是一个名/值对。</p>
<p>属性名是字符串，因此我们可以吧对象看成从字符串到值的映射。</p>
<p>对象不仅仅是字符串到值的映射，除了可以保持自有的属性，对象还可以从一个称为原型的对象继承属性。<br>对象的方法通常是继承的属性。</p>
<p>“原型式继承”是Javascript的核心特征。</p>
<h2 id="创建对象">创建对象</h2>
<p>三种方式.</p>
<h3 id="对象直接量">对象直接量</h3>
<pre><code><span class="keyword">var</span> <span class="keyword">empty</span> = {}
<span class="keyword">var</span> point = {x:<span class="number">0</span>, y:<span class="number">0</span>}
<span class="keyword">var</span> book = {
    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,
    <span class="string">"sub-title"</span>:<span class="string">"The Definitive Guide"</span>
}
</code></pre><h3 id="new创建对象">new创建对象</h3>
<pre><code><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个空对象， 和{}一样</span>
<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个空数组, 和[]一样</span>
<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); 
<span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>);
</code></pre><p>除了这些内置构造函数， 也可以自定义构造函数来初始化新对象。</p>
<h3 id="原型">原型</h3>
<pre><code><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create({x:<span class="number">1</span>, y:<span class="number">2</span>}) <span class="comment">// o1 继承了属性x和y</span>
<span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype) <span class="comment">// o3 和 {} 一样</span>
</code></pre><p>可以通过任何原型创建对象:</p>
<p>function inherit(p){<br>    if(p==null) throw TypeError();<br>    if(Object.create) return Object.create(p);<br>    var t= typeof p;<br>    if(t!== “object”&amp;&amp; t!== “function”) throw TypeError();<br>    fucntion f() {} // 定义一个空构造函数<br>    f.prototype = p;<br>    return new f();<br>}</p>
<h2 id="属性的查询和设置">属性的查询和设置</h2>
<p>通过.和[]来获取属性的值。</p>
<p>Javascript对象都是关联数组。</p>
<p>属性访问错误，会抛出一个类型错误异常。</p>
<p>避免错误的方法:</p>
<pre><code><span class="keyword">var</span> <span class="built_in">len</span> = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;
</code></pre><h2 id="删除属性">删除属性</h2>
<p>delete book.author<br>delete book[“main title”]</p>
<h2 id="检测属性">检测属性</h2>
<h2 id="枚举属性">枚举属性</h2>
<p>for/in循环可以在循环体中遍历对象中所有可枚举的属性。<br>对象继承的内置方法是不可枚举的。<br>d但在代码中给对象添加的属性是可枚举的。</p>
<h2 id="属性getter和setter">属性getter和setter</h2>
<h2 id="属性的特征">属性的特征</h2>
<p>除了包含名字和值之外，属性还包含一些标识他们可写，可枚举和可配置的特性。</p>
<h2 id="对象的三个属性">对象的三个属性</h2>
<p>每个对象都有与之相关的原型(prototype), 类(class)和可扩展性().</p>
<h2 id="序列化对象">序列化对象</h2>
<h2 id="对象方法">对象方法</h2>
<h1 id="7-_数组">7. 数组</h1>
<h1 id="8-_函数">8. 函数</h1>
<p>函数即对象。</p>
<h2 id="函数定义">函数定义</h2>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">distance</span><span class="params">(x1, y1, x2, y2)</span></span>{
    <span class="keyword">var</span> dx = x2 - x1;
    <span class="keyword">var</span> dy = y2 - y1;
    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);
}

<span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{<span class="keyword">return</span> x*x;}

<span class="comment">// 函数表达式可以包含名称</span>
<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(x)</span> </span>{ <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x * faxt(x-<span class="number">1</span>);};

data.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>{<span class="keyword">return</span> a-b;});
</code></pre><p>嵌套函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span><span class="params">(a,b)</span></span>{
    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(x)</span></span>{<span class="keyword">return</span> x*x;}
    reurn <span class="built_in">Math</span>.sqrt(square(a) +square(b));
}
</code></pre><h2 id="函数调用">函数调用</h2>
<p>有四种方式.</p>
<h3 id="函数调用-1">函数调用</h3>
<h3 id="方法调用">方法调用</h3>
<h1 id="9-_类和模块">9. 类和模块</h1>
<h1 id="10-_正则表达式的模式匹配">10. 正则表达式的模式匹配</h1>
<h1 id="11-_Javascript的子集和扩展">11. Javascript的子集和扩展</h1>
<h1 id="12-_服务端Javascript">12. 服务端Javascript</h1>
<h1 id="13-_Web浏览器中的Javascript">13. Web浏览器中的Javascript</h1>
<h1 id="14-_windows对象">14. windows对象</h1>
<h1 id="15-_脚本化文档">15. 脚本化文档</h1>
<h1 id="16-_脚本化css">16. 脚本化css</h1>
<h1 id="17-_事件处理">17. 事件处理</h1>
<h1 id="18-_脚本化http">18. 脚本化http</h1>
<h1 id="19-_JQuery类库">19. JQuery类库</h1>
<h1 id="20-_客户端存储">20. 客户端存储</h1>
<h1 id="21-_多媒体和图形编程">21. 多媒体和图形编程</h1>
<h1 id="22-_HTML5_API">22. HTML5 API</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/18/javascript权威指南/" data-id="r2tcz3rjcn12u8oj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Erlang/" style="font-size: 10.00px;">Erlang</a><a href="/tags/Ice/" style="font-size: 10.00px;">Ice</a><a href="/tags/Vim/" style="font-size: 10.00px;">Vim</a><a href="/tags/golang/" style="font-size: 10.00px;">golang</a><a href="/tags/hadoop/" style="font-size: 13.33px;">hadoop</a><a href="/tags/hbase/" style="font-size: 10.00px;">hbase</a><a href="/tags/java/" style="font-size: 16.67px;">java</a><a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a><a href="/tags/node/" style="font-size: 10.00px;">node</a><a href="/tags/program/" style="font-size: 10.00px;">program</a><a href="/tags/scalao/" style="font-size: 10.00px;">scalao</a><a href="/tags/think/" style="font-size: 10.00px;">think</a><a href="/tags/tool/" style="font-size: 13.33px;">tool</a><a href="/tags/分布式系统/" style="font-size: 10.00px;">分布式系统</a><a href="/tags/如何记笔记/" style="font-size: 10.00px;">如何记笔记</a><a href="/tags/笔记/" style="font-size: 20.00px;">笔记</a><a href="/tags/管理/" style="font-size: 10.00px;">管理</a><a href="/tags/读书笔记/" style="font-size: 10.00px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
          </li>
        
          <li>
            <a href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
          </li>
        
          <li>
            <a href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
          </li>
        
          <li>
            <a href="/2015/03/10/evernote超效率数字笔记术/">evernote超效率数字笔记术</a>
          </li>
        
          <li>
            <a href="/2015/03/07/ProgrammingInScala/">Scala编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Peter Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>
