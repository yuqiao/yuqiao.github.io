<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Joe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="enjoy life">
<meta property="og:type" content="website">
<meta property="og:title" content="Joe's Blog">
<meta property="og:url" content="http://yuqiao.github.io/">
<meta property="og:site_name" content="Joe's Blog">
<meta property="og:description" content="enjoy life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joe's Blog">
<meta name="twitter:description" content="enjoy life">

  
    <link rel="alternative" href="/atom.xml" title="Joe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Carpe Diem</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yuqiao.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-代码的未来" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/19/代码的未来/" class="article-date">
  <time datetime="2015-03-19T08:06:04.000Z" itemprop="datePublished">3月 19 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/代码的未来/">代码的未来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/19/代码的未来/" data-id="6kzq8e5d3084oda1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/program/">program</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解JVM虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/17/深入理解JVM虚拟机/" class="article-date">
  <time datetime="2015-03-17T09:29:50.000Z" itemprop="datePublished">3月 17 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_走近Java">1. 走近Java</h1>
<h2 id="1-1_概述">1.1 概述</h2>
<p>Java不仅仅是一门编程语言, 它还是一个由一系列计算机软件和规范形成的技术体系.</p>
<p>java优点:</p>
<ul>
<li>结构严谨, 编写对象</li>
<li>摆脱了硬件平台的束缚</li>
<li>提供了相对安全的内存管理和访问机制, 避免绝大部分的内存泄露和指针越界问题</li>
<li>实现了热点代码检测和运行时编译及优化, 使java应用随着运行时间的增加而获取更高的性能</li>
<li>有一套完善的应用程序接口, 还有无数第三方类库</li>
</ul>
<h2 id="1-2_Java技术体系">1.2 Java技术体系</h2>
<p>Sun官方定义的Java技术体系:</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机</li>
<li>Class文件格式</li>
<li>Java API类库</li>
<li>第三方Java类库</li>
<li>实现了热点代码检测和运行时编译及优化, 使java应用随着运行时间的增加而获取更高的性能</li>
<li>有一套完善的应用程序接口, 还有无数第三方类库</li>
</ul>
<h2 id="1-3_Java发展史">1.3 Java发展史</h2>
<h2 id="1-4_展望Java技术的未来">1.4 展望Java技术的未来</h2>
<h3 id="模块化">模块化</h3>
<h3 id="混合语言">混合语言</h3>
<h3 id="多核并发">多核并发</h3>
<h2 id="1-5_实战:_自己编译JDK">1.5 实战: 自己编译JDK</h2>
<h1 id="2-_Java_内存区域与内存溢出异常">2. Java 内存区域与内存溢出异常</h1>
<h2 id="2-2_运行时数据区域">2.2 运行时数据区域</h2>
<ul>
<li><p>执行引擎</p>
</li>
<li><p>本地库接口</p>
</li>
<li><p>运行时数据区域</p>
<ul>
<li>方法区 Method Area， 用以存储虚拟机加载的类信息， 常量，静态变量，即时编译器编译后的代码等数据. </li>
<li>堆 Heap</li>
<li>程序计数器 Program Couter Register</li>
<li>虚拟机栈 VM Stack</li>
<li>本地方法栈 Native method Stack</li>
</ul>
</li>
<li><p>直接内存</p>
</li>
</ul>
<h3 id="程序计数器">程序计数器</h3>
<p>一块较小的内存空间, 作用可以看做是当前线程所执行的字节码的行号指示器.<br>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.<br>分支, 循环, 跳转,异常处理, 线程恢复等基础功能需要这个计数器来完成.</p>
<p>每条线程都有自己一个独立的程序计数器. “线程私有”的内存.</p>
<h3 id="Java虚拟机栈">Java虚拟机栈</h3>
<p>线程私有.</p>
<p>描述的是java方法执行的内存模型: 每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表,<br>操作数栈,动态链接, 方法出口等信息.<br>每一个方法被调用直至执行完成的过程, 就对应着在虚拟机栈中从入栈到出栈的过程.</p>
<h3 id="Java虚拟机栈-1">Java虚拟机栈</h3>
<p>线程私有.<br>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.<br>分支, 循环, 跳转,异常处理, 线程恢复等基础功能需要这个计数器来完成.</p>
<p>每条线程都有自己一个独立的程序计数器. “线程私有”的内存.</p>
<h3 id="Java堆">Java堆</h3>
<p>采用分代收集算法。 堆可细分为：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>划分的目的：更好地回收内存，更快地分配内存</p>
<p>-Xms, -Xmx 来配置堆大小。</p>
<h2 id="OutOfMemoryError异常">OutOfMemoryError异常</h2>
<h3 id="Java堆溢出">Java堆溢出</h3>
<p>配置：</p>
<ul>
<li>-Xms</li>
<li>-Xmx</li>
<li>-XX:+HeapDumpOnOutOfMemeoryError</li>
</ul>
<p>堆溢出时， 异常堆栈信息”java.lang.OutOfMemoryError”会进一步提示”java heap space”</p>
<p>解决该异常：</p>
<ul>
<li>通过内存映象分析工具对dump出来的堆转储快照进行分析。</li>
<li>若是内存泄露， 进一步通过该工具查看泄露对象打GC Roots的引用链，从而找到泄露对象是通过怎样的路径与GC Roots相关联而导致无法垃圾收集。</li>
<li>若不存在泄露， 需要检查虚拟机的堆参数（-Xms，-Xmx)</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3>
<p>栈容量由-Xss参数设定。</p>
<p>由两类异常：</p>
<ul>
<li>线程请求的深度大于虚拟机所允许的最大深度， 抛出StackOverflowError异常</li>
<li>虚拟机在扩展栈是无法申请到足够的内存空间， 抛出OutOfMemoryError</li>
</ul>
<h3 id="运行时常量池异常/方法区溢出">运行时常量池异常/方法区溢出</h3>
<p>溢出时， 异常堆栈信息”java.lang.OutOfMemoryError”会进一步提示”PermGen space”</p>
<p>配置：</p>
<ul>
<li>-XX:PermSize</li>
<li>-XX:MaxPermSize</li>
</ul>
<h1 id="3-_垃圾收集器与内存分配策略">3. 垃圾收集器与内存分配策略</h1>
<h2 id="对象已死？">对象已死？</h2>
<h3 id="引用计数算法">引用计数算法</h3>
<p>很难解决对象之间的相互引用的问题。</p>
<h3 id="根搜索算法">根搜索算法</h3>
<p>GC Roots Tracing 判定对象是否存活。</p>
<p>基本思路：</p>
<pre><code>通过一系列名为<span class="string">"GC Roots"</span>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为”引用链“(Reference Chain). 
当一个对象到GC <span class="keyword">Roots</span>没有任何引用链相连，则证明此对象是不可用的。被判定为可回收对象。
</code></pre><h3 id="Java引用">Java引用</h3>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h3 id="生存还是死亡？">生存还是死亡？</h3>
<p>根搜索不可达的对象， 并非是”非死不可”, 暂时处于缓刑阶段。要真正宣告对象死亡， 至少经历两次标记。</p>
<ol>
<li>根搜索不到， 第一次标记</li>
<li>是否有必要执行finalize()方法， 第二次标记。</li>
</ol>
<p>被判定有必要执行finalize()方法， 对象会被添加名为F-Queue的对了之中， 并在稍后有一条虚拟机自动建立的低优先级的Finalize线程执行。<br>若某个对象在finalize()方法中死循环，那么F-Queue后面的对象都将永久处于等待状态。</p>
<p>永久代的垃圾收集主要回收两部分内容： 废弃常量和无用的类。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<h3 id="标记-清除算法">标记-清除算法</h3>
<p>标记出所需要回收的对象，在标记完成后统一回收掉。 </p>
<p>缺点:</p>
<ul>
<li>效率问题: 标记和清除的效率不高</li>
<li>空间问题: 产生大量不连续的内存碎片</li>
</ul>
<h3 id="复制算法">复制算法</h3>
<p>将可用的内存按容量划分为大小相等的两块，每次使用其中一块。当这块内存用完，将存活的对象复制到另一块上面，然后在把已使用的内存空间一次清理掉。</p>
<p>代价： 可用内存缩小到原来的一半。</p>
<p>使用这种方式来回收新生代， 因为新生代的对象98%是朝生夕死的。</p>
<p>实际划分： 一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden空间和一块Survivor. 回收时讲Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上。</p>
<p>一般Eden:Survivor空间之比是8：1， 那么空间浪费只有10%。</p>
<p>若Survivor空间没有足够的空间存放上一次新生代存活下来的对象， 那么这些对象通过分配担保机制进入老年代。</p>
<h3 id="标记-整理算法">标记-整理算法</h3>
<p>让所有存活的对象向一段移动，然后清理端边界以外的内存。</p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>根据对象的存活周期不同将内存划分为几块。根据各个年代的特点采用最恰当的收集算法。</p>
<h2 id="垃圾收集器">垃圾收集器</h2>
<p>垃圾收集器是内存回收的具体实现。</p>
<h3 id="Serial收集器">Serial收集器</h3>
<h1 id="4-_虚拟机性能监控与故障处理工具">4. 虚拟机性能监控与故障处理工具</h1>
<h2 id="jps">jps</h2>
<ul>
<li>-l</li>
<li>-m</li>
</ul>
<h2 id="jstat">jstat</h2>
<p>例子</p>
<pre><code><span class="tag">jstat</span> <span class="tag">-gcutil</span> <span class="attr_selector">[进程id]</span> <span class="attr_selector">[毫秒数]</span> <span class="attr_selector">[打印次数]</span>

<span class="attr_selector">[admin@v189230231.sqa.zmf ~]</span>$ <span class="tag">jstat</span> <span class="tag">-gcutil</span> 6671 250 10
<span class="tag">S0</span>     <span class="tag">S1</span>     <span class="tag">E</span>      <span class="tag">O</span>      <span class="tag">P</span>     <span class="tag">YGC</span>     <span class="tag">YGCT</span>    <span class="tag">FGC</span>    <span class="tag">FGCT</span>     <span class="tag">GCT</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.18</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
20<span class="class">.86</span>   0<span class="class">.00</span>  59<span class="class">.54</span>   7<span class="class">.79</span>  32<span class="class">.03</span>    448    9<span class="class">.656</span>     0    0<span class="class">.000</span>    9<span class="class">.656</span>
</code></pre><p>说明：</p>
<ul>
<li>S0: Survivor 0</li>
<li>S1: Survivor 1</li>
<li>E: Eden空间</li>
<li>O: Old 老年代</li>
<li>YGC: 新生代gc 次数</li>
<li>YGCT:  新生代gc 时间. 单位为秒</li>
<li>FGC： full gc 次数</li>
<li>FGCT： full gc 时间</li>
</ul>
<h2 id="jstack">jstack</h2>
<h1 id="5-_调优案例分析与实战">5. 调优案例分析与实战</h1>
<h1 id="6-_类文件结构">6. 类文件结构</h1>
<h1 id="7-_虚拟机类加载机制">7. 虚拟机类加载机制</h1>
<h1 id="8-_虚拟机字节码执行引擎">8. 虚拟机字节码执行引擎</h1>
<h1 id="9-_类加载及执行子系统的案例与实战">9. 类加载及执行子系统的案例与实战</h1>
<h1 id="10-_早期(编译期)优化">10. 早期(编译期)优化</h1>
<h1 id="11-_晚期(编译期)优化">11. 晚期(编译期)优化</h1>
<h1 id="12-_Java内存模型与线程">12. Java内存模型与线程</h1>
<h1 id="13-_线程安全与锁优化">13. 线程安全与锁优化</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/17/深入理解JVM虚拟机/" data-id="0l16szcs6cqupp2w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-思考，快与慢" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/15/思考，快与慢/" class="article-date">
  <time datetime="2015-03-15T06:50:05.000Z" itemprop="datePublished">3月 15 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一_系统1，_系统2">一 系统1， 系统2</h1>
<h1 id="1_一张愤怒的脸和一张乘法题">1 一张愤怒的脸和一张乘法题</h1>
<h1 id="2_电影的主角和配角">2 电影的主角和配角</h1>
<h1 id="3_惰性思维和延迟满足的矛盾">3 惰性思维和延迟满足的矛盾</h1>
<h1 id="4_联想的神奇力量">4 联想的神奇力量</h1>
<h1 id="5_你的直觉有可能是错觉">5 你的直觉有可能是错觉</h1>
<h1 id="6_意料之外与情理之中">6 意料之外与情理之中</h1>
<h1 id="7_字母“B”和数字“13”">7 字母“B”和数字“13”</h1>
<h1 id="8_我们究竟是如何作出判断的">8 我们究竟是如何作出判断的</h1>
<h1 id="9_目标问题与启发性问题形影不离">9 目标问题与启发性问题形影不离</h1>
<h1 id="二_启发性与偏见">二 启发性与偏见</h1>
<h1 id="10_大数法则与小数定律">10 大数法则与小数定律</h1>
<h1 id="11_锚定效应在生活中随处可见">11 锚定效应在生活中随处可见</h1>
<h1 id="12_科学地利用可得性启发法">12 科学地利用可得性启发法</h1>
<h1 id="13_焦虑情绪与风险政策的设计">13 焦虑情绪与风险政策的设计</h1>
<h1 id="14_猜一下，汤姆的专业是什么">14 猜一下，汤姆的专业是什么</h1>
<h1 id="15_琳达问题的社会效应">15 琳达问题的社会效应</h1>
<h1 id="16_因果关系比统计学信息更有说服力">16 因果关系比统计学信息更有说服力</h1>
<h1 id="17_所有表现都会回归平均值">17 所有表现都会回归平均值</h1>
<h1 id="18_如何让自觉性预测更恰当有效">18 如何让自觉性预测更恰当有效</h1>
<h1 id="三_过度自信与决策错误">三 过度自信与决策错误</h1>
<h1 id="19_“知道”的错觉">19 “知道”的错觉</h1>
<h1 id="20_未来是不可预测">20 未来是不可预测</h1>
<h1 id="21_直觉判断与公式运算，_孰优孰劣">21 直觉判断与公式运算， 孰优孰劣</h1>
<h1 id="22_什么时候可以相信专家的直觉？">22 什么时候可以相信专家的直觉？</h1>
<h1 id="23_努力养成采纳外部意见的决策习惯">23 努力养成采纳外部意见的决策习惯</h1>
<h1 id="24_乐观主义是一把双刃剑">24 乐观主义是一把双刃剑</h1>
<h1 id="四_选择与风险">四 选择与风险</h1>
<h1 id="25_事关财富和风险的选择">25 事关财富和风险的选择</h1>
<h1 id="26_更人性化的前景理论">26 更人性化的前景理论</h1>
<h1 id="27_禀赋效应与市场交易">27 禀赋效应与市场交易</h1>
<h1 id="28_公平性_—_经济交易的参照物">28 公平性 — 经济交易的参照物</h1>
<h1 id="29_对结果可能性的权衡">29 对结果可能性的权衡</h1>
<h1 id="30_被过分关注的罕见事件">30 被过分关注的罕见事件</h1>
<h1 id="31_能带来长远收益的风险政策">31 能带来长远收益的风险政策</h1>
<h1 id="32_心理账户是如何影响我们的选择的？">32 心理账户是如何影响我们的选择的？</h1>
<h1 id="33_评估结果的逆转">33 评估结果的逆转</h1>
<h1 id="34_善用框架效应，让生活更美好">34 善用框架效应，让生活更美好</h1>
<h1 id="五_两个自我">五 两个自我</h1>
<h1 id="35_体验效用于决策效用的不一致">35 体验效用于决策效用的不一致</h1>
<h1 id="36_人生如戏">36 人生如戏</h1>
<h1 id="37_你有多幸福">37 你有多幸福</h1>
<h1 id="38_思考生活">38 思考生活</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/15/思考，快与慢/" data-id="br7hz20kqfycig0p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/think/">think</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go并发编程实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/14/Go并发编程实战/" class="article-date">
  <time datetime="2015-03-14T10:54:05.000Z" itemprop="datePublished">3月 14 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_初识Go语言">1 初识Go语言</h1>
<h2 id="Go语言特性">Go语言特性</h2>
<ul>
<li>开放源代码</li>
<li>虽为静态类型，编译型语言，但Go语言的语法趋于脚本化，非常简洁。</li>
<li>卓越的跨平台支持</li>
<li>全自动的垃圾回收机制</li>
<li>原生的先进并发编程模型和机制</li>
<li>拥有函数式编程范式的特性，函数为一等代码块</li>
<li>无继承层次的轻量级面向对象编程范式</li>
<li>内涵完善，全面的软件工程共计</li>
<li>代码风格强制统一。</li>
<li>程序编译和运行程序都非常快</li>
<li>标准库丰富</li>
</ul>
<h2 id="Go语言优缺点">Go语言优缺点</h2>
<p>优点：</p>
<ul>
<li>相对于c/c++来讲，Go语言拥有清晰的依赖管理和全自动的垃圾回收机制</li>
<li>相对于Java而言，Go语言拥有简明的类型系统， 函数式编程和先进的并发编程类型: 代码更小更简洁,可重用性</li>
<li>性能比脚本语言快</li>
</ul>
<p>缺点：</p>
<ul>
<li>分布式计算，成熟度不比Erlang</li>
<li>程序运行速度，与java不相上下，但不比c</li>
<li>第三方库，不比java, python, ruby.</li>
<li>go并发模型很强大，但有些编写规则需要了解。否则，很容易踩入“坑”。</li>
<li>垃圾回收，会造成停顿。</li>
</ul>
<h1 id="2_Go语言环境搭建">2 Go语言环境搭建</h1>
<h2 id="安装和设置">安装和设置</h2>
<p>目录：</p>
<ul>
<li>api</li>
<li>bin</li>
<li>doc</li>
<li>misc</li>
<li>pkg</li>
<li>src</li>
<li>test</li>
</ul>
<p>环境变量：</p>
<ul>
<li>GOROOT</li>
</ul>
<h2 id="工程结构">工程结构</h2>
<p>Go是一门推崇软件工程理念的编程语言， 为开发周期的每个环节都提供了完备的工具和支持。</p>
<h3 id="工作区">工作区</h3>
<p>包含3个目录:</p>
<ul>
<li>src</li>
<li>pkg</li>
<li>bin</li>
</ul>
<p>命令源文件: 声明为属于main代码包，有main函数的文件。</p>
<h3 id="GOPATH">GOPATH</h3>
<h3 id="源码文件">源码文件</h3>
<h3 id="代码包">代码包</h3>
<h2 id="标准命令">标准命令</h2>
<ul>
<li>build</li>
<li>clean</li>
<li>install</li>
<li>env</li>
<li>fix</li>
<li>fmt</li>
<li>get</li>
<li>list</li>
<li>run</li>
<li>test</li>
<li>version</li>
</ul>
<p>标记：</p>
<ul>
<li>-a: 强行重新构建所有涉及的Go语言代码包</li>
<li>-n: 使命令指示打印，而不真正执行</li>
<li>-v:</li>
<li>-x</li>
</ul>
<h1 id="3_词法与数据结构">3 词法与数据结构</h1>
<h2 id="基本词法">基本词法</h2>
<p>5类词法元素:</p>
<ul>
<li>标识符</li>
<li>关键字</li>
<li>操作符</li>
<li>分隔符</li>
<li>字面量</li>
</ul>
<p>Go语言的所有源代码必须由Unicode编码规范的UTF-8编码格式编码。</p>
<p>接收操作符:  &lt;-</p>
<h3 id="b表达式">b表达式</h3>
<ul>
<li>基本表达式</li>
<li>选择表达式 .</li>
<li>索引符号和索引表达式</li>
<li>切片表达式： a[x:y:z]</li>
<li>类型断言：v, ok := x.(T)</li>
<li>调用</li>
<li><p>可变长参数： </p>
<p>  func appendIfAbsent(s []string, t …string) [] string<br>  appendIfAbsent([]string{“a”,”b”}, s…)</p>
</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>bool</li>
<li>byte</li>
<li>rune</li>
<li>int/uint</li>
<li>int8/uint8</li>
<li>int16/uint16</li>
<li>int32/uint32</li>
<li>int64/uint64</li>
<li>float32</li>
<li>float64</li>
<li>complex64</li>
<li>complex128</li>
<li>string </li>
</ul>
<h3 id="数组">数组</h3>
<ol>
<li><p>类型表示法: [n]T</p>
</li>
<li><p>值表示法: </p>
<ul>
<li>[6]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
<li>[…]string{“Go”, “Python”, “Java”, “C”, “PHP”}</li>
</ul>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="切片">切片</h3>
<p>可看做对数组的一种包装形式</p>
<ol>
<li><p>类型表示法: []T</p>
</li>
<li><p>值表示法: []string{“GO”, “Python”}</p>
</li>
<li><p>属性和基本操作</p>
<ul>
<li>len</li>
<li>取值[]</li>
</ul>
</li>
</ol>
<h3 id="字典">字典</h3>
<h3 id="函数与方法">函数与方法</h3>
<h3 id="接口">接口</h3>
<pre><code><span class="typedef"><span class="keyword">type</span> <span class="type">Interface</span> interface <span class="container">{
    <span class="type">Len</span>() <span class="title">int</span>
}</span></span>
<span class="typedef"><span class="keyword">type</span> <span class="type">Sortable</span> interface <span class="container">{
    <span class="title">sort</span>.<span class="type">Interface</span>
    <span class="type">Sort</span>()
}</span></span>
</code></pre><h3 id="结构体">结构体</h3>
<p>type Sequence struct {<br>    len int<br>    cap int<br>}</p>
<h3 id="指针">指针</h3>
<h3 id="数据初始化">数据初始化</h3>
<ul>
<li>new</li>
<li>make: 创建切片类型，字典类型和通道类型的值</li>
</ul>
<h2 id="数据的使用">数据的使用</h2>
<h3 id="赋值">赋值</h3>
<h3 id="常量与变量">常量与变量</h3>
<pre><code>const {
    Sunday = itoa
    Monday
    <span class="keyword">...</span>
}
</code></pre><h3 id="内建函数">内建函数</h3>
<ul>
<li>close: 只接受通道类型的值</li>
<li>len, cap</li>
<li>new, make</li>
<li>append, copy: 用于切片类型</li>
<li>delete: 删除一个字典类型的某个键值对</li>
<li>complex, real, imag</li>
<li>panic, recover</li>
<li>print, println</li>
</ul>
<h1 id="4_流程控制方法">4 流程控制方法</h1>
<h2 id="基本流程控制">基本流程控制</h2>
<ul>
<li><p>代码块和作用域</p>
</li>
<li><p>if</p>
</li>
<li><p>switch</p>
</li>
<li><p>for</p>
</li>
</ul>
<h2 id="defer">defer</h2>
<h2 id="异常处理">异常处理</h2>
<h1 id="5_程序测试与文档">5 程序测试与文档</h1>
<h1 id="6_并发编程综述">6 并发编程综述</h1>
<h1 id="7_Goroutine和Channel">7 Goroutine和Channel</h1>
<h1 id="8_同步">8 同步</h1>
<h1 id="9_一个网络爬虫框架的设计和实现">9 一个网络爬虫框架的设计和实现</h1>
<h1 id="Go语言的学习资料">Go语言的学习资料</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/14/Go并发编程实战/" data-id="bshtpwwoj3zsq9u4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript高级程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/12/javascript高级程序设计/" class="article-date">
  <time datetime="2015-03-12T00:12:57.000Z" itemprop="datePublished">3月 12 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_Javascript简介">1 Javascript简介</h1>
<p>Javascript从一个简单的输入验证器发展成了一门强大的语言。</p>
<p>javascript由三部分组成：</p>
<ul>
<li>核心(ECMAScipt)</li>
<li>文档对象模型(DOM)</li>
<li>浏览器对象模型(BOM)</li>
</ul>
<h1 id="2_在HTML中使用Javascript">2 在HTML中使用Javascript</h1>
<h2 id="使用元素">使用<script>元素</h2>
<p><script>定义了6个属性:</p>
<ul>
<li>async</li>
<li>charset</li>
<li>defer</li>
<li>language. 已废弃</li>
<li>src</li>
<li>type</li>
</ul>
<p>标签的位置一般放在<body>元素中页面内容的后面,为了避免延迟。</p>
<p>使用src属性引用外部脚本。最好的做法是引入外部脚本：</p>
<ul>
<li>可维护性</li>
<li>可缓存</li>
<li>适应未来</li>
</ul>
<h2 id="文档模式">文档模式</h2>
<h2 id="元素"><noscript>元素</h2>
<p>用以在不支持javascipt的浏览器中。</p>
<h1 id="3_基本概念">3 基本概念</h1>
<h2 id="语法">语法</h2>
<ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释</li>
<li>严格模式</li>
<li>语句</li>
<li>关键字和保留字</li>
<li>变量：松散类型</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>5种简单类型：</p>
<ul>
<li>Undefined:只有一个值, undefiend. var声明但未初始化. </li>
<li>Null: 只有一个值: null.</li>
<li>Boolean</li>
<li>Number<ul>
<li>浮点数值</li>
<li>数值范围</li>
<li>NaN</li>
<li></li>
</ul>
</li>
<li>String</li>
</ul>
<p>1种复杂数据类型： Object</p>
<p>typeof操作符， 注意它不是函数</p>
<h2 id="流控制语句">流控制语句</h2>
<h2 id="函数">函数</h2>
<h1 id="4_变量，作用域和内存问题">4 变量，作用域和内存问题</h1>
<h1 id="5_引用类型">5 引用类型</h1>
<h1 id="6_面向对象的程序设计">6 面向对象的程序设计</h1>
<h1 id="7_函数表达式">7 函数表达式</h1>
<h1 id="8_BOM">8 BOM</h1>
<h1 id="9_客户端检测">9 客户端检测</h1>
<h1 id="10_DOM">10 DOM</h1>
<h1 id="11_DOM扩展">11 DOM扩展</h1>
<h1 id="12_DOM2和DOM3">12 DOM2和DOM3</h1>
<h1 id="13_事件">13 事件</h1>
<h1 id="14_表单脚本">14 表单脚本</h1>
<h1 id="15_使用Canvas绘图">15 使用Canvas绘图</h1>
<h1 id="16_HTML5脚本编程">16 HTML5脚本编程</h1>
<h1 id="17_错误处理和调试">17 错误处理和调试</h1>
<h1 id="18_Javascript与XML">18 Javascript与XML</h1>
<h1 id="19_E4X(ECMAScipt_for_XML)">19 E4X(ECMAScipt for XML)</h1>
<h1 id="20_JSON">20 JSON</h1>
<h1 id="21_Ajax与Comet">21 Ajax与Comet</h1>
<h1 id="22_高级技巧">22 高级技巧</h1>
<h1 id="23_离线应用与客户端存储">23 离线应用与客户端存储</h1>
<h1 id="24_最佳实践">24 最佳实践</h1>
<h1 id="25_新兴的API">25 新兴的API</h1>
</script></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/12/javascript高级程序设计/" data-id="yl793uiqyiwu57xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-evernote超效率数字笔记术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/10/evernote超效率数字笔记术/" class="article-date">
  <time datetime="2015-03-10T01:05:14.000Z" itemprop="datePublished">3月 10 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/10/evernote超效率数字笔记术/">evernote超效率数字笔记术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/10/evernote超效率数字笔记术/" data-id="iaqmn1ggdogy709x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ProgrammingInScala" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/ProgrammingInScala/" class="article-date">
  <time datetime="2015-03-07T02:47:36.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/ProgrammingInScala/">Scala编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_可扩展的语言">1 可扩展的语言</h1>
<p>增加新的类型:</p>
<pre><code> scala像一个集市而不是大教堂, 它被设计为可以让使用他的人扩展和修改.
</code></pre><p>增加新的控制结构:</p>
<pre><code> 基于actor的并发模型
</code></pre><h2 id="为何使用scala">为何使用scala</h2>
<p>1 兼容的<br>2 简洁的<br>3 高级的</p>
<pre><code> 程序员总是在与代码的复杂性搏斗.只有对工作的代码了如指掌,才能有的放矢的编程开发.
 复杂的代码成了很多软件项目崩溃的原因.
 不幸的是,重要的软件通常需求复杂.复杂性不可避免,那么必须加强管理.
 scala可以通过帮助提升接口的抽象级别来帮助管理复杂性.
</code></pre><p>4 静态类型的</p>
<pre><code> scala通过类型推断避免了冗余性
 通过模式匹配和一些新的编写和组织类型的办法获得了灵活性.
 静态类型系统可以保证消除某些运行时错误.
</code></pre><h1 id="2_Scala入门初探">2 Scala入门初探</h1>
<p>定义方法时, 如果仅仅包含一条语句, 可以连花括号可以不写.</p>
<p>倾向于函数式的编程风格::</p>
<pre><code>    args.<span class="keyword">foreach</span>( arg =&gt; println(arg ) )
    args.<span class="keyword">foreach</span>( println )
</code></pre><p>scala的数组是通过索引值加圆括号进行访问( 不是方括号)</p>
<p>另一个准则: 方法只有一个参数,调用的时候可以省略点和括号::</p>
<pre><code>    <span class="keyword">for</span>( <span class="keyword">i</span> &lt;- <span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> )
        <span class="keyword">print</span>( greetingString(<span class="keyword">i</span>))
</code></pre><p>用括号传递给变量一个或多个值变量时, Scala会把它转换为对apply方法的调用.</p>
<p>类似有update方法调用.</p>
<p>scala对任何事物都追求概念的简洁性, 从数组到表达式,包括带有方法的对象.</p>
<p>方法没有副作用是函数式风格编程的重要概念.</p>
<p>为何列表不支持append, 性能差</p>
<p>Scala程序员的平衡感:</p>
<pre><code> 崇尚val, 不可变量和没有副作用的方法.
 首先想到他们.只有在特定需要和并加以权衡之后才选择var,可变对象和有副作用的方法.
</code></pre><p>从文件里读取文本行:</p>
<pre><code>    <span class="keyword">for</span>( <span class="built_in">line</span> &lt;- Source.fromFile(<span class="string">"scalaProject.iml"</span>).getLines())
      println( <span class="built_in">line</span>.<span class="built_in">length</span> + <span class="string">" "</span> + <span class="built_in">line</span>)
</code></pre><h1 id="4_类和对象">4 类和对象</h1>
<p>保持对象健壮性的重要方法之一: 保证对象的状态.</p>
<p>scala里方法参数的一个重要特征是他们都是val.</p>
<p>方法的推荐风格是尽量避免return语句, 尤其是多条return语句.</p>
<p>scala通常的风格:把操作符放在行尾和不是行头::</p>
<pre><code>    <span class="title">x</span> +
    y +
    z
</code></pre><p>scala不能定义静态成员,而代之定义单例对象.</p>
<h1 id="5_基本类型和操作">5 基本类型和操作</h1>
<p>值类型: Int,Long,Short,Byte,Float,Double,Char, Boolean<br>String</p>
<p>符号字面值:  ‘&lt;标识符&gt;, Symbol(“cybmbal”)</p>
<p>方法调用的空括号可以省略. 惯例是若方法带有副作用就加上括号, 如pringln(). 若没有副作用,就去掉括号.</p>
<p>scala的==与java有差别.</p>
<p>富包装器.</p>
<h1 id="6_函数式对象">6 函数式对象</h1>
<p>函数式对象: 不具有任何可改变状态的对象的类</p>
<p>不可变对象的缺点: 有时需要负责很大的对象表, 而可变对象的更新可以在原址上发生.</p>
<p>为朱构造器定义先决条件. 用require方法.</p>
<p>不建议在标识符结尾使用下划线.</p>
<p>scala的常量名, 习惯只是第一个字母必须大写.</p>
<p>如果无技巧性地使用, 操作符方法和隐式转换都会让客户代码变得难以阅读和理解.</p>
<p>在设计库的时候你应记在脑袋你的目标并不是仅仅让客户代码简洁, 而是让他变得更可读,更易懂.</p>
<h1 id="7_内建控制结构">7 内建控制结构</h1>
<p>由于while循环不产生值,因此他经常被纯函数式语言所舍弃.</p>
<p>for 过滤:</p>
<pre><code>    val filesHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>) ).listFiles
    <span class="keyword">for</span>( <span class="keyword">file</span> &lt;- filesHere <span class="keyword">if</span> <span class="keyword">file</span>.getname.endsWith(<span class="string">".scala"</span>)
        <span class="keyword">println</span>( <span class="keyword">file</span>)

    <span class="keyword">for</span>( 
        <span class="keyword">file</span> &lt;- filesHere
        <span class="keyword">if</span> <span class="keyword">file</span>.isFile;
        <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
    ) <span class="keyword">println</span>(<span class="keyword">file</span>)
</code></pre><p>嵌套枚举:</p>
<pre><code>    <span class="keyword">def</span> fileLines(<span class="keyword">file</span>: java.io.<span class="keyword">File</span>) =
        scala.io.<span class="keyword">Source</span>.fromFile(<span class="keyword">file</span>).getLines.<span class="keyword">toList</span>

    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span>(
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>);     <span class="comment">//必须有分号;</span>
            line &lt;- fileLines(<span class="keyword">file</span>)
            <span class="keyword">if</span> line.trim.matches(pattern)
        )<span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ line.trim )

    <span class="keyword">grep</span> (<span class="string">".*gcd.*"</span>)
</code></pre><p>可以使用花括号代替小括号包裹发生器和过滤器,优点:可以不写分号.</p>
<p>以上有缺点, line.trim多次计算. 可以使用流间变量绑定::</p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">grep</span>(pattern: String)=
        <span class="keyword">for</span> {
            <span class="keyword">file</span> &lt;- filesHere
            <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(<span class="string">".scala"</span>)
            line &lt;- fileLines(<span class="keyword">file</span>)
            trimmed = line.trim
            <span class="keyword">if</span> trimmed.matches(pattern)
        } <span class="keyword">println</span>( <span class="keyword">file</span> + <span class="string">": "</span>+ trimmed )
</code></pre><p>制造新集合. 使用yield::</p>
<pre><code>    <span class="keyword">for</span> {  子句 } <span class="keyword">yield</span> { 循环体}
</code></pre><p>抛出异常的类型是Nothing.</p>
<p>catch使用模式匹配::</p>
<pre><code>    <span class="keyword">try</span>{
        val f = <span class="keyword">new</span> FileReader(<span class="string">"input.txt"</span>)
    }<span class="keyword">catch</span>{
        <span class="keyword">case</span> ex:FileNotFoundException =&gt; <span class="comment">// 处理丢失的文件</span>
        <span class="keyword">case</span> ex: IOException =&gt; <span class="comment">//处理io错误</span>
    }
</code></pre><p>finally也产生值.</p>
<p>不再使用break和continue</p>
<p>变量范围::</p>
<pre><code>任何定义在花括号里的东西超出括号之后就脱离了范围. ( <span class="keyword">for</span>子句有例外)
</code></pre><h1 id="8_函数和闭包">8 函数和闭包</h1>
<p>函数式编程风格的重要设计原则: 程序应该被解构成若干小的函数.</p>
<p>本地函数可以访问包含其函数的参数.</p>
<p>函数字面值::</p>
<pre><code>    <span class="function"><span class="params">(x: Int)</span> =&gt;</span> x + <span class="number">1</span>
</code></pre><p>想让函数字面量包含多条语句,可以用花括号包住函数体,一行一语句 ::</p>
<pre><code>    <span class="function"><span class="title">increase</span> = <span class="params">(x: Int)</span> =&gt;</span> {
        println(<span class="string">"We"</span>)
        println(<span class="string">"are"</span>)
        println(<span class="string">"here!)
        x + 1
    }</span>
</code></pre><p>其他例子::</p>
<pre><code>    val someNumbers = List( -<span class="number">11</span>, -<span class="number">10</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)
    someNumbers.foreach<span class="function"><span class="params">(  (x:Int) =&gt; println( x ) )</span>
    <span class="title">someNumbers</span>.<span class="title">filter</span><span class="params">( (x:Int) =&gt; x &gt; <span class="number">0</span> )</span></span>
</code></pre><p>函数字面量的短格式. ( 去除参数类型; 去除括号) ::</p>
<pre><code><span class="attribute">    someNumbers.filter( x </span>=<span class="string">&gt; x &gt; 0 )</span>
</code></pre><p>占位符语法(只要每个参数在函数字面量内仅出现一次)::</p>
<pre><code>    someNumbers.<span class="built_in">filter</span>( _ &gt; <span class="number">0</span> )

    val f = (_: <span class="built_in">Int</span> ) + (_ : <span class="built_in">Int</span> )
    f(<span class="number">5</span>, <span class="number">10</span> )
</code></pre><p>还可以用单个下划线代替整个参数列表::</p>
<pre><code>    someNumbers.foreach( println _ )
    def <span class="built_in">sum</span>(<span class="operator">a</span>: Int, b: Int, c:Int ) = <span class="operator">a</span> + b + c
    val <span class="operator">a</span> = <span class="built_in">sum</span> _
    <span class="operator">a</span>( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )

    val b = <span class="built_in">sum</span>( <span class="number">1</span>, _:Int, <span class="number">3</span> )
</code></pre><p> 写一个省略所以参数偏函数表达式, 如 println <em> 或 sum </em>, 在需要函数的地方可进一步去掉占位符::</p>
<pre><code>    someNumbers.<span class="keyword">foreach</span>( println )

    <span class="comment">//但不能这样写: val c = sum</span>
    val d = sum _   <span class="comment">//必须带占位符</span>
</code></pre><h1 id="9_控制抽象">9 控制抽象</h1>
<h2 id="9-1_减少代码重复">9.1 减少代码重复</h2>
<p>所有的函数都可以被分成通用部分, 以及非通用部分. 通用部分是函数体, 而非通用部分必须由参数提供.</p>
<p>高阶函数: 带其他函数做参数的函数- 给你额外的机会去组织和简化代码.</p>
<p>例如:</p>
<pre><code>    object FileMatcher {
        <span class="keyword">def</span> fileHere = (<span class="keyword">new</span> java.io.<span class="keyword">File</span>(<span class="string">"."</span>)).listFiles
    <span class="keyword">def</span> filesEnding(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.endsWith(query))
        yield <span class="keyword">file</span>

    <span class="keyword">def</span> filesContain(query:String) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> <span class="keyword">file</span>.getName.contains(query))
        yield <span class="keyword">file</span>

    }
</code></pre><p>以上filesEnding和FilesContain结构很像.</p>
<pre><code>    def filesMatching(query:<span class="typename">String</span>, matcher: (<span class="typename">String</span>,<span class="typename">String</span>) =&gt;<span class="typename">Boolean</span>) =
        <span class="keyword">for</span>(<span class="keyword">file</span> &lt;- fileHere; <span class="keyword">if</span> matcher(<span class="keyword">file</span>.getName, query))
        yield <span class="keyword">file</span>
</code></pre><p>那么原来两个方法可以简化为:</p>
<pre><code>    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(query,_.<span class="function">endsWith</span>(_))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(query, _.<span class="function">contains</span>(_))</span>
</code></pre><p>使用闭包可以更短.</p>
<pre><code>    def <span class="function">filesMatching</span>(matcher<span class="value">: String =&gt; Boolean) =
        <span class="function">for</span>(file &lt;- fileHere;</span> if <span class="function">matcher</span>(file<span class="class">.getName</span>))
        yield file

    def <span class="function">fileEnding</span>(query<span class="value">:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))
    def <span class="function">fileContain</span>(query:String) = <span class="function">filesMatching</span>(_.<span class="function">endsWith</span>(query))</span>
</code></pre><h2 id="9-2_简化客户代码">9.2 简化客户代码</h2>
<p>例子: 判断是否有负数.</p>
<pre><code>    <span class="function"><span class="keyword">def</span> <span class="title">containsNeg</span><span class="params">( nums: List[Int])</span>:</span>Boolean = {
        var exists = false
        <span class="keyword">for</span>(num&lt;-nums)
        <span class="keyword">if</span> (num&lt;<span class="number">0</span>)
            exists = true
        exists   
    }
</code></pre><p>更简洁的方式, 是使用高阶函数exists:</p>
<pre><code>   def containsNeg(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ &lt; <span class="number">0</span>)
   def containsOdd(num<span class="variable">s:</span> List[Int]) = nums.<span class="built_in">exists</span>( _ % <span class="number">2</span> == <span class="number">1</span>) 
</code></pre><h2 id="9-3_柯里化(_currying_)">9.3 柯里化( currying )</h2>
<p>例子：</p>
<pre><code>    <span class="keyword">def</span> plainOldSum(x :<span class="keyword">Int</span>, y: <span class="keyword">Int</span>) = x + y
    plainOldSum(<span class="number">1</span>,<span class="number">3</span>)
    <span class="keyword">def</span> curriedSum(x:<span class="keyword">Int</span>)(y:<span class="keyword">Int</span>)= x + y
    curriedSum(<span class="number">1</span>)(<span class="number">3</span>)
    val first = curriedSum(<span class="number">1</span>)_
    first(<span class="number">3</span>)
</code></pre><h2 id="9-4_编写新的控制结构">9.4 编写新的控制结构</h2>
<p>双倍控制结构:</p>
<pre><code>    <span class="keyword">def</span> twice(op: <span class="keyword">Double</span> =&gt;<span class="keyword">Double</span>, x:<span class="keyword">Double</span>) = op(op(x))
    twice(_ + <span class="number">1</span>, <span class="number">5</span>)
</code></pre><p>代码模式: 打开一个资源, 对它进行操作, 然后释放资源: </p>
<pre><code>    <span class="keyword">def</span> <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>: <span class="keyword">File</span>)(op: PrintWriter =&gt; Unit){
        val writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">file</span>)
        <span class="keyword">try</span>{
        op(writer)
        }<span class="keyword">finally</span>{
        writer.close()
        }
    }
    val <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"date.txt"</span>)
    <span class="keyword">withPrintWriter</span>(<span class="keyword">file</span>){
        writer =&gt; writer.<span class="keyword">println</span>(<span class="keyword">new</span> java.util.Date)
    }
</code></pre><p>scala的任何方法调用, 如果你确实只传入一个参数, 就能可选地使用花括号替代小括号包围参数.<br>目的: 是让客户程序员写出包围在花括号内的函数字面量,.</p>
<h2 id="9-5_传名参数">9.5 传名参数</h2>
<h1 id="10_组合与继承">10 组合与继承</h1>
<h2 id="10-1_二维布局库">10.1 二维布局库</h2>
<h2 id="10-3_定义无参数方法">10.3 定义无参数方法</h2>
<p>scala鼓励使用不带参数且没有副作用的方法定义为无参数方法的风格, 即省略空括号.<br>无论何时当调用有副作用的方法, 应确保包含一对括号.</p>
<p>scala里的字段和方法属于相同的命名空间.这让字段可以重写无参数方法.</p>
<p>scala仅有两个命名空间:</p>
<ul>
<li>值</li>
<li>类型</li>
</ul>
<h1 id="11_Scala的层级">11 Scala的层级</h1>
<p>Scala中每个类都继承超类Any。在底层还定义了： Null和Nothing。 Nothing是所有其他类的子类。</p>
<h2 id="11-1_Scala的类层级">11.1 Scala的类层级</h2>
<p>Any两子类:</p>
<ul>
<li><p>AnyVal: 内建值类的父类， 有9个子类：</p>
<ul>
<li>Byte</li>
<li>Short</li>
<li>Char</li>
<li>Int</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Unit</li>
</ul>
</li>
<li><p>AnyRef：所有引用类的基类，就是java.lang.Object的别名。还继承自一个名为ScalaObject的特别的记号特质（ 用于编译优化）</p>
</li>
</ul>
<h2 id="11-2_原始类型是如何实现的">11.2 原始类型是如何实现的</h2>
<h2 id="11-3_底层类型">11.3 底层类型</h2>
<p>Null类是null引用对象的类型, 是每个引用类的子类. 不兼容值类型.<br>Nothing类型在Scala的类层次的最底层.</p>
<h1 id="12_特质">12 特质</h1>
<p>特质封装了方法和字段的定义,并可以混入到类中重新定义它们.</p>
<h1 id="13_包和引用">13 包和引用</h1>
<p>做程序的时候, 使耦合最小化是很重要的. 减小耦合性的方式之一是使用模块化的风格编写代码.</p>
<h1 id="13-1_包">13.1 包</h1>
<p>scala采用java平台完整的包机制.</p>
<ol>
<li><p>和java相同:</p>
<p> package bobosrockets.navigtion<br> class Navigtor</p>
</li>
<li><p>像C#的命名空间:</p>
<p> package bobosrockets {</p>
<pre><code> <span class="keyword">package</span> navigtion{
     <span class="class"><span class="keyword">class</span> <span class="title">Navigtor</span></span>
     <span class="keyword">package</span> tests{
         <span class="class"><span class="keyword">class</span> <span class="title">NavigtorSuite</span></span>
     }
 }
</code></pre><p> }</p>
</li>
</ol>
<p>顶层包: <em>root</em></p>
<h1 id="13-2_引用">13.2 引用</h1>
<p>import子句让包活对象的成员可以子句通过名称访问而不是通过前缀包访问.<br>例子:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets._</span>
<span class="preprocessor"><span class="keyword">import</span> bobosrockets.Fruit._</span>
</code></pre><p>Scala的引用可以出现在任何地方.</p>
<p>可以引用包本身.</p>
<p>可以重命名或隐匿成员:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> Fruits.{Apple =&gt; McIntosh, Orange}</span>
<span class="preprocessor"><span class="keyword">import</span> java.sql.{Date =&gt; SDate}</span>

<span class="preprocessor"><span class="keyword">import</span> Fruits.{Pear =&gt; _, _ }  // 引用了Fruits的所有成员,但Pear除外</span>
</code></pre><h1 id="13-3_隐式引用">13.3 隐式引用</h1>
<p>Scala为每个程序隐式地添加一些引用:</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> java.lang._</span>
<span class="preprocessor"><span class="keyword">import</span> scala._</span>
<span class="preprocessor"><span class="keyword">import</span> Predef._</span>
</code></pre><h1 id="13-4_访问修饰符">13.4 访问修饰符</h1>
<p>private[X] 表示”直到”X的私有保护.</p>
<p>private[this]标记的定义仅能在包含了定义同一个对象中被访问.</p>
<p>类的所有访问权限都对伴生对象开放,反过来也是如此.</p>
<h1 id="14_断言和单元测试">14 断言和单元测试</h1>
<h1 id="21_隐式转换和参数">21 隐式转换和参数</h1>
<p>隐式转换只是普通的方法, 但它一修饰符implicit开始.</p>
<p>例子:</p>
<pre><code>    implicit def stringWrpper(<span class="keyword">s</span>: String) = 
            new RandomAccessSe<span class="string">q[Char]</span>  {
            def <span class="keyword">length</span> = <span class="keyword">s</span>.<span class="keyword">length</span>
            def apply(i: Int) = <span class="keyword">s</span>.charAt(i)
    }
</code></pre><p>优点:</p>
<ul>
<li>免费获取所有其它RandomAccessSeq的方法</li>
<li>支持目标类型的转换</li>
</ul>
<p>隐性定义是指编译器为了修正类型错误而允许插入到程序中的定义.<br>例如: 若 x + y不能通过类型检查, 编译器可能会把它改为convert(x) + y</p>
<p>标记规则: 只有标记为implicit的定义才是可用的.</p>
<p>作用域规则: 插入的隐性转换必须以单一标识符的形式处于作用域中,或与转换的源或目标类型关联在一起.</p>
<p>无歧义规则: 隐式转换唯有不存在其他可插入转换的前提下才能插入.</p>
<p>单一调用规则: 只会尝试一个隐式操作, 编译器不会把 x +y 重写成convert1(convert2(x)) + y.</p>
<p>显式操作先行规则: 若编写的代码类型检查无误, 则不会尝试任何隐式操作.</p>
<p>命名隐式转换.</p>
<p>隐式操作在哪里尝试:</p>
<ul>
<li>转换为期望类型</li>
<li>指定(方法)调用者的转换</li>
<li>隐式参数</li>
</ul>
<p>被所有Scala程序隐式引用的scala.Predef对象, 定义了把”较小的”数值类型转变为”较大的”类型的隐式转换.</p>
<h2 id="转换为方法的接受者">转换为方法的接受者</h2>
<p>例子:</p>
<pre><code>    class Rational(n: Int, d: Int) {
        <span class="keyword">...</span>
        def + (that: Rational): Rational = <span class="keyword">...</span>
        def + (that: Int): Rational = <span class="keyword">...</span>
    }
</code></pre><p>执行：</p>
<pre><code>scala&gt; <span class="number">1</span> + oneHalf
&lt;console&gt;:<span class="number">6</span>: error: overloaded <span class="function"><span class="keyword">method</span> <span class="title">value</span> + <span class="title">with</span>
<span class="title">alternatives</span> <span class="params">(Double)</span><span class="title">Double</span> &lt;<span class="title">and</span>&gt; ... <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span>

<span class="title">scala</span>&gt; <span class="title">implicit</span> <span class="title">def</span> <span class="title">intToRational</span><span class="params">(x: Int)</span> = <span class="title">new</span> <span class="title">Rational</span><span class="params">(x, 1)</span>
<span class="title">intToRational</span>:</span> (x: Int)Rational

scala&gt; <span class="number">1</span> + oneHalf
res2: Rational = <span class="number">3</span>/<span class="number">2</span>
</code></pre><h2 id="模拟新的语法">模拟新的语法</h2>
<p>例子:</p>
<pre><code>    <span class="built_in">Map</span>(<span class="number">1</span> <span class="subst">-&gt;</span><span class="string">"one"</span>, <span class="number">2</span> <span class="subst">-&gt;</span><span class="string">"two"</span>, <span class="number">3</span> <span class="subst">-&gt;</span><span class="string">"three"</span>)
</code></pre><p>“-&gt;”不是内建语法, -&gt;只是定义在标准Scala中类ArrowAssoc的方法, 定义了Any到ArrowAssoc的隐式转化.<br>编写 1-&gt;”one”的时候, 编译器会插入1到ArrowAssoc的转换以便找到-&gt;方法.</p>
<pre><code>    package scala
    object Predef {
        class ArrowAssoc[A](x: A) {
            def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)
        }
        implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
        new ArrowAssoc(x)
        <span class="keyword">...</span>
    }
</code></pre><h2 id="隐式参数">隐式参数</h2>
<p>编译器有时会用someCall(a)(b)替换somCall(a) 或者用new someCall(a)(b)替换new someCall(a).<br>从而通过添加缺失参数列表以满足函数调用.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/ProgrammingInScala/" data-id="n7l1932ui6el72wb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-scala快学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/scala快学/" class="article-date">
  <time datetime="2015-03-07T01:10:50.000Z" itemprop="datePublished">3月 7 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/scala快学/">快学scala</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1_基础">1 基础</h1>
<h2 id="scala解释器">scala解释器</h2>
<h2 id="声明值和变量">声明值和变量</h2>
<p>变量或函数的类型总是写在变量或函数名称的后面。 使得我们更容易阅读那些负责类型的声明。</p>
<pre><code><span class="keyword">val</span> greeting: String = <span class="keyword">null</span>
<span class="keyword">val</span> greeting: Any = <span class="string">"Hello"</span>
</code></pre><p>可以将多个值或变量放在一起声明:</p>
<pre><code>val xmax, ymax = <span class="number">100</span> <span class="comment">//将xmax和ymax设为100</span>
valgreeting, message: <span class="built_in">String</span> = <span class="literal">null</span>
</code></pre><h2 id="常用类型">常用类型</h2>
<p>7种数值类型： Byte, Char, Short, Int, Long, Float和Double, Boolean</p>
<p>不需要包装类型，基本类型和包装类型自己的转换是scala编译器的工作。</p>
<p>在scala中，我们用方法，而不是强制类型转换， 来做数值类型之间的转换：</p>
<pre><code><span class="number">99.44</span>.toInt <span class="comment">//= 99</span>
<span class="number">99.</span>toChar   <span class="comment">//='c'</span>
</code></pre><h2 id="算术和操作符重载是">算术和操作符重载是</h2>
<p>“a 方法 b”  是 “a.方法(b)” 的简写</p>
<p>scala没有++， — 操作符</p>
<h2 id="apply方法">apply方法</h2>
<p>“hello”(4)是”hello”.apply(4)的缩写。</p>
<p>使用伴生对象的apply方法。</p>
<h2 id="Scaladoc">Scaladoc</h2>
<p>www.scala-lang.org/api<br>或者www.scala-lang.org/downloads#api</p>
<p>类名旁边的O(伴生对象）和C（类）</p>
<p>scala文档小窍门:</p>
<ul>
<li>想使用数值类型， 记得看看RichInt, RichDouble等， 字符串，记得看看StringOps.</li>
<li>数值函数位于scala.math包中。</li>
<li>名称比较奇怪的函数。 如BigInt有个方法unary_-, 就是你定义前置的负操作符-x的方式</li>
<li>标记位implicit的方法对应的是自动（隐式）转换。</li>
<li>方法可以以函数为常数</li>
</ul>
<h1 id="2_控制结构和函数">2 控制结构和函数</h1>
<h2 id="变长参数">变长参数</h2>
<p>使用Int<em>, 若传入的数组后面要加上”:_</em>“转换</p>
<pre><code>def sum(args:<span class="type">Int</span>*) = {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="number">0</span>
  <span class="keyword">for</span>(arg &lt;- args) <span class="literal">result</span> += arg
  <span class="literal">result</span>
}
val s = sum(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>)
val s2 = sum(<span class="number">1</span> to <span class="number">10</span>: _*)
</code></pre><h2 id="懒值">懒值</h2>
<p>但val被声明为lazy时，它的初始化将被推迟，直到我们首次对它取值。</p>
<p>lazy val words = scala.io.Source.fromFile(“/usr/share/dict/words”).mkString</p>
<h2 id="异常">异常</h2>
<p>throws表达式有特殊的类型Nothing.</p>
<h1 id="3_数组相关操作">3 数组相关操作</h1>
<p>要点：</p>
<ul>
<li>长度固定使用Array， 长度可能变化用ArrayBuffer</li>
<li>提供初始值不用使用new</li>
<li>用()来访问元素</li>
<li>用for(elem &lt;- arr)来遍历元素</li>
<li>用for(elem &lt;- arr if …)… yeild .. 来将原数组转型为新数组</li>
<li>scala数组和Java数组可以互操作；用ArrayBuffer, 使用scala.collection.JavaConversions中的转换函数。</li>
</ul>
<h2 id="与java的互操作">与java的互操作</h2>
<p>转成java的List:</p>
<pre><code>import scala.collection.JavaConversions.bufferAsJavaList
val <span class="command"><span class="keyword">command</span> = <span class="title">ArrayBuffer</span>(<span class="string">"ls"</span>, <span class="string">"-la"</span>, <span class="string">"/home/"</span>)</span>
val pb = <span class="built_in">new</span> ProcessBuilder(<span class="command"><span class="keyword">command</span>)</span>
</code></pre><p>将java的List转成BufferArray:</p>
<pre><code>import scala.collection.JavaConversions.asScalaBuffer
<span class="keyword">val</span> cmd:<span class="keyword">mutable</span>.Buffer[String] = pb.command()
</code></pre><h1 id="4_映射和元组">4 映射和元组</h1>
<pre><code>val scores <span class="subst">=</span> <span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
val ms <span class="subst">=</span> scala<span class="built_in">.</span>collection<span class="built_in">.</span>mutable<span class="built_in">.</span><span class="built_in">Map</span>(<span class="string">"Alice"</span> <span class="subst">-&gt; </span><span class="number">10</span>, <span class="string">"Bob"</span> <span class="subst">-&gt; </span><span class="number">3</span>, <span class="string">"Cindy"</span> <span class="subst">-&gt; </span><span class="number">5</span>)
println(scores(<span class="string">"Bob"</span>))
println(scores<span class="built_in">.</span>getOrElse(<span class="string">"yuqiao"</span>, <span class="number">0</span>))
</code></pre><p>与Java的互操作：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap</span>
</code></pre><p>使用zip:</p>
<pre><code>val symbols = Array(<span class="string">"&lt;"</span>, <span class="string">"-"</span>, <span class="string">"&gt;"</span>)
val counts = Array(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)
val <span class="built_in">pairs</span> = symbols.zip(counts)
<span class="keyword">for</span>((k,v)&lt;-<span class="built_in">pairs</span>){
  <span class="built_in">print</span>(k*v)
}
</code></pre><p>使用toMap将对偶集合转换成映射Map.</p>
<h1 id="5_类">5 类</h1>
<p>要点:</p>
<ul>
<li>类中字段自动带有getter和setter方法</li>
<li>可以用定制的getter/setter方法替换掉字段的定义</li>
<li>用@BeanProperty注解来生成JavaBeans的getXXX/setXXX方法</li>
<li>每个类都有一个主要的构造器, 它的参数直接成为类的字段。</li>
<li>辅助构造器是可选的， 叫做this.</li>
</ul>
<p>定义类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>{
    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span>
    <span class="keyword">def</span> increment() { value +=<span class="number">1</span>}
    <span class="keyword">def</span> current() = value
}

<span class="keyword">val</span> myCounter = <span class="keyword">new</span> Counter
myCounter.increment()        <span class="comment">//对改值器使用()</span>
println(myCounter.current)   <span class="comment">//对取值器不使用()</span>
</code></pre><p>在scala中， getter和setter分别是age和age_=</p>
<p>统一访问原则</p>
<p>对象私有字段</p>
<p>Bean属性</p>
<p>主构造器:</p>
<pre><code><span class="keyword">class</span> Person(val name:String, val age: <span class="keyword">Int</span>) {

<span class="keyword">def</span> <span class="keyword">description</span> = name + <span class="string">" is "</span> + age + <span class="string">" years old"</span>
}
</code></pre><p>Martin Odesky建议: 在scala中, 类也接受参数， 就像方法一样。</p>
<p>嵌套类:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(val name:String)</span></span>{
        <span class="keyword">val</span> contacts = <span class="keyword">new</span> ArrayBuffer[Member]()
    }

    <span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> ArrayBuffer[Member]()

    <span class="keyword">def</span> join(name:String)={
        <span class="keyword">val</span> m = <span class="keyword">new</span> Member(name)
        members += m
        m
    }
}

<span class="keyword">val</span> chatter = <span class="keyword">new</span> Network
<span class="keyword">val</span> myFace = <span class="keyword">new</span> Network
</code></pre><p>每个实例都有它自己的Member类。chatter.Member和myFace.Member是不同的类。</p>
<p>可以放在Network的伴生对象。</p>
<h1 id="6_对象">6 对象</h1>
<p>scala没有静态方法或静态字段， 可以用object这个语法结构达到同样目的。</p>
<p>枚举通过扩展Enumeration实现：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">TrafficColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>{
    <span class="keyword">type</span> TrafficColor = Value
    <span class="keyword">val</span> Red, Yellow, Geen = Value
}

<span class="keyword">def</span> doWhat(color: TrafficColor) ={
  <span class="keyword">if</span>(color == Red)  <span class="string">"stop"</span>
  <span class="keyword">else</span> <span class="keyword">if</span>(color==Geen) <span class="string">"go"</span>
  <span class="keyword">else</span> <span class="string">"hurry up"</span>
}

<span class="keyword">def</span> testEnum(): Unit = {
  <span class="keyword">for</span>(c &lt;- TrafficColor.values) println(c.id + <span class="string">":"</span> + c + <span class="string">" "</span> + doWhat(c))
}
</code></pre><h1 id="7_包和引入">7 包和引入</h1>
<p>要点:</p>
<ul>
<li>包也可以像内部类那样嵌套</li>
<li>包路径不是绝对路径</li>
<li>包声明链x.y.z并不自动将中间包x.y变成可见</li>
<li>位于文件顶部不带花括号的包声明在整个文件范围内有效</li>
<li>包对象可以持有函数和变量</li>
<li>引入语句可以引入包，类和对象</li>
<li>引入语句可以出现在任何地方</li>
<li>引入语句可以重命名和隐藏特定成员</li>
<li>java.lang, scala和predef总是被引入</li>
</ul>
<h1 id="8_继承">8 继承</h1>
<p>要点:</p>
<ul>
<li>extends, final关键字和java相同</li>
<li>重写方法必须用override</li>
<li>只有主构造器可以钓鱼超类的主构造器</li>
<li>你可以重写字段</li>
</ul>
<p>类型检查和转换:</p>
<pre><code><span class="keyword">if</span>(p.isInstanceOf[Employee]){
    val s = p.asInstanceOf[Employee]
    <span class="keyword">...</span>
}
</code></pre><p>若想测试p指向的是一个Employee对象但又不是其子类：</p>
<pre><code><span class="keyword">if</span>(p.getClasss == <span class="class"><span class="keyword">class</span><span class="title">Of</span>[<span class="title">Employee</span>])</span>
</code></pre><p>classOf定义在scala.Predef对象中。</p>
<p>模式匹配通常是更好的选择：</p>
<pre><code>p match {
    case s:Employee =&gt; <span class="keyword">...</span> // 将s作为Employee处理
    case _ =&gt; // p 不是Employee
}
</code></pre><p>超类的构造：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(name: String, age: Int, val salary: Double)</span><span class="keyword">extends</span> <span class="title">Person</span><span class="params">(name, age)</span></span>
</code></pre><p>可以用val重写抽象def. 但def只能重写def, var只能重写另一个抽象的var</p>
<p>匿名子类：</p>
<pre><code>val alien = <span class="keyword">new</span> Person(<span class="string">"Fred"</span>) {
    <span class="keyword">def</span> greeting = <span class="string">"Greetings, Earthinling! My name is Fred!"</span>
}

<span class="keyword">def</span> meet(p: Person{<span class="keyword">def</span> greeting: String}){
    <span class="keyword">println</span>(p.name +<span class="string">"says: "</span> + p.greeting)
}
</code></pre><p>抽象类：用abstract标记不能实例化的类。</p>
<p>重写超类的抽象方法， 不需要override.</p>
<p>类可以有抽象字段。</p>
<p>构造顺序和提前定义。 </p>
<p>提前定义， 让你可以在超类的构造器之前初始化子类的val字段：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Ant</span> <span class="keyword">extends</span> </span>{
    <span class="keyword">override</span> <span class="keyword">val</span> range = <span class="number">2</span>
} <span class="keyword">with</span> Creature
</code></pre><h2 id="Scala继承层级">Scala继承层级</h2>
<p>基本类型和Unit， 都扩展自AnyVal<br>类都扩展自AnyRef.</p>
<p>AnyVal和AnyRef的基类是Any。Any是根节点.</p>
<p>Any类定义了isInstanceOf, asInstanceOf方法， 以及用于相等性判断和哈希码的方法<br>AnyRef追加了来着Object类的监视方法wait和notify/notifyAll.</p>
<h2 id="对象相等性">对象相等性</h2>
<pre><code><span class="keyword">final</span> override <span class="keyword">def</span> equals(other: <span class="keyword">Any</span>){
    val that = other.asInstanceOf[Item]
    <span class="keyword">if</span>(that == <span class="keyword">null</span>) <span class="keyword">false</span>
    <span class="keyword">else</span> <span class="keyword">description</span> == that.<span class="keyword">description</span> &amp;&amp; price == that.price
}
</code></pre><p>注意：</p>
<ul>
<li>方法定义为final</li>
<li>equals方法参数类型为Any.</li>
<li>定义equals时，记得同事也定义hashCode, 计算hashCode时，只应使用那些你用来做相等性判断的字段。</li>
</ul>
<p>::</p>
<pre><code>final override def hashCode = 13 <span class="keyword">*</span>description<span class="keyword">*</span>.hashCode +17 <span class="keyword">*</span> price.hashCode
</code></pre><h1 id="9_文件和正则表达式">9 文件和正则表达式</h1>
<p>要点:</p>
<ul>
<li>Source.fromFile(…).getLines.toArray 输出文件的所有行</li>
<li>Source.fromFile(…).mkString 以字符串形式输出文件内容</li>
<li>将字符串转成数字， 可以用toInt或toDouble方法。</li>
<li>使用Java的PrintWriter写入文件</li>
<li>“正则”.r是一个Regex对象。</li>
<li>若你的正则表达式包含反斜杠或者引号的话，用”””…”””</li>
<li>若正则模式包含分组，使用一些预发提取它们的内容： for(regex(变量,…,变量n)&lt;- 字符串）</li>
</ul>
<h2 id="读取">读取</h2>
<p>从文件:</p>
<pre><code><span class="keyword">import</span> scala.io.Source
<span class="keyword">val</span> source = Source.fromFile(<span class="string">"myfile.txt"</span>, <span class="string">"UTF-8"</span>)
<span class="keyword">val</span> lineIterator = source.getLines
<span class="keyword">val</span> tokens = source.mkString.split(<span class="string">"\\S+"</span>)
<span class="keyword">val</span> numbers = <span class="keyword">for</span>( w&lt;- tokens) <span class="keyword">yield</span> w.toDouble
<span class="keyword">val</span> numbers = tokens.map(_.toDouble)
</code></pre><p>从控制台读取:</p>
<pre><code>val age = <span class="built_in">read</span>Int()
</code></pre><p>其它源：</p>
<pre><code>val <span class="built_in">source</span>1 = Source.fromURL(<span class="string">"http://horstamnn.com"</span>, <span class="string">"UTF-8"</span>)
val <span class="built_in">source</span>2 = Source.fromString(<span class="string">"Hello, Wolle"</span>)
val <span class="built_in">source</span>3 = Source.stdin
</code></pre><p>二进制文件:</p>
<pre><code>val <span class="built_in">file</span>  = <span class="built_in">new</span> File(filename)
val <span class="operator">in</span>  = <span class="built_in">new</span> FileInputStream(<span class="built_in">file</span>)
val <span class="keyword">bytes</span> = <span class="built_in">new</span> Array[Byte](<span class="built_in">file</span>.<span class="built_in">length</span>.toInt)
<span class="operator">in</span>.<span class="built_in">read</span>(<span class="keyword">bytes</span>)
<span class="operator">in</span>.<span class="built_in">close</span>()
</code></pre><h2 id="写入">写入</h2>
<pre><code>val <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="string">"numbers.txt"</span>)
<span class="keyword">for</span>(i&lt;-<span class="number">1</span> <span class="keyword">to</span> <span class="number">100</span>)<span class="keyword">out</span>.println(i)
<span class="keyword">out</span>.close()
</code></pre><h2 id="访问目录">访问目录</h2>
<pre><code><span class="keyword">import</span> java.io.File

<span class="function"><span class="keyword">def</span> <span class="title">subdirs</span><span class="params">(dir:File)</span>:</span> Iterator[File] = {
    val children = dir.listFiles.filter(_.isDirectory)
    children.toIterator ++ children.toIterator.flatMap(subdirs _)
}
</code></pre><p>在scala中， 我们通常喜欢用函数对象来制定过着内容。</p>
<pre><code><span class="reserved">import</span> java.nio.file._
implicit def makeFileVistor<span class="function"><span class="params">(f: (Path) =&gt; Unit)</span>= <span class="title">new</span> <span class="title">SimpleFileVisitor</span>[<span class="title">Path</span>] {
    <span class="title">override</span> <span class="title">def</span> <span class="title">visitFile</span><span class="params">(p: Path, attrs: attribute.BasicFileAttributes)</span>= {
        <span class="title">f</span><span class="params">(p)</span>
        <span class="title">FileVisitResult</span>.<span class="title">CONTINUE</span>
    } 
}

<span class="title">Files</span>.<span class="title">walkFileTree</span><span class="params">(dir.toPath, (f:Path) =&gt;println(f))</span></span>
</code></pre><h2 id="序列化">序列化</h2>
<pre><code><span class="annotation">@SerialVersionUID</span>(<span class="number">42</span>L) <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Serilizable</span></span>
</code></pre><h2 id="进程控制">进程控制</h2>
<p>scala.sys.process包提供了与shell程序交互的工具。</p>
<pre><code><span class="keyword">import</span> sys.process._
<span class="string">"ls -al .."</span>!   <span class="comment">//执行结果打印到标准输出</span>
val result = <span class="string">"ls -al .."</span> !! <span class="comment">// !! 返回字符串</span>
<span class="string">"ls -al .."</span> #&gt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>)  <span class="comment">// #&gt; 重定向到文件</span>
<span class="string">"ls -al .."</span> #&gt;&gt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>)  <span class="comment">// #&gt;&gt; 追加到文件末尾</span>
<span class="string">"grep sec"</span> #&lt; <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"output.txt"</span>) <span class="comment">// #&lt; 把文件内容作为输入</span>
<span class="string">"grep Scala"</span> #&lt; <span class="keyword">new</span> URL(<span class="string">"http://horstmann.com/index.html"</span>) 
</code></pre><h2 id="正则表达式">正则表达式</h2>
<pre><code><span class="keyword">val</span> numPattern = <span class="string">"[0-9]+"</span>.r 
<span class="keyword">for</span> (matchString &lt;- numPattern.findAllIn(<span class="string">"99 bottles, 98 bottles"</span>) )
    处理matchString  <span class="comment">// 99, 98</span>

<span class="keyword">val</span> m1 = numPattern.findFirstIn(<span class="string">"99 bottles, 98 bottles"</span>) <span class="comment">//Some()</span>
numPattern.findPrefixOf(<span class="string">"99 bottles, 98 bottles"</span>) <span class="comment">// Some(99)</span>
</code></pre><h2 id="正则表达式组">正则表达式组</h2>
<pre><code>val numitemPatten = <span class="string">"([0-9]+) ([a-z]+)"</span>.r
val numitemPatten(<span class="built_in">num</span>, <span class="keyword">item</span>) = <span class="string">"99 bottles"</span><span class="comment"> // num 设置为99 ， item设置为"bottles"</span>

<span class="keyword">for</span> (numitemPatten(<span class="built_in">num</span>, <span class="keyword">item</span>) &lt;- numitemPatten.findAllIn(<span class="string">"99 bottles, 98 bottles"</span>) )
    处理<span class="built_in">num</span>, <span class="keyword">item</span>
</code></pre><h1 id="10_特质">10 特质</h1>
<p>要点：</p>
<ul>
<li>类可以实现任意数量的特质</li>
<li>特质要求实现他们的类具备特定的字段， 方法或超类</li>
<li>和Java接口不同，Scala特质可以提供方法和字段的实现</li>
<li>但你将多个特质叠加在一起时，顺序很重要 — 其方法先被执行的特质排在更后面</li>
</ul>
<h2 id="d当做接口使用的特质">d当做接口使用的特质</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>{
    <span class="keyword">def</span> log(msg: String)
}
</code></pre><p>子类可以给出实现：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">def</span> log(msg: String) { println(msg)}
}
</code></pre><h2 id="带有具体实现的特质">带有具体实现的特质</h2>
<h2 id="带有特质的对象">带有特质的对象</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">Logged</span> </span>{
    <span class="keyword">def</span> log(msg: String){}
}
<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">Logged</span> </span>{
    <span class="keyword">def</span> withdraw(amount:Double){
        <span class="keyword">if</span>(amout &gt; balance) log(<span class="string">"INsufficient funds"</span>)
        <span class="keyword">else</span> ...
    }
}
</code></pre><p>可以在构造具体对象时”混入”一个更好的日志记录器的实现：</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String) { println(msg)}
}
<span class="keyword">val</span> acct = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> ConsoleLogger
<span class="keyword">val</span> acct2 = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> FileLogger
</code></pre><h2 id="叠加在一起的特质">叠加在一起的特质</h2>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String){
        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.Date() +<span class="string">" "</span> +msg)
    }
}

<span class="class"><span class="keyword">trait</span> <span class="title">ShorLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">override</span> <span class="keyword">def</span> log(msg: String){
        <span class="keyword">super</span>.log(
            <span class="keyword">if</span>(msg.length&lt;=maxLength) msg <span class="keyword">else</span> msg.substring(<span class="number">0</span>, maxLength -<span class="number">3</span>) + <span class="string">"..."</span>)
    }
}

<span class="keyword">val</span> acct1 = <span class="keyword">new</span> SavingsAccount <span class="keyword">with</span> ConsoleLogger <span class="keyword">with</span> TimestampLogger <span class="keyword">with</span> ShorLogger
acct1.withdraw() <span class="comment">// 打印： Wed Mar 18 07:40:16 CST 2015 Insufficient...</span>
</code></pre><p>特质从最后一个开始处理.</p>
<h2 id="重写抽象方法">重写抽象方法</h2>
<p>需要加上abstract关键字。</p>
<h2 id="特质中的字段">特质中的字段</h2>
<p>具体字段和抽象字段。</p>
<h2 id="特质的构造顺序">特质的构造顺序</h2>
<ul>
<li>首先调用超类的构造器</li>
<li>特质构造器在超类构造器之后，类构造器之前咨询</li>
<li>特质从左到右构造</li>
<li>每个特质当中，父特质先被构造</li>
<li>若多个特质共有一个父特质，那么父特质构造只会被构造一次</li>
<li>特质构造完毕后，子类被构造</li>
</ul>
<h2 id="初始化特质的字段">初始化特质的字段</h2>
<p>trait FileLogger extends Logger {<br>    val filename:String<br>    val out = new PrintStream(filename)<br>    def log(msg: String) { out.println(msg);out.flush() }<br>}</p>
<p>提前定义：</p>
<pre><code><span class="keyword">val</span> acct = <span class="keyword">new</span> {
    <span class="keyword">val</span> filename = <span class="string">"myapp.log"</span>
} <span class="keyword">with</span> SavingsAccount <span class="keyword">with</span> FileLogger

<span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> </span>{
    <span class="keyword">val</span> filename = <span class="string">"saving.log"</span>
} <span class="keyword">with</span> Account <span class="keyword">with</span> FileLogger {
    ...
}
</code></pre><h2 id="自身类型">自身类型</h2>
<p>可限定被混入指定类型的子类。</p>
<pre><code><span class="class"><span class="keyword">trait</span> <span class="title">LoggedException</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">this</span>:Exception =&gt;
        <span class="keyword">def</span> log() { log(getMessage())}
}

<span class="keyword">val</span> f = <span class="keyword">new</span> JFrame <span class="keyword">with</span> LoggedException <span class="comment">// Error：JFrame不是Exception的子类。</span>

<span class="class"><span class="keyword">trait</span> <span class="title">LoggedException</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{
    <span class="keyword">this</span>: { <span class="keyword">def</span> getMessage() :String } =&gt;
    <span class="keyword">def</span> log(){log(getMessage()}
} <span class="comment">// 特质可以混入任何拥有getMessage方法的类</span>
</code></pre><h1 id="11_操作符">11 操作符</h1>
<p>要点：</p>
<ul>
<li>标识符由字母，数字或运算符构成</li>
<li>一元和二元操作符其实是方法调用</li>
<li>操作符优先级取决于第一个字符，而结合性取决于最后一个字符</li>
<li>apply和update方法在对expr(args)表达式求值时被调用。</li>
<li>提取器从输入中提取元组或值的序列</li>
</ul>
<p>前置操作符(+,-,!, ~) 被转换成名为unary_操作符的方法调用。</p>
<pre><code>-a  <span class="comment">// a.unary_- 一样</span>
</code></pre><h2 id="apply和update方法">apply和update方法</h2>
<p>f(arg1, arg2, …) // =&gt; f.apply(arg1, arg2, …)</p>
<p>f(arg1, arg2, …) = value // =&gt; f.update(arg1, arg2, …, value)</p>
<p>被用于数组和映射。</p>
<p>apply进程用于伴生对象中， 用来构造对象而不用显式使用new.</p>
<pre><code>class Fraction(n: Int, d: Int){
    <span class="keyword">...</span>
}

object Fraction {
    def apply(n:Int, d:Int)= new Fraction(n,d)
}
</code></pre><h2 id="提取器">提取器</h2>
<p>如前所示，apply从分子和分母创建一个分数。而unapply方法就是取出分子和分母：</p>
<pre><code><span class="attribute">var Fraction(a,b) </span>=<span class="string"> Fraction(3,4) *Fraction(2,5)</span>
</code></pre><p>或者用于模式匹配：</p>
<pre><code>case Fraction(a,b) =&gt; <span class="keyword">...</span> // a, b 被绑定到分子和分母
</code></pre><p>unapply方法返回的是一个Option, 包含一个元组：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Fraction</span> </span>{
    <span class="keyword">def</span> unapply(input:Fraction) =
        <span class="keyword">if</span>(input.den == <span class="number">0</span>) None <span class="keyword">else</span> Some((input.num, input.den))
}
</code></pre><p>样例类自动具备apply和unapply方法。</p>
<p>带来单个参数：</p>
<pre><code>object Number {
    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span><span class="params">(input: String)</span>:</span> Option[Int] = 
        <span class="keyword">try</span>{
            Some(Integer.parseInt(input.trim)
        }catch{
            case ex: NumberFormatException =&gt;<span class="keyword">None</span>
        }
}

val Number(n) = <span class="string">"1729"</span>
</code></pre><p>提取器只是测试输入：</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">IsCompound</span> </span>{
    <span class="keyword">def</span> unapply(input: String)= input.contains(<span class="string">" "</span>)
}
</code></pre><p>给模式增加一个测试:</p>
<pre><code>authon match {
    case Name(first, last @ IsCompound()) =&gt; <span class="keyword">...</span>
    case Name(first, last) =&gt; <span class="keyword">...</span>
}
</code></pre><h2 id="unapplySeq方法">unapplySeq方法</h2>
<p>要提取任意长度的值的序列， 使用unapplySeq:</p>
<pre><code>object Nmae {
    def unapplySeq(input: String): Option[Seq[String]] =
        <span class="keyword">if</span>(input.trim == <span class="string">""</span>) None <span class="keyword">else</span> Some(input.trim.split(<span class="string">"\\s+"</span>))
}

author match {
    case Name(first, last) =&gt; <span class="keyword">...</span>
    case Name(first, middle, last) =&gt; <span class="keyword">...</span>
    case Name(first, <span class="string">"van"</span>, <span class="string">"der"</span>, last) =&gt; <span class="keyword">...</span>
}
</code></pre><h1 id="12_高阶函数">12 高阶函数</h1>
<p>要点：</p>
<ul>
<li>函数是“头等公民”， 跟数字一样</li>
<li>可创建匿名函数， 一般交给其他函数</li>
<li>函数参数可以给出需要稍后执行的行为</li>
<li>许多集合方法都接受函数参数</li>
<li>有很多预发简写</li>
<li>可以参加操作代码块的函数，看上去像内建的控制语句</li>
</ul>
<p>作为值的函数：</p>
<pre><code><span class="keyword">val</span> num = <span class="number">3.14</span>
<span class="keyword">val</span> <span class="keyword">fun</span> = ceil _  <span class="comment">// _ 意味着你确实自动是这个函数。从技术上讲_将ceil方法转成了函数</span>
</code></pre><p>调用：</p>
<pre><code><span class="keyword">fun</span>(num) <span class="comment">// = 4</span>
</code></pre><p>传递:</p>
<pre><code><span class="keyword">Array</span>(<span class="number">3.14</span>, <span class="number">1.42</span>, <span class="number">2.0</span>).<span class="keyword">map</span>(fun) // = <span class="keyword">Array</span>(<span class="number">4.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>)
</code></pre><p>带函数参数的函数：</p>
<pre><code>def valueAtOneQuarter<span class="function"><span class="params">(f: (Double) =&gt; Double)</span> = <span class="title">f</span><span class="params">(<span class="number">0.25</span>)</span>
<span class="title">valueAtOneQuarter</span><span class="params">(ceil _ )</span>// 1.0</span>
</code></pre><p>参数推断：</p>
<pre><code>valueAtOneQuarter(<span class="number">3</span> * _)
<span class="keyword">val</span> <span class="keyword">fun</span> = <span class="number">3</span> *_ <span class="comment">// 错误：无法推断类型</span>
<span class="keyword">val</span> <span class="keyword">fun</span> = <span class="number">3</span> *(_:Double) <span class="comment">//OK</span>
<span class="keyword">val</span> <span class="keyword">fun</span>:(Double)=&gt;Double = <span class="number">3</span> * _ <span class="comment">//OK</span>
</code></pre><p>一些高价函数：</p>
<ul>
<li>map</li>
<li>filter</li>
<li>reduceLeft :   ( 1 to 9 ).reduceLeft(<em> * </em>)</li>
</ul>
<h1 id="13_集合">13 集合</h1>
<p>要点：</p>
<ul>
<li>所有集合都扩展自Iterable特质</li>
<li>三大类：序列，集和映射。</li>
<li>都提供可变和不可变版本</li>
<li>列表要么是空的，要么拥有一头一尾，尾部本身又是一个列表。</li>
<li>集是无先后次序的集合</li>
<li>用LinkedHashSet来保留插入次序，或用SortedSet来安顺序进行迭代</li>
<li><ul>
<li>将元素添加到无先后次序的集合中， +: 和 :+ 向前或向后追加序列。 ++把两集合串联在一起; - 和 — 移除元素。</li>
</ul>
</li>
<li>Iterator和Seq特质有数十个常见操作的方法。</li>
<li>映射、折叠和拉链操作是很有用的技巧。</li>
</ul>
<p>:: 操作符从头到尾创建一个新列表：</p>
<pre><code>9 <span class="comment">:: List(4, 2)</span>
9 <span class="comment">:: 4 :: 2 :: Nil</span>
</code></pre><p>可用迭代器遍历列表:</p>
<pre><code>def sum(<span class="keyword">ls</span><span class="variable">t:</span> List[Int]) = 
    <span class="keyword">if</span>(lst == Nil) <span class="number">0</span> <span class="keyword">else</span> lst.head + sum(lst.tail)
</code></pre><p>或者模式匹配：</p>
<pre><code>def sum(lst: <span class="keyword">List</span>[Int]) =  lst match {
    <span class="keyword">case</span> Nil =&gt;<span class="number">0</span> 
    <span class="keyword">case</span> h :: t =&gt; h +sum(t)
}
</code></pre><p>scala类库已经有了sum方法。</p>
<p>iterator的重要方法：</p>
<ul>
<li>head, last, headOption, lastOption</li>
<li>tail, init</li>
<li>length, isEmpty</li>
<li>map(f), foreach(f), flatMap(f), collect(f)</li>
<li>reduceLeft(op), reduceRight(op), aggregate(init)(op, combineOp)</li>
<li>reduce(op)<br>…    </li>
</ul>
<p>与java集合的互操作：</p>
<pre><code><span class="keyword">import</span> scala<span class="built_in">.</span>collection<span class="built_in">.</span>JavaConversions<span class="built_in">.</span>_ <span class="comment">// import scala.collection.JavaConversions.propertiesAsScalaMap</span>
val props: scala<span class="built_in">.</span>collection<span class="built_in">.</span>mutable<span class="built_in">.</span><span class="built_in">Map</span><span class="preprocessor">[</span><span class="built_in">String</span>,<span class="built_in">String</span><span class="preprocessor">]</span><span class="markup"> = System.getProperties()</span>
</code></pre><p>从Scala集合到java的转换：</p>
<ul>
<li>asJavaCollection</li>
<li>asJavaIterable</li>
<li>asJavaIterator</li>
<li>asJavaEnumeration</li>
<li>…</li>
</ul>
<p>从Java集合到scala的转换:</p>
<ul>
<li>collectionAsScalaIterable</li>
<li>…</li>
</ul>
<p>线程安全的集合, 可混入以下六特质：</p>
<ul>
<li>SynchronizedBuffer</li>
<li>SynchronizedMap</li>
<li>SynchronizedPriorityQueue</li>
<li>SynchronizedQueue</li>
<li>SynchronizedSet</li>
<li>SynchronizedStack</li>
</ul>
<p>并行集合:</p>
<pre><code>coll.par.sum
coll.par.count(<span class="variable">_</span> <span class="comment">% 2 == 0)</span>
<span class="function"><span class="title">for</span><span class="params">(i &lt;- (<span class="number">0</span> until <span class="number">100</span>)</span>.<span class="title">par</span>) <span class="title">print</span><span class="params">(i + <span class="string">" "</span>)</span></span>
</code></pre><h1 id="14_模式匹配和样例类">14 模式匹配和样例类</h1>
<p>要点:</p>
<ul>
<li>match表达式是一个更好的switch</li>
<li>若没有模式匹配， 会抛出MatchError. 可用case _模式来避免。</li>
<li>模式可包含一个随意定义的条件，称为守卫。</li>
<li>可对表达式类型进行匹配； 优先选用模式而不是isInstanceOf/asInstanceOf.</li>
<li>可以匹配数组，元组和样例类的么偶是，然后将匹配到的不同部分绑定到变量。</li>
<li>在for表达式中，不能匹配的情况会被安静地跳过。</li>
<li>样例类是编译器会为之自动产出模式匹配所需要的方法的类。</li>
<li>样例类继承层级中的公共超类是sealed的。</li>
<li>用Option来存放对于可能存在也可能不存在的值- 比null更安全。</li>
</ul>
<p>守卫：</p>
<pre><code>ch match {
    <span class="reserved">case</span> <span class="string">'+'</span><span class="function"> =&gt;</span> sign = <span class="number">1</span>
    <span class="reserved">case</span> <span class="string">'-'</span><span class="function"> =&gt;</span> sign = -<span class="number">1</span>
    <span class="reserved">case</span> _ <span class="keyword">if</span> Character.isDigit<span class="function"><span class="params">(ch)</span> =&gt;</span> digit = Character.digit(ch,<span class="number">10</span>)
    <span class="reserved">case</span> _<span class="function"> =&gt;</span>sign = <span class="number">0</span>
}
</code></pre><p>类型模式：</p>
<pre><code>obj match {
    <span class="keyword">case</span> x: Int =&gt; x
    <span class="keyword">case</span> s: String =&gt; Integer.parseInt(s)
    <span class="keyword">case</span> _: BigInt =&gt;Int.MaxValue
    <span class="keyword">case</span> _ =&gt;<span class="number">0</span>
}
</code></pre><p>匹配数组，列表和元组:</p>
<pre><code>arr match {
    <span class="reserved">case</span> Array<span class="function"><span class="params">(<span class="number">0</span>)</span> =&gt;</span><span class="string">"0"</span>
    <span class="reserved">case</span> Array<span class="function"><span class="params">(x,y)</span> =&gt;</span> x + <span class="string">" "</span>+ y
    <span class="reserved">case</span> Array<span class="function"><span class="params">(<span class="number">0</span>, _*)</span> =&gt;</span> <span class="string">"0 ..."</span>
    <span class="reserved">case</span> _<span class="function"> =&gt;</span> <span class="string">"something else"</span>
}

lst match {
    <span class="reserved">case</span> <span class="number">0</span> ::Nil<span class="function"> =&gt;</span><span class="string">"0"</span>
    <span class="reserved">case</span> x :: y ::Nil<span class="function"> =&gt;</span> x+ <span class="string">" "</span> + y
    <span class="reserved">case</span> _<span class="function"> =&gt;</span> <span class="string">"something else"</span>
}
</code></pre><h3 id="样例类">样例类</h3>
<pre><code><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Dollar</span><span class="params">(value: Double)</span> <span class="keyword">extends</span> <span class="title">Amount</span></span>
<span class="keyword">case</span> calss Currency(value: Doublie, unit: String) <span class="keyword">extends</span> Amount
</code></pre><p>也可以针对单例的样例对象:</p>
<pre><code><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nothing</span> <span class="keyword">extends</span> <span class="title">Amount</span></span>
</code></pre><p>使用模式匹配:</p>
<pre><code>amt match {
    <span class="reserved">case</span> Dollar<span class="function"><span class="params">(v)</span> =&gt;</span>  <span class="string">"$"</span> +v
    <span class="reserved">case</span> Currency(_, u) = &gt; <span class="string">"Oh nose, I got "</span>+ u
    <span class="reserved">case</span> Nothing<span class="function"> =&gt;</span><span class="string">""</span>
}
</code></pre><p>声明样例类，自动发送以下事情：</p>
<ul>
<li>构造器中的每个参数都成为val</li>
<li>在伴生对象中提供apply方法让你不用new关键字就构造出相应对象</li>
<li>提供unapply方法让模式匹配可以工作</li>
<li>将生成toString, equals, hashCode和copy方法— 除非显式给出这些方法的定义</li>
</ul>
<p>copy方法,创建一个域现有对象值相同的新对象。</p>
<h3 id="匹配嵌套结构">匹配嵌套结构</h3>
<h3 id="密封类">密封类</h3>
<pre><code><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>
</code></pre><p>模拟枚举：</p>
<pre><code><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Red</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Yellow</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Green</span> <span class="keyword">extends</span> <span class="title">TrafficColor</span></span>

color <span class="keyword">match</span> {
    <span class="keyword">case</span> Red =&gt; <span class="string">"stop"</span>
    <span class="keyword">case</span> Green =&gt; <span class="string">"go"</span>
    <span class="keyword">case</span> Yellow =&gt; <span class="string">"Hurry up"</span>
}
</code></pre><h3 id="Option_类型">Option 类型</h3>
<p>表示可能存在，也不可能存在。<br>支持泛型。</p>
<pre><code>val aliceScore = scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>)
<span class="keyword">if</span>(aliceScore.isEmpty) <span class="built_in">println</span>(<span class="string">"no score"</span>)
<span class="keyword">else</span> <span class="built_in">println</span>(aliceScore.<span class="keyword">get</span>)

<span class="built_in">println</span>(aliceScore.getOrElse(<span class="string">"no score"</span>))
<span class="built_in">println</span>(scores.getOrElse(<span class="string">"Alice"</span>, <span class="string">"no score"</span>))
</code></pre><p>若想略过None:</p>
<pre><code><span class="keyword">for</span>(score &lt;- scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>)) <span class="built_in">println</span>(score)
scores.<span class="keyword">get</span>(<span class="string">"Alice"</span>).foreach(<span class="built_in">println</span> <span class="number">_</span>)
</code></pre><h2 id="偏函数">偏函数</h2>
<p>被包在花括号内的一组case语句是一个偏函数 —  一个并非对所有输入值都有定义的函数。</p>
<h1 id="15_注解">15 注解</h1>
<ul>
<li>可以为类， 方法，字段， 局部变量，参数，表达式，类型参数以及各种类型添加注解</li>
<li>对于表达式和类型，注解跟在被注解条目之后</li>
<li>注解的形式: @Annotation @Annotation(value) 或 @Annotation(name1=value1,…)</li>
<li>@volatile @transient @strictfp 和@native分别生成等效的java修饰符</li>
<li>@throws来生成与java兼容的throws规格说明</li>
<li>@tailrec注解让你校验某个递归函数使用了尾递归优化</li>
<li>assert函数利用了@eldable注解，你可以移除所有断言</li>
<li>@deprecated注解标记已过时的特性</li>
</ul>
<h1 id="16_XML处理">16 XML处理</h1>
<h1 id="17_类型参数">17 类型参数</h1>
<h1 id="18_高级类型">18 高级类型</h1>
<h1 id="19_解析">19 解析</h1>
<h1 id="20_Actor">20 Actor</h1>
<h1 id="21_隐式转换和隐式参数">21 隐式转换和隐式参数</h1>
<h1 id="22_定界延续">22 定界延续</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/07/scala快学/" data-id="vbw899bc9g9rfzk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何记笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/04/如何记笔记/" class="article-date">
  <time datetime="2015-03-04T06:30:39.000Z" itemprop="datePublished">3月 4 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/04/如何记笔记/">如何记笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="记笔记的目的">记笔记的目的</h1>
<ul>
<li>加深记忆, 稳定心绪. (看书有时候看不进去，通过记笔记，可以稳定心绪)</li>
<li>系统整理书的知识体系</li>
<li>看笔记就能想起书的内容, 可以完整反应书本内容， 可以扔掉原书</li>
</ul>
<h1 id="方法">方法</h1>
<ol>
<li><p>一本书应该被读两遍，而且只读两遍。</p>
<ul>
<li>第一步正常通读，放松欣赏</li>
<li>第二遍写下读书笔记，可以供以后重温，直接看笔记即可</li>
</ul>
</li>
<li><p>按照原书的章节给读书笔记划分章节，甚至保留各章的标题. 写下每章作者到底想说什么。<br>写出作者的逻辑脉络。</p>
</li>
<li><p>颜色和字体的变化可以起到自动突出重点和分类的作用。</p>
</li>
<li><p>要注意给将来使用搜索引擎留下线索。也就是说要把关键字，人名地名组织名等记好</p>
</li>
<li><p>主动式的阅读。在笔记中写下自己对此书的评论。统一做法是把自己的评论全部放在方括号【】中。</p>
</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li>用强力研读书: <a href="http://www.geekonomics10000.com/376" target="_blank" rel="external">http://www.geekonomics10000.com/376</a></li>
<li>三遍读书法: <a href="http://www.codeceo.com/article/how-i-read-programming-books.html" target="_blank" rel="external">http://www.codeceo.com/article/how-i-read-programming-books.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/03/04/如何记笔记/" data-id="h0er2ax0f7tpdgt7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/如何记笔记/">如何记笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java核心技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/27/java核心技术/" class="article-date">
  <time datetime="2015-02-27T09:11:30.000Z" itemprop="datePublished">2月 27 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/27/java核心技术/">java核心技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_流与文件">1. 流与文件</h1>
<h2 id="流">流</h2>
<p>输入流</p>
<p>输出流</p>
<p>抽象类：InputStream和OutputStream</p>
<h1 id="2-_XML">2. XML</h1>
<h1 id="3-_网络">3. 网络</h1>
<h1 id="4-_数据库编程">4. 数据库编程</h1>
<h1 id="5-_国际化">5. 国际化</h1>
<h1 id="6-_高级swing">6. 高级swing</h1>
<h1 id="7-_高级AWT">7. 高级AWT</h1>
<h1 id="8-_JavaBean构件">8. JavaBean构件</h1>
<h1 id="9-_安全">9. 安全</h1>
<h1 id="10-_脚本，编译与注解处理">10. 脚本，编译与注解处理</h1>
<h1 id="11-_分布式对象">11. 分布式对象</h1>
<h1 id="12-_本地方法">12. 本地方法</h1>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuqiao.github.io/2015/02/27/java核心技术/" data-id="g4fg92x6t3nqeuwt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Erlang/" style="font-size: 12.50px;">Erlang</a><a href="/tags/Ice/" style="font-size: 12.50px;">Ice</a><a href="/tags/Vim/" style="font-size: 12.50px;">Vim</a><a href="/tags/golang/" style="font-size: 12.50px;">golang</a><a href="/tags/hadoop/" style="font-size: 15.00px;">hadoop</a><a href="/tags/hbase/" style="font-size: 12.50px;">hbase</a><a href="/tags/java/" style="font-size: 17.50px;">java</a><a href="/tags/javascript/" style="font-size: 15.00px;">javascript</a><a href="/tags/node/" style="font-size: 12.50px;">node</a><a href="/tags/program/" style="font-size: 15.00px;">program</a><a href="/tags/scala/" style="font-size: 12.50px;">scala</a><a href="/tags/scalao/" style="font-size: 10.00px;">scalao</a><a href="/tags/think/" style="font-size: 12.50px;">think</a><a href="/tags/tool/" style="font-size: 15.00px;">tool</a><a href="/tags/分布式系统/" style="font-size: 12.50px;">分布式系统</a><a href="/tags/如何记笔记/" style="font-size: 12.50px;">如何记笔记</a><a href="/tags/笔记/" style="font-size: 20.00px;">笔记</a><a href="/tags/管理/" style="font-size: 12.50px;">管理</a><a href="/tags/读书笔记/" style="font-size: 12.50px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/19/代码的未来/">代码的未来</a>
          </li>
        
          <li>
            <a href="/2015/03/17/深入理解JVM虚拟机/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/03/15/思考，快与慢/">思考，快与慢</a>
          </li>
        
          <li>
            <a href="/2015/03/14/Go并发编程实战/">Go并发编程实战</a>
          </li>
        
          <li>
            <a href="/2015/03/12/javascript高级程序设计/">javascript高级程序设计</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Peter Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>
